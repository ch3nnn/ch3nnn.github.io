<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ch3nnn个人博客</title>
    <link>https://ch3nnn.github.io/</link>
    
    <atom:link href="https://ch3nnn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>小站主要用来分享和记录学习经验,教程,记录个人生活的点滴以及一些随笔.</description>
    <pubDate>Tue, 11 Apr 2023 02:52:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang-常见数据结构Map</title>
      <link>https://ch3nnn.github.io/2023/04/11/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map/</link>
      <guid>https://ch3nnn.github.io/2023/04/11/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map/</guid>
      <pubDate>Tue, 11 Apr 2023 02:07:33 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h2&gt;&lt;p&gt;map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。</p><p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表， 有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 <code>O(1)</code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。</p><p>完美哈希函数如图:<br><img src="https://cdn.ch3nnn.cn/img202304111020765.png"></p><p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。</p><p> 不均匀哈希函数如图:<br><img src="https://cdn.ch3nnn.cn/img202304111022378.png"></p><p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p><p><strong>开放寻址法</strong><br>开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从索引开始遍历</p><p>当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置<br>开放地址法写入数据如图:<br><img src="https://cdn.ch3nnn.cn/img202304111027414.png"><br>如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p><p>开放地址法读取数据如图:<br><img src="https://cdn.ch3nnn.cn/img202304111029114.png"></p><p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。</p><p>开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。</p><p><strong>拉链法</strong></p><p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p><p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：<br>拉链法写入数据如图:<br><img src="https://cdn.ch3nnn.cn/img202304111030711.png"></p><p>如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模</p><p>选择了 2 号桶之后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p><p>找到键相同的键值对 —— 更新键对应的值；<br>没有找到键相同的键值对 —— 在链表的末尾追加新键值对；将键值对写入哈希之后，要通过某个键在其中获取映射的值，就会经历如下的过程：<br><img src="https://cdn.ch3nnn.cn/img202304111037651.png"></p><p>Key11 展示了一个键在哈希表中不存在的例子，当哈希表发现它命中 4 号桶时，它会依次遍历桶中的链表，然而遍历到链表的末尾也没有找到期望的键，所以哈希表中没有该键对应的值。</p><p>在一个性能比较好的哈希表中，每一个桶中都应该有 0-1 个元素，有时会有 2-3 个，很少会超过这个数量，计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：<br><code>装载因子 := 元素数量 / 桶数量</code><br>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1&#x2F;10，但是仍然比在链表中直接读写好 1000 倍。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 hmap 结构体来表示哈希，我们先来看一下这个结构体内部的字段：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span></span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span></span><br><span class="line">    noverflow <span class="type">uint16</span></span><br><span class="line">    hash0     <span class="type">uint32</span></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line">    nevacuate  <span class="type">uintptr</span></span><br><span class="line">    extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>count</code> 表示当前哈希表中的元素数量；<br><code>B</code> 表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 len(buckets) &#x3D;&#x3D; 2^B；<br><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；<br><code>oldbuckets</code> 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；</p><p> 哈希表的数据结构如图:<br><img src="https://cdn.ch3nnn.cn/img202304111044236.png"></p><p>如上图所示哈希表 hmap 的桶就是 bmap，每一个 bmap 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶无法装满时就会使用 extra.overflow 中桶存储溢出的数据。上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 bmap 就是正常桶，绿色的 bmap 是溢出桶，溢出桶是在 Go 语言还使用 C 语言实现时就使用的设计3，由于它能够减少扩容的频率所以一直使用至今。</p><p>这个桶的结构体 bmap 在 Go 语言源代码中的定义只包含一个简单的 tophash 字段，tophash 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap 结构体其实不止包含 tophash 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段，但是我们能根据编译期间的 cmd&#x2F;compile&#x2F;internal&#x2F;gc.bmap 函数对它的结构重建：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果哈希表存储的数据逐渐增多，我们会对哈希表进行扩容或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime.mapassign</code> 函数会在以下两种情况发生时触发哈希的扩容：</p><ul><li>装载因子已经超过 6.5；</li><li>哈希使用了太多溢出桶；不过由于 Go 语言哈希的扩容不是一个原子的过程，所以 <code>runtime.mapassign</code> 函数还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</li></ul><p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 sameSizeGrow，sameSizeGrow 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏。runtime: limit the number of map overflow buckets 引入了 sameSizeGrow 通过重用已有的哈希扩容机制，一旦哈希中出现了过多的溢出桶，它就会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存5。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">Go 语言设计与实现-哈希表</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/04/11/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务 API 网关对比和选型</title>
      <link>https://ch3nnn.github.io/2023/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</link>
      <guid>https://ch3nnn.github.io/2023/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</guid>
      <pubDate>Tue, 04 Apr 2023 08:45:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务&quot;&gt;&lt;/a&gt;什么是微服务&lt;/h2&gt;&lt;p&gt;微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。<br>在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。微服务是互联网业务发展的结果，互联网业务的飞速发展导致系统的架构也在不断地发生变化，总体来说，系统的架构大致经历了：单体应用架构—&gt;<br>SOA 架构—&gt;微服务架构 的演变，具体发展历程和各自的优缺点如下表所示。<br><img src="https://cdn.ch3nnn.cn/img202304041708571.png"></p><p>因此，微服务是互联网发展的必然结果，很多传统公司的系统架构也在逐步微服务化。但是，随着互联网业务的发展，API 的数量也在剧增，使用网关对API统一管理也将面临挑战，选择一个更强大的<br>API 网关，可以有效地增强系统的监控、容灾、鉴权和限流等能力。</p><h2 id="什么是微服务网关"><a href="#什么是微服务网关" class="headerlink" title="什么是微服务网关"></a>什么是微服务网关</h2><p><strong>API网关是一个服务器，是系统的唯一入口。</strong> 从面向对象设计的角度看，它与外观模式类似。</p><p>API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。</p><p><strong>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。</strong> 通常，网关也是提供REST&#x2F;HTTP的访问API。<br><img src="https://cdn.ch3nnn.cn/img202304162258745.png"></p><p>微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：</p><p>数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。<br>控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。</p><p><strong>微服务遇到的挑战</strong></p><p>微服务网关应该首先要具备 API 路由能力，微服务数量变多，API 数量急剧增加，网关还可以根据具体的场景作为流量过滤器来使用，以提供某些额外可选功能，因此对微服务<br>API Gateway 提出了更高要求，比如：</p><ul><li>可观测性：在以往的单体应用中，排查问题往往通过查看日志定位错误信息和异常堆栈；但是在微服务架构中服务繁多，出现问题时的问题定位变得非常困难；因此，如何监控微服务的运行状况、当出现异常时能快速给出报警，这给开发人员带来很大挑战。</li><li></li></ul><p>鉴权认证：而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其它服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在微服务架构下，要考虑外部应用接入的场景、用户 -</p><ul><li>服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。</li><li>系统稳定性：若大量请求超过微服务的处理能力时，可能会将服务打垮，甚至产生雪崩效应、影响系统的整体稳定性。</li><li>服务发现：微服务的分散管理，让微服务的负载均衡的实现也更具有挑战性。</li></ul><p><strong>解决方案</strong></p><p>API 网关作为客户端和服务端的中间桥梁，为微服务系统提供统一的管理机制：<br>除了基础的请求分发、API 管理和条件路由等功能，还包括身份验证、监控报警、调用链追踪、负载均衡、限流隔离和熔断降级。身份认证：下图表示的是微服务联合<br>API 网关如何进行身份认证的，由图可见所有请求都通过网关，从而有效地隐藏了微服务。</p><p><img src="https://cdn.ch3nnn.cn/img202304041714043.png"><br>监控报警&#x2F;调用链追踪：<br>API 作为客户端和服务端的中间桥梁，是微服务监控的最好载体，API 网关监控功能的主要职责是及时发现网关以及后端服务器的连接异常，在 API<br>的监控平台上面用户可以随时查看日志信息，监控信息，调用链等等，并且主机发生的任何异常都会自动报警到控制台。有些网关甚至可以做到给客户端和服务端双向报警。</p><p><img src="https://cdn.ch3nnn.cn/img202304041714673.png"></p><p>限流隔离&#x2F;熔断降级：<br>随着互联网业务规模的增加，系统的并发度增高，多个服务之间相互调用链路，一条核心链路往往可能调用十个服务。如果在链路中，某个服务的<br>rt（响应时间）急剧上升，上游服务不断请求，造成恶性循环，上游等待结果线程数越多，使得更上游服务阻塞最终整条链路无法使用，从而导致服务雪崩，所以对入口流量进行整治管理是很有必要的，下图表示微服务系统是如何结合<br>API 网关进行限流隔离和熔断降级的。</p><p><img src="https://cdn.ch3nnn.cn/img202304041715894.png"></p><h2 id="主流网关选择"><a href="#主流网关选择" class="headerlink" title="主流网关选择"></a>主流网关选择</h2><p>在微服务领域，有许多开源网关实现，有 NGINX、Kong、Apache APISIX 和 Envoy 等，Java 技术栈的有 Netfilx Zuul、Spring Cloud Gateway、Soul 等。或许你会问“有了<br>NGINX 和 Kong，为什么还需要 Apache APISIX？” ，下面做个简单对比。</p><table><thead><tr><th>网关</th><th>痛点</th><th>优势</th></tr></thead><tbody><tr><td>NGINX</td><td>修改配置需要 Reload 才能生效，跟不上云原生的发展。</td><td>1. 老牌应用；2. 稳定可靠，久经考验；3. 高性能。</td></tr><tr><td>Apache APISIX</td><td>文档不够丰富和清晰，需要待改进。</td><td>1. Apache 基金会顶级项目；2. 技术架构更贴合云原生；3. 性能表现优秀；4. 生态丰富；5. 除了支持 Lua 开发插件外，还支持 Java、Go、Python、Node 等语言插件</td></tr><tr><td>Kong</td><td>1. 默认使用 PostgreSQL 或 Cassandra 数据库，使得整个架构非常臃肿，并且会带来高可用的问题；2. 路由使用的是遍历查找，当网关内有超过上千个路由时，它的性能就会出现比较急剧的下降；3. 一些重要功能是需要付费的。</td><td>1. 开源 API 网关的鼻祖，用户数众多；2. 性能满足大部分用户的需求；3. 生态丰富；4. 支持 Lua 和 Go 开发插件。</td></tr><tr><td>Spring Cloud Gateway</td><td>虽然 Spring 社区成熟，但是 Gateway 资源缺乏。</td><td>1. 内置了非常多的开箱即用功能，并且都可以通过 SpringBoot 配置或者手工编码链式调用来使用；2. Spring 系列可扩展性强，易配置，可维护性好；   3. Spring 社区成熟；4. 简单易用；5. 对于 Java 技术栈来说方便</td></tr><tr><td>Traefik</td><td>生产案例不太多</td><td>1. 基于 golang开发 2. 云原生可编程 api&#x2F;对接各种服务发现</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/l9Nvlyg95KSdoo6iU6Fh4Q">微服务为什么要用到 API 网关？</a><br><a href="https://juejin.cn/post/7063244165538119710">5 种主流API网关技术选型，yyds！</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <comments>https://ch3nnn.github.io/2023/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-channel通道</title>
      <link>https://ch3nnn.github.io/2023/03/19/Golang-channel%E9%80%9A%E9%81%93/</link>
      <guid>https://ch3nnn.github.io/2023/03/19/Golang-channel%E9%80%9A%E9%81%93/</guid>
      <pubDate>Sun, 19 Mar 2023 09:41:05 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;goroutine 和 channel (通道)并成为 Go 并发的两大基石。channel 可以放心地在多个 goroutine 之间使用, 因为它是并发安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;channel-有哪些应用&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>goroutine 和 channel (通道)并成为 Go 并发的两大基石。channel 可以放心地在多个 goroutine 之间使用, 因为它是并发安全的。</p></blockquote><h2 id="channel-有哪些应用"><a href="#channel-有哪些应用" class="headerlink" title="channel 有哪些应用"></a>channel 有哪些应用</h2><p><strong>停止信号</strong><br>channel 用于停止信号的场景很多，通常是通过关闭某个channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作，如停止某个循环等。</p><p><strong>定时任务</strong><br>与计时器结合，一般有两种做法：实现超时控制、实现定期执行某个任务。<br>有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定。这就是时控制：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(<span class="number">100</span>*time.Millisecond):</span><br><span class="line"><span class="keyword">case</span> &lt;- s.stopc:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。</p><p>定时执行某个任务，也比较简单：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ticker:</span><br><span class="line"><span class="comment">// 执行定时任务</span></span><br><span class="line">fmt.Println(<span class="string">&quot;执行 1s 定时任务&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每隔 1 秒种，执行一次定时任务。</p><p><strong>解耦生产方和消费方</strong><br>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">taskCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">go</span> worker(taskCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 塞任务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">taskCh &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1 小时 </span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Hour):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(taskCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> N = <span class="number">5</span></span><br><span class="line"><span class="comment">// 启动 5 个工作协程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">task := &lt;- taskCh</span><br><span class="line">fmt.Printf(<span class="string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。<br>程序输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">finish task: 1 by worker 4</span><br><span class="line">finish task: 2 by worker 2</span><br><span class="line">finish task: 4 by worker 3</span><br><span class="line">finish task: 3 by worker 1</span><br><span class="line">finish task: 0 by worker 0</span><br><span class="line">finish task: 6 by worker 0</span><br><span class="line">finish task: 8 by worker 3</span><br><span class="line">finish task: 9 by worker 1</span><br><span class="line">finish task: 7 by worker 4</span><br><span class="line">finish task: 5 by worker 2</span><br></pre></td></tr></table></figure><p><strong>控制并发数</strong><br>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。<br>channel 来控制并发数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            limit &lt;- <span class="number">1</span></span><br><span class="line">            w()</span><br><span class="line">            &lt;-limit</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// …………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p><h3 id="channel-数据结构"><a href="#channel-数据结构" class="headerlink" title="channel 数据结构"></a>channel 数据结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// chan 里元素数量</span></span><br><span class="line">qcount   <span class="type">uint</span></span><br><span class="line"><span class="comment">// chan 底层循环数组的长度</span></span><br><span class="line">dataqsiz <span class="type">uint</span></span><br><span class="line"><span class="comment">// 指向底层循环数组的指针</span></span><br><span class="line"><span class="comment">// 只针对有缓冲的 channel</span></span><br><span class="line">buf      unsafe.Pointer</span><br><span class="line"><span class="comment">// chan 中元素大小</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line"><span class="comment">// chan 是否被关闭的标志</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line"><span class="comment">// chan 中元素类型</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line"><span class="comment">// 已发送元素在循环数组中的索引</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line"><span class="comment">// 已接收元素在循环数组中的索引</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line"><span class="comment">// 等待接收的 goroutine 队列</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line"><span class="comment">// 等待发送的 goroutine 队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护 hchan 中所有字段</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于字段的含义都写在注释里了，再来重点说几个字段：</p><p>buf 指向底层循环数组，只有缓冲型的 channel 才有。</p><p>sendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p><p>sendq，recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p><p>waitq 是 sudog 的一个双向链表，而 sudog 实际上是对 goroutine 的一个封装：</p><pre><code>type waitq struct &#123;    first *sudog    last  *sudog&#125;</code></pre><p>lock 用来保证每个读 channel 或写 channel 的操作都是原子的。</p><h2 id="收发数据的本质"><a href="#收发数据的本质" class="headerlink" title="收发数据的本质"></a>收发数据的本质</h2><blockquote><p>All transfer of value on the go channels happens with the copy of value.</p></blockquote><p>就是说 channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。<br>举一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = user&#123;name: <span class="string">&quot;Ankur&quot;</span>, age: <span class="number">25</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g = &amp;u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyUser</span><span class="params">(pu *user)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;modifyUser Received Vaule&quot;</span>, pu)</span><br><span class="line">pu.name = <span class="string">&quot;Anand&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUser</span><span class="params">(u &lt;-<span class="keyword">chan</span> *user)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;printUser goRoutine called&quot;</span>, &lt;-u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> *user, <span class="number">5</span>)</span><br><span class="line">c &lt;- g</span><br><span class="line">fmt.Println(g)</span><br><span class="line"><span class="comment">// modify g</span></span><br><span class="line">g = &amp;user&#123;name: <span class="string">&quot;Ankur Anand&quot;</span>, age: <span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">go</span> printUser(c)</span><br><span class="line"><span class="keyword">go</span> modifyUser(g)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>&amp;&#123;Ankur 25&#125;modifyUser Received Vaule &amp;&#123;Ankur Anand 100&#125;printUser goRoutine called &amp;&#123;Ankur 25&#125;&amp;&#123;Anand 100&#125;</code></pre><h2 id="channel-如何优雅关闭通道"><a href="#channel-如何优雅关闭通道" class="headerlink" title="channel 如何优雅关闭通道"></a>channel 如何优雅关闭通道</h2><p>有两个不那么优雅地关闭 channel 的方法：</p><ul><li>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。</li><li>使用 sync.Once 来保证只关闭一次。</li></ul><p>那到底应该如何优雅地关闭 channel？<br>根据 sender 和 receiver 的个数，分下面几种情况：</p><ol><li>一个 sender，一个 receiver</li><li>一个 sender， M 个 receiver</li><li>N 个 sender，一个 reciver</li><li>N 个 sender， M 个 receiver</li></ol><p>对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。</p><p>第 3 种情形下，优雅关闭 channel 的方法是：the only receiver says “please stop sending more” by closing an additional signal channel。</p><p>解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止接收数据。代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- rand.Intn(Max):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            <span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;send stop signal to senders.&quot;</span>)</span><br><span class="line">                <span class="built_in">close</span>(stopCh)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fmt.Println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 stopCh 就是信号 channel，它本身只有一个 sender，因此可以直接关闭它。senders 收到了关闭信号后，select 分支 “case &lt;- stopCh” 被选中，退出函数，不再发送数据。<br>需要说明的是，上面的代码并没有明确关闭 dataCh。在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭 channel，让 gc 代劳。</p><p>最后一种情况，优雅关闭 channel 的方法是：any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel。<br>和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line">    <span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It must be a buffered channel.</span></span><br><span class="line">    toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stoppedBy <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// moderator</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stoppedBy = &lt;-toStop</span><br><span class="line">        <span class="built_in">close</span>(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                value := rand.Intn(Max)</span><br><span class="line">                <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// receivers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">                    <span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    fmt.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(time.Hour):</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里 toStop 就是中间人的角色，使用它来接收 senders 和 receivers 发送过来的关闭 dataCh 请求。<br>这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。</p><p>更本质的原则：</p><blockquote><p>don’t close (or send values to) closed channels.</p></blockquote><h2 id="channel-在什么情况下会引起资源泄漏"><a href="#channel-在什么情况下会引起资源泄漏" class="headerlink" title="channel 在什么情况下会引起资源泄漏"></a>channel 在什么情况下会引起资源泄漏</h2><p>Channel 可能会引发 goroutine 泄漏。<br>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。<br>另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏。</p><h2 id="操作-channel-的情况总结"><a href="#操作-channel-的情况总结" class="headerlink" title="操作 channel 的情况总结"></a>操作 channel 的情况总结</h2><p>总结一下操作 channel 的结果：</p><ol><li>给一个 nil channel 发送数据，造成永远阻塞 </li><li>从一个 nil channel 接收数据，造成永远阻塞 </li><li>给一个已经关闭的 channel 发送数据，引起 panic </li><li>从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 </li><li>无缓冲的channel是同步的，而有缓冲的channel是非同步的</li></ol><p>以上5个特性是死东西，也可以通过口诀来记忆：<strong>“空读写阻塞，写关闭异常，读关闭空零”</strong>。</p><p>总结一下，发生 panic 的情况有三种：</p><ol><li>向一个关闭的 channel 进行写操作；</li><li>关闭一个 nil 的 channel；</li><li>重复关闭一个 channel。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://qcrao91.gitbook.io/go/channel">码农桃花源-channel</a><br><a href="https://www.yuque.com/aceld/golang/ahkkr1">Golang修养之路-channel</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/19/Golang-channel%E9%80%9A%E9%81%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-垃圾回收</title>
      <link>https://ch3nnn.github.io/2023/03/18/Golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <guid>https://ch3nnn.github.io/2023/03/18/Golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <pubDate>Sat, 18 Mar 2023 15:21:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。&lt;/p&gt;
&lt;h3 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>目前比较常见的垃圾回收算法有三种：<br><strong>引用计数</strong>：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。</p><ul><li>代表语言：Python、PHP、Swift </li><li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。 </li><li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li></ul><p><strong>标记-清除</strong>：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。</p><ul><li>代表语言：Golang（三色标记法） </li><li>优点：解决了引用计数的缺点。 </li><li>缺点：需要 STW，暂时停掉程序运行。</li></ul><p><strong>分代收集</strong>：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。</p><ul><li>代表语言：Java</li><li>优点：回收性能好</li><li>缺点：算法复杂</li></ul><h3 id="Golang-垃圾回收"><a href="#Golang-垃圾回收" class="headerlink" title="Golang 垃圾回收"></a>Golang 垃圾回收</h3><h4 id="Go1-3之前-标记清除法"><a href="#Go1-3之前-标记清除法" class="headerlink" title="Go1.3之前 标记清除法"></a>Go1.3之前 标记清除法</h4><ol><li>进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的内存占用和可达的内存占用</li><li>开始标记，程序找出可达内存占用并做标记</li><li>标记结束清除未标记的内存占用</li><li>结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束</li></ol><p><img src="https://s2.loli.net/2023/03/18/eaq4SfrMFOHYxVI.png"></p><p>一开始的做法是将垃圾清理结束时才停止 STW，后来优化了方案将清理垃圾放到了 STW 之后，与程序运行同时进行，这样做减小了 STW 的时长。<br>但是 STW 会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的 STW 对于性能较高的程序还是无法接受，但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。<br>因此 Go1.5 采用了三色标记法优化了 STW。</p><h4 id="Go1-5之后-三色并发标记法"><a href="#Go1-5之后-三色并发标记法" class="headerlink" title="Go1.5之后 三色并发标记法"></a>Go1.5之后 三色并发标记法</h4><p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：</p><p>灰色：对象还在标记队列中等待<br>黑色：对象已被标记，gcmarkBits对应位为 1 – 该对象不会在本次 GC 中被回收<br>白色：对象未被标记，gcmarkBits对应位为 0 – 该对象将会在本次 GC 中被清理</p><p>三色标记法分五步进行:</p><ol><li>将所有对象标记为白色</li><li>从根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中</li><li>遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色</li><li>循环这个过程</li><li>直到灰色节点集合为空，回收所有的白色节点</li></ol><p>具体流程如下图:<br><img src="https://s2.loli.net/2023/03/19/Ob69hxsuAJZYmGE.png"></p><p>回收原理:<br>通过上图，应该对三色标记法有了一个比较直观的了解，那么我们现在来讲讲原理。简单的讲，就是标记内存中那些还在使用中（即被引用了）的部分，而内存中不再使用（即未被引用）的部分，就是要回收的垃圾，需要将其回收，以供后续内存分配使用。上图中的 A、B、D 就是被引用正在使用的内存，而C、F、E 曾经被使用过，但现在没有任何对象引用，就需要被回收掉。</p><p><strong>三色标记法缺点</strong><br>将 GC 和程序会放一起执行，会因为 cpu 的调度出现下面这种情况，导致被引用的对象 3 却被GC给“误杀”回收掉了，从而出现错误。<br><img src="https://s2.loli.net/2023/03/19/p1ANEKigV8PbHWS.png"></p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><ul><li>条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)</li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</li></ul><p>如果当以上两个条件同时满足时，就会出现对象丢失现象!</p><p><strong>屏障机制</strong><br>强三色不变式和弱三色不变式</p><ul><li>强三色不变式</li></ul><p><img src="https://s2.loli.net/2023/03/19/nBHRLtXmIQebVgK.png"><br>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><ul><li>弱三色不变式</li></ul><p><img src="https://s2.loli.net/2023/03/19/9QA7HSeZYVUtbIj.png"><br>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p><strong>插入屏障和删除屏障</strong></p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p><ul><li>插入屏障<br>对象被引用时触发的机制，当白色对象被黑色对象引用时，白色对象被标记为灰色（栈上对象无插入屏障）<br><img src="https://s2.loli.net/2023/03/19/zobvNwRKp8nyZj3.png"></li></ul><p>缺点在于：如果对象 1 在栈上新创建了一个对象 6，<strong>由于栈没有屏障机制，所以对象 6 仍为白色节点会被回收</strong><br>栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以<strong>“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中</strong>.</p><p><img src="https://s2.loli.net/2023/03/19/R143m69xfcUSeBI.png"><br>所以栈在 GC 迭代结束时（没有灰色节点），会对栈执行 STW，重新进行扫描清除白色节点。（STW 时间为 10-100ms）</p><ul><li>删除屏障<br>对象被删除时触发的机制。如果灰色对象引用的白色对象被删除时，那么白色对象会被标记为灰色。<br><img src="https://s2.loli.net/2023/03/19/WUq9Yv2MjfoCKeP.png"></li></ul><p>缺点在于：这种做法回收精度较低，一个对象即使被删除仍可以活过这一轮再下一轮被回收。（如果对象 4 没有引用对象 3，此时对象 3 应该作为垃圾被回收，但是对象 3 却要等到下一轮 GC 才会被回收）<br><img src="https://s2.loli.net/2023/03/19/jxFnmhskMlfNqCX.png"><br>同样也存在对栈的二次扫描影响程序的效率。</p><h3 id="Go1-8-三色标记-混合写屏障-hybrid-write-barrier-机制"><a href="#Go1-8-三色标记-混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="Go1.8 三色标记 + 混合写屏障(hybrid write barrier)机制"></a>Go1.8 三色标记 + 混合写屏障(hybrid write barrier)机制</h3><p><strong>插入写屏障和删除写屏障的短板：</strong></p><ul><li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； </li><li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</li></ul><p><strong>混合写屏障规则</strong></p><ol><li>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</li><li>GC期间，任何在栈上创建的新对象，均为黑色。</li><li>被删除的对象标记为灰色。</li><li>被添加的对象标记为灰色。</li></ol><p><img src="https://s2.loli.net/2023/03/19/kIz3o62gVsfSO4r.png"></p><h2 id="触发垃圾回收的时机"><a href="#触发垃圾回收的时机" class="headerlink" title="触发垃圾回收的时机"></a>触发垃圾回收的时机</h2><p>主动触发: </p><ul><li>通过调用 <code>runtime.GC</code> 来触发 GC, 此调用阻塞式等待当前 GC 运行完毕</li></ul><p>被动触发:</p><ul><li>定期触发GC (使用系统监控, 当超过 2 分钟没有产生任何 GC 时, 强制触发 GC)</li><li>内存分配量达到阀值触发GC (堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量 GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发 GC)</li></ul><h2 id="GO-GC-调优"><a href="#GO-GC-调优" class="headerlink" title="GO GC 调优"></a>GO GC 调优</h2><ol><li>控制内存分配的速度, 限制 <code>goroutine</code> 的数量, 从而提高对 CPU 的利用率</li><li>减少并复用内存, 例如使用<code>sysnc.Poll</code> 来复用需要频繁创建的临时对象, 例如提前分配足够的内存来降低多余的复制</li><li>增大 <code>GOGC</code> 的值, 降低 GC 的运行频率</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.yuque.com/aceld/golang/zhzanb#d067ac74">Golang三色标记混合写屏障GC模式全分析</a><br><a href="https://learnku.com/articles/59021#:~:text=%E5%9C%A8Go%20%E4%B8%AD%E6%A0%88%E4%B8%8A,%E5%9E%83%E5%9C%BE%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%82">图解Golang垃圾回收机制！</a><br><a href="https://blog.csdn.net/qq_35246620/article/details/53790350">浅析 Golang 垃圾回收机制</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/18/Golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-Modules的演进史</title>
      <link>https://ch3nnn.github.io/2023/03/13/Golang-Modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</link>
      <guid>https://ch3nnn.github.io/2023/03/13/Golang-Modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid>
      <pubDate>Mon, 13 Mar 2023 03:53:48 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。&lt;/p&gt;
&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。</p><p>使用<code> Go Modules</code> 模式，一般分为以下几个流程：</p><ul><li><code>go mod init</code> 创建一个新模块，初始化 <code>go.mod</code> 文件。</li><li><code>go build</code>、<code>go test</code>、<code>go run</code>、<code>go install</code> 等构建命令，向 <code>go.mod</code>文件中添加模块所需的依赖项。</li><li><code>go list -m -json all</code> 打印当前模块的依赖项。</li><li><code>go get</code> 添加依赖项，或修改依赖项版本。</li><li><code>go mod tidy</code> 删除未使用的依赖项。</li></ul><h2 id="Go-Modules-演进史"><a href="#Go-Modules-演进史" class="headerlink" title="Go Modules 演进史"></a>Go Modules 演进史</h2><p><strong>Go v1.11</strong><br>从 Go v1.11 开始支持 Go Moduls。<br>为了兼容使用 Go v1.11 之前的任意版本的项目，当设置 <code>GO111MODULE=auto</code> 或 <code>GO111MODULE=off</code> 时，Go v1.11 在 <code>$GOPATH/src</code> 中，继续使用 <code>GOPATH</code> 模式。<br>当设置 <code>GO111MODULE=auto</code> 时，其它任意位置，如果当前目录或父目录包含 go.mod 文件，则使用 Modules 模式。</p><blockquote><p>注意：GO111MODULE 包含三个模式，分别是 auto、on 和 off，其中默认值是 auto，即不显式设置 GO111MODULE 的值，默认是 auto 模式。</p></blockquote><p><strong>Go v1.13</strong><br>在 Go v1.13 中，Go Modules 发生一些变化：</p><p>当设置 <code>GO111MODULE=auto</code> 时，如果在任意位置找到 go.mod 文件，则使用 Go Modules 模式，即使在 <code>$GOPATH/src</code> 中。</p><blockquote><p>注意：在 Go v1.13 之前，即使 GO111MODULE&#x3D;auto，在 $GOPATH&#x2F;src 目录中也不会启动 Go Modules 模式。</p></blockquote><p>go get 的变化：</p><ul><li><code>go get -u （不包含任何参数）</code>，现在只升级当前包的直接和间接依赖，并且不再检查整个模块。</li><li><code>go get -u ./...</code> 从模块根升级模块的所有直接和间接依赖项，现在排除测试依赖项。</li><li><code>go get -u -t ./... </code>从模块根升级模块的所有直接和间接依赖项，而且还会升级测试依赖项。</li></ul><p><strong>Go v1.14</strong><br>从 Go v1.14 开始，模块被认为可以用于生产环境，并且鼓励所有用户从其他依赖管理系统迁移到模块。<br>当主模块包含一个顶级 vendor 目录，并且它的 go.mod 文件指定 go 1.14 或更高版本时，对于支持 <code>-mod=vendor</code> 的 go 命令，将默认添加 <code>-mod=vendor</code>。</p><p><strong>Go v1.15</strong><br>模块缓存的位置现在可以使用 <code>GOMODCACHE</code> 环境变量进行设置。<code>GOMODCACHE</code> 的默认值是 <code>GOPATH[0]/pkg/mod</code>，这也是不支持使用 <code>GOMODCACHE</code> 环境变量进行设置之前的模块缓存的位置。</p><blockquote><p>注意：可以使用 GOPATH 环境变量设置多个目录。</p></blockquote><p><strong>Go v1.16</strong><br>模块模式（<code>GO111MODULE=on</code>）默认开启，也就是说默认启用 Go Modules 模式，如果用户想要使用 GOPATH 模式，需要显式设置 <code>GO111MODULE=off</code> 或 <code>GO111MODULE=auto</code>（并且需要在 <code>$GOPATH/src</code> 目录）。<br>使用 <code>go install pkg@version</code> 替换 <code>go get pkg@version</code> 全局安装包和可执行文件。</p><blockquote><p>注意：在 Modules 模式 go get 不再用于构建或安装包，而是专门用于调整 go.mod 中的依赖项，如果在模块外执行 go get 将会报错，因为没有可更新的 go.mod 文件；在 GOPATH 模式（GO111MODULE&#x3D;off） go get 仍然构建和安装包。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍 Go Modules 模式在 Go 语言各个版本中的演进史，限于篇幅，仅介绍的在使用时常用操作的变化，我们最后做一下总结：</p><ol><li>Go v1.11  开始支持 Go Modules 模式</li><li>Go v1.13 在（包含 $GOPATH&#x2F;src ）任意目录找到 go.mod 文件，都开启 Go Modules 模式</li><li>Go v1.14 推荐在生产环境使用</li><li>Go v1.16 默认开启 Go Modules 模式。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/wVUVcppCZ89o7ViMNyTHfw">Go 语言各个版本支持 Go Modules 的演进史</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/13/Golang-Modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
