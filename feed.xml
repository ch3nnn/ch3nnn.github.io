<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ch3nnn个人博客</title>
    <link>https://ch3nnn.github.io/</link>
    
    <atom:link href="https://ch3nnn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>小站主要用来分享和记录学习经验,教程,记录个人生活的点滴以及一些随笔.</description>
    <pubDate>Mon, 09 Jan 2023 08:46:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Filebeat轻量型日志采集器及output插件开发</title>
      <link>https://ch3nnn.github.io/2023/01/09/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
      <guid>https://ch3nnn.github.io/2023/01/09/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
      <pubDate>Mon, 09 Jan 2023 08:36:01 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; cl</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Filebeat 是使用 Golang 实现的轻量型日志采集器。本质上是一个 agent ，可以安装在各个节点上，根据配置读取对应位置的日志，并上报到相应的地方去。</p><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Filebeat 并不依赖于 ElasticSearch，可以单独存在。我们可以单独使用Filebeat进行日志的上报和搜集。filebeat 内置了常用的 Output 组件, 例如 kafka、ElasticSearch、redis 等，出于调试考虑，也可以输出到 console 和 file 。我们可以利用现有的 Output 组件，将日志进行上报。</p><h3 id="整体工作原理"><a href="#整体工作原理" class="headerlink" title="整体工作原理"></a>整体工作原理</h3><p>Filebeat 由两个主要组件组成：harvester 和 prospector。</p><ul><li>harvester (采集器) 的主要职责是读取单个文件的内容。读取每个文件，并将内容发送到 the output。 每个文件启动一个 harvester，harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态。如果文件在读取时被删除或重命名，Filebeat 将继续读取文件。</li><li>prospector (查找器) 的主要职责是管理 harvester 并找到所有要读取的文件来源。如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个 harvester。每个 prospector 都在自己的 Go 协程中运行。<blockquote><p><em>注：Filebeat prospector只能读取本地文件， 没有功能可以连接到远程主机来读取存储的文件或日志。</em></p></blockquote></li></ul><p>由以上两个组件一起工作来读取文件（tail file）并将事件数据发送到指定的输出。<br>下图是 Filebeat 官方提供的架构图：<br><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs20230109163928.png"></p><h4 id="Filebeat背后的“老大”"><a href="#Filebeat背后的“老大”" class="headerlink" title="Filebeat背后的“老大”"></a>Filebeat背后的“老大”</h4><p>说到Filebeat，它其实只是<a href="https://links.jianshu.com/go?to=https://github.com/elastic/beats/tree/master/libbeat">beats家族</a>众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：</p><table><thead><tr><th>beat</th><th>功能</th></tr></thead><tbody><tr><td>Filebeat</td><td>收集日志文件</td></tr><tr><td>Metricbeat</td><td>收集各种指标数据</td></tr><tr><td>Packetbeat</td><td>收集网络数据包</td></tr><tr><td>Auditbeat</td><td>收集审计数据</td></tr><tr><td>Heartbeat</td><td>收集服务运行状态监测数据</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>如果你愿意的话，你也可以按照beat的规范来写自己的beat。<br>能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么</p><ul><li>libbeat提供了publisher组件，用于对接input；</li><li>收集到的数据在进入到libbeat后，首先会经过各种 processor的加工处理，比如过滤添加字段，多行合并等等；</li><li>input组件通过publisher组件将收集到的数据推送到publisher内部的队列；</li><li>libbeat本身实现了前面介绍过的多种output, 因此它负责将处理好的数据通过output组件发送出去；</li><li>libbeat本身封装了retry的逻辑；</li><li>libbeat负责将ACK反馈通过到input组件 ；</li></ul><p>由此可见，大部分活儿都是libbeat来作，当“老大”不容易啊～。<br>input仅需要作两件事：</p><ul><li>从不同的介质中收集数据后投递给libbeat;</li><li>接收libbeat反馈回来的ACK, 作相应的持久化;</li></ul><h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><p>Filebeat 基于 Go 语言开发无其他依赖，它最大的特点是性能稳定、配置简单、占用系统资源很少，安装使用也非常简单，可访问 Elastic-Beats 官网获取各版本 Filebeat。因为 Filebeat 各版本之间的差异较大，这里推荐7以上的新版，首先进行下载解压：<br>tar -zxvf filebeat-7.tar.gz mv filebeat-7 filebeat cd filebeat</p><h3 id="FileBeat启停指令："><a href="#FileBeat启停指令：" class="headerlink" title="FileBeat启停指令："></a>FileBeat启停指令：</h3><ul><li>调试模式下采用：终端启动（退出终端或 ctrl+c 会退出运行）</li></ul><p><code>./filebeat -e -c filebeat.yml</code></p><ul><li>线上环境配合 error 级别使用：以后台守护进程启动启动 filebeats</li></ul><p><code>nohup ./filebeat -e -c filebeat.yml &amp;</code></p><ul><li>零输出启动（不推荐）：将所有标准输出及标准错误输出到&#x2F;dev&#x2F;null空设备，即没有任何输出信息。</li></ul><p><code>nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><ul><li>停止运行 FileBeat 进程</li></ul><p><code>ps -ef | grep filebeat Kill -9 线程号</code></p><h3 id="FileBeat配置文件"><a href="#FileBeat配置文件" class="headerlink" title="FileBeat配置文件"></a>FileBeat配置文件</h3><p>FileBeat 的配置文件定义了在读取文件的位置，输出流的位置以及相应的性能参数，本实例是以 Kafka 消息中间件作为缓冲，所有的日志收集器都向 Kafka 输送日志流，相应的配置项如下，并附配置说明：</p><p>filebeat.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/wls/applogs/rtlog/app.log</span></span><br><span class="line">  <span class="attr">fields:</span> </span><br><span class="line">    <span class="attr">log_topic:</span> <span class="string">appName</span></span><br><span class="line">  <span class="attr">multiline:</span></span><br><span class="line">        <span class="comment"># pattern for error log, if start with space or cause by </span></span><br><span class="line">        <span class="attr">pattern:</span> <span class="string">&#x27;^[[:space:]]+(at|\.&#123;3&#125;)\b|^Caused by:&#x27;</span></span><br><span class="line">        <span class="attr">negate:</span>  <span class="literal">false</span></span><br><span class="line">        <span class="attr">match:</span>   <span class="string">after</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.kafka:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">hosts:</span> [<span class="string">&quot;kafka-1:9092&quot;</span>,<span class="string">&quot;kafka-2:9092&quot;</span>]</span><br><span class="line">   <span class="attr">topic:</span> <span class="string">applog</span></span><br><span class="line">   <span class="attr">version:</span> <span class="string">&quot;0.10.2.0&quot;</span></span><br><span class="line">   <span class="attr">compression:</span> <span class="string">gzip</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">drop_fields:</span> </span><br><span class="line">   <span class="attr">fields:</span> [<span class="string">&quot;beat&quot;</span>, <span class="string">&quot;input&quot;</span>, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;offset&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level:</span> <span class="string">error</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">app-server-ip</span></span><br></pre></td></tr></table></figure><ul><li><strong>paths</strong>:定义了日志文件路径，可以采用模糊匹配模式，如*.log</li><li><strong>fields</strong>：topic 对应的消息字段或自定义增加的字段。</li><li><strong>output.kafka</strong>：filebeat 支持多种输出，支持向 kafka，logstash，elasticsearch 输出数据，此处设置数据输出到 kafka。</li><li><strong>enabled</strong>：这个启动这个模块。</li><li><strong>topic</strong>：指定要发送数据给 kafka 集群的哪个 topic，若指定的 topic 不存在，则会自动创建此 topic。</li><li><strong>version</strong>：指定 kafka 的版本。</li><li><strong>drop_fields</strong>：舍弃字段，filebeat 会 json 日志信息，适当舍弃无用字段节省空间资源。</li><li><strong>name</strong>：收集日志中对应主机的名字，<strong>建议 name 这里设置为 IP</strong>，便于区分多台主机的日志信息。</li></ul><p>以上参数信息，需要用户个性化修改的主要是：paths，hosts，topic，version 和 name。</p><h3 id="Filebeat-input-配置热加载"><a href="#Filebeat-input-配置热加载" class="headerlink" title="Filebeat input 配置热加载"></a>Filebeat input 配置热加载</h3><p>filebeat.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.config.inputs:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">../configs/input*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">reload.period:</span> <span class="string">5s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.syslog:</span></span><br><span class="line">  <span class="attr">network:</span> <span class="string">tcp</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:5140</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">tag</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fields:</span></span><br><span class="line">  <span class="attr">prober_id:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>input.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/Users/chentong/project/log-prober-go/prober-filebeat/cmd/filebeat/example.log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Filebeat-写入-kafka-示例"><a href="#Filebeat-写入-kafka-示例" class="headerlink" title="Filebeat 写入 kafka 示例"></a>Filebeat 写入 kafka 示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">    - type: log</span><br><span class="line">      paths:</span><br><span class="line">        - /var/log/*.log</span><br><span class="line">        - /Users/chentong/project/log-prober-go/logs/app.log</span><br><span class="line">output.kafka:</span><br><span class="line">    hosts:</span><br><span class="line">        - 127.0.0.1:9092</span><br><span class="line">    topic: test_filebeat</span><br><span class="line">    keep_alive: 10s</span><br><span class="line">fields:</span><br><span class="line">    prober_id: 999</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Filebeat-output-syslog插件开发"><a href="#Filebeat-output-syslog插件开发" class="headerlink" title="Filebeat output syslog插件开发"></a>Filebeat output syslog插件开发</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>filebeat 自带只支持 es、logstash、kafka、redis、file、console 数据输出. 需要自定义输出 syslog </p></blockquote><h3 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h3><h4 id="引入对beat的依赖"><a href="#引入对beat的依赖" class="headerlink" title="引入对beat的依赖"></a>引入对<code>beat</code>的依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/elastic/beats/v7</span><br></pre></td></tr></table></figure><p>定义在filebeat中的配置文件<br><code>filebeat</code>通常以配置文件的方式加载插件。让我们定义一下必须的配置，就像<code>elasticsearch</code>中的连接地址等等一样。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output.syslog:</span></span><br><span class="line">  <span class="comment"># 接收方式</span></span><br><span class="line">  <span class="attr">network:</span> <span class="string">tcp</span>   </span><br><span class="line">  <span class="comment"># syslog 地址</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:5140</span></span><br><span class="line">  <span class="comment"># 自定义消息tag</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">tag</span></span><br></pre></td></tr></table></figure><h4 id="go文件中的配置"><a href="#go文件中的配置" class="headerlink" title="go文件中的配置"></a>go文件中的配置</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> syslogConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Network <span class="type">string</span> <span class="string">`config:&quot;network&quot;`</span></span><br><span class="line">Addr    <span class="type">string</span> <span class="string">`config:&quot;addr&quot;`</span></span><br><span class="line">Tag     <span class="type">string</span> <span class="string">`config:&quot;tag&quot;`</span></span><br><span class="line"><span class="comment">// 发布日志事件的 worker goroutines 数量</span></span><br><span class="line">Workers <span class="type">int</span> <span class="string">`config:&quot;workers&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line"><span class="comment">// Max number of events in a batch to send to a single client</span></span><br><span class="line">BatchSize <span class="type">int</span> <span class="string">`config:&quot;batch_size&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line"><span class="comment">// Max number of retries for single batch of events</span></span><br><span class="line">RetryLimit <span class="type">int</span> <span class="string">`config:&quot;retry_limit&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="初始化加载插件"><a href="#初始化加载插件" class="headerlink" title="初始化加载插件"></a>初始化加载插件</h4><h4 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h4><p>在某个init函数中注册插件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">outputs.RegisterType(<span class="string">&quot;syslog&quot;</span>, newSyslogOutPut)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>newSyslogOutPut</code>中卸载配置，并提供配置给<code>Syslog</code>客户端</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSyslogOutPut</span><span class="params">(_ outputs.IndexManager, _ beat.Info, stats outputs.Observer, cfg *common.Config)</span></span> (outputs.Group, <span class="type">error</span>) &#123;</span><br><span class="line">config := syslogConfig&#123;Workers: <span class="number">1</span>, BatchSize: <span class="number">1</span>, RetryLimit: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span> err := cfg.Unpack(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> outputs.Fail(err)</span><br><span class="line">&#125;</span><br><span class="line">clients := <span class="built_in">make</span>([]outputs.NetworkClient, config.Workers)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; config.Workers; i++ &#123;</span><br><span class="line">clients[i] = &amp;SyslogClient&#123;</span><br><span class="line">network: config.Network,</span><br><span class="line">addr:    config.Addr,</span><br><span class="line">tag:     config.Tag,</span><br><span class="line">stats:   stats,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> outputs.SuccessNet(<span class="literal">true</span>, config.BatchSize, config.RetryLimit, clients)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="初始化syslog客户端"><a href="#初始化syslog客户端" class="headerlink" title="初始化syslog客户端"></a>初始化<code>syslog</code>客户端</h4><p><code>syslog</code>客户端不仅仅是一个<code>syslog</code>客户端，而且还需要实现<code>filebeat</code>中的<code>NetworkClient</code>接口，接下来，让我们来关注接口中的每一个方法的作用及实现</p><h3 id="String-接口"><a href="#String-接口" class="headerlink" title="String()接口"></a>String()接口</h3><p><code>String</code>作为客户端的名字，用来标识日志以及指标。是最简单的一个接口</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Connect-接口"><a href="#Connect-接口" class="headerlink" title="Connect()接口"></a>Connect()接口</h3><p><code>Connect</code>用来初始化客户端</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> Connect() <span class="type">error</span> &#123;</span><br><span class="line">dial, err := gsyslog.DialLogger(c.network, c.addr, gsyslog.LOG_NOTICE, <span class="string">&quot;LOCAL0&quot;</span>, c.tag)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">c.client = dial</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里初始化失败，需要<code>Sleep</code>一段时间，否则，filebeat会一直重试。这绝非是你想要的。或许对于场景来说，退避重试可能会更好</p><h3 id="Close-接口"><a href="#Close-接口" class="headerlink" title="Close()接口"></a>Close()接口</h3><p>关闭客户端，也是很简单的接口</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.client.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Publish-接口"><a href="#Publish-接口" class="headerlink" title="Publish()接口"></a>Publish()接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> Publish(_ context.Context, batch publisher.Batch) <span class="type">error</span> &#123;</span><br><span class="line">events := batch.Events()</span><br><span class="line"><span class="comment">// 记录这批日志</span></span><br><span class="line">c.stats.NewBatch(<span class="built_in">len</span>(events))</span><br><span class="line">retryEvents, err := c.PublishEvents(events)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 发送失败，则重试 受RetryLimit的限制</span></span><br><span class="line">batch.RetryEvents(retryEvents)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.stats.Acked(<span class="built_in">len</span>(events))</span><br><span class="line">batch.ACK()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布 syslog 数据</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> PublishEvents(events []publisher.Event) ([]publisher.Event, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i, event := <span class="keyword">range</span> events &#123;</span><br><span class="line">message, err := event.Content.Fields.GetValue(<span class="string">&quot;message&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> events[i:], err</span><br><span class="line">&#125;</span><br><span class="line">m, ok := message.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> events[i:], errors.New(<span class="string">&quot;cast log to str failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// syslog 发送数据</span></span><br><span class="line">_, err = c.client.Write([]<span class="type">byte</span>(m))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> events[i:], err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后是SyslogClient"><a href="#最后是SyslogClient" class="headerlink" title="最后是SyslogClient"></a>最后是<code>SyslogClient</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyslogClient <span class="keyword">struct</span> &#123;</span><br><span class="line">network <span class="type">string</span></span><br><span class="line">addr    <span class="type">string</span></span><br><span class="line">tag     <span class="type">string</span></span><br><span class="line"></span><br><span class="line">stats  outputs.Observer</span><br><span class="line">client gsyslog.Syslogger</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/09/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>这些最常用的 Go CLI 命令，新手 Gopher 应该掌握</title>
      <link>https://ch3nnn.github.io/2023/01/02/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84GoCLI%E5%91%BD%E4%BB%A4/</link>
      <guid>https://ch3nnn.github.io/2023/01/02/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84GoCLI%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Mon, 02 Jan 2023 02:28:19 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;本文将介绍一些最基本的 Go 命令行命令。如果你刚接触 Go 语言，那你有必要记住它们，因为这些命令是 Go 开发者日常工作中所必备的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go version&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始 Go 项目前，我们应该确保开发机上已经安装好了</description>
        
      
      
      
      <content:encoded><![CDATA[<p>本文将介绍一些最基本的 Go 命令行命令。如果你刚接触 Go 语言，那你有必要记住它们，因为这些命令是 Go 开发者日常工作中所必备的。</p><p><strong>Go version</strong></p><p>开始 Go 项目前，我们应该确保开发机上已经安装好了 Go 编译器。这可以通过 <a href="https://go.dev/doc/install">https://go.dev/doc/install</a> 进行下载安装。</p><p>通过执行以下命令可以查看安装的 Go 版本信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.18</span> darwin/amd64</span><br></pre></td></tr></table></figure><p><strong>Go env</strong></p><p>如果我们可能想查看一些 Go 相关的环境变量，例如 GOROOT 或者 GOPATH。你可以执行这个命令。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env</span><br></pre></td></tr></table></figure><p>当你想对某个环境变量进行更改，例如修改 Go 代理，你可以这样做。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.io,direct</span></span><br></pre></td></tr></table></figure><p><strong>go mod</strong></p><p>在你开始建立第一个 Go 程序时，在项目根目录下，你应该运行这样的命令。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init &lt;your project name&gt;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod init demo/firstProject</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，项目根目录将增加 go.mod 文件，它的内容如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ cat <span class="keyword">go</span>.mod </span><br><span class="line">module demo/firstProject</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br></pre></td></tr></table></figure><p>如果你有其他语言的经验，那么 go.mod 类似于 Python 中的 requirements.txt，Java 中的 pom.xml，它用于管理项目的依赖包。</p><p><strong>go get</strong></p><p>当项目中有引入外部库，应该执行 go get 命令。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get &lt;<span class="keyword">package</span> name&gt;</span><br></pre></td></tr></table></figure><p>例如我们需要使用日志库 logrus，执行以下命令会将该库源代码下载至 mod cache 中，并将在 go.mod  文件中记录该库的依赖情况。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/sirupsen/logrus</span><br><span class="line">$ cat <span class="keyword">go</span>.mod </span><br><span class="line">module demo/firstProject</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/sirupsen/logrus v1<span class="number">.9</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">        golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20220715151400</span>-c0bba94af5f8 <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>go run&#x2F;build</strong></p><p>当我们已经编写了一些 Go 代码，并希望在本地运行它以查看程序表现是否符合预期。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run .</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用 go build 命令。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build -o &lt;name of binary&gt; &lt;packages&gt;</span><br><span class="line">$ ./&lt;name of binary&gt;</span><br></pre></td></tr></table></figure><p>两种命令方式都需要编译的过程，实质并无什么区别。go run只是将编译得到的可执行文件执行后销毁，而 go build 是将可执行文件保留下来，并不直接执行。</p><p><strong>go test</strong></p><p>如果你编写了一堆单元测试代码（在以_test.go 结尾的文件中），你想运行它们，只需要执行以下语句。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test</span><br></pre></td></tr></table></figure><p><strong>go mod tidy</strong></p><p>当项目中尝试引入过多个三方包，而其中部分包我们并不需要了，那就应该从代码依赖中删除。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure><p><strong>go vet</strong></p><p>当完成了功能开发后，应该使用以下命令来帮助我们检测程序中可能存在问题的代码。更多 vet 知识可以查看文章Go工具之vet——静态诊断器。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> vet</span><br></pre></td></tr></table></figure><p><strong>go fmt</strong></p><p>当完成了功能开发，准备提交代码到公共仓库。我们应该确保项目代码遵循统一的官方代码风格。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">fmt</span></span></span><br></pre></td></tr></table></figure><p>当然更好的方式其实是使用检查套件，具体可以参见文章Gopher一定要会的代码自动化检查。</p><p><strong>总结</strong></p><p>Go 提供了非常多简单又实用的命令行工具，本文仅介绍了一些在项目开发中最可能被用到的命令。</p><p>想获取更多 Go 命令？可以执行 $ go 或者 $ go tool 获取命令列表，执行 go help <command>可了解特定命令的更多信息。</p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/02/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84GoCLI%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>「回顾2022，展望2023」 —— 年终总结</title>
      <link>https://ch3nnn.github.io/2023/01/01/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <guid>https://ch3nnn.github.io/2023/01/01/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sun, 01 Jan 2023 15:41:48 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;致自己：折腾不息 · 乐此不疲!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;22-年收获&quot;&gt;&lt;a href=&quot;#22-年收获&quot; class=&quot;headerlink&quot; title=&quot;22 年收获&quot;&gt;&lt;/a&gt;22 年收获&lt;/h2&gt;&lt;p&gt;&lt;st</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>致自己：折腾不息 · 乐此不疲!</p></blockquote><h2 id="22-年收获"><a href="#22-年收获" class="headerlink" title="22 年收获"></a>22 年收获</h2><p><strong>技术上</strong></p><ul><li>编程语言方面<ul><li>Golang: 从开始学习到现在的一年时间里, 前前后后也写了些代码, 其中包括业余时间的, 也有产品项目中的. 在摸滚打爬中对于Golang的使用算是勉强达到了较为熟练的状态.</li></ul></li><li>开源贡献方向<ul><li>jaywcjlove&#x2F;reference <a href="https://github.com/jaywcjlove/reference">为开发人员分享快速参考备忘清单(速查表)</a></li><li>liangliangyy&#x2F;DjangoBlog <a href="https://github.com/liangliangyy/DjangoBlog">基于Django的博客系统</a></li><li>Lcry&#x2F;a-sheep-assistant <a href="https://github.com/Lcry/a-sheep-assistant">羊了个羊助手，羊了个羊一键闯关</a></li></ul></li></ul><p><strong>生活上</strong></p><ul><li>疫情防控<br>保持绿码, 小🐑人中… 还以为自己就是那位”天选之子”(又开始吹牛皮).</li><li>生活情感<br>端午节前带女朋友回家, 父母都感觉很满意, 生活很幸福, 偶尔会吵吵嘴毕竟生活需要增加些乐趣嘛(哈哈哈).</li></ul><p><strong>工作上</strong></p><ul><li>从互联网医疗到工控安全行业, 工作内容没有任何变化(就是撸码搬砖🧱)</li></ul><h2 id="23年展望"><a href="#23年展望" class="headerlink" title="23年展望"></a>23年展望</h2><p>2023年是新的一年，新的一年就会有新的flag。新的一年我要以下几件事:</p><ul><li>保持持续学习的激情、态度</li><li>持续开源贡献</li><li>真的需要运动(感觉自己要废了)</li><li>感情上还是需要更加谦让</li><li>…</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul><li>最后, 最后, Happy New Year … 或者至少, 平平安安度过新的一年</li><li>各位, 继续加油吧! 冲冲冲!</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/01/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
