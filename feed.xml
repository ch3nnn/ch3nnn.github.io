<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ch3nnn个人博客</title>
    <link>https://ch3nnn.github.io/</link>
    
    <atom:link href="https://ch3nnn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>小站主要用来分享和记录学习经验,教程,记录个人生活的点滴以及一些随笔.</description>
    <pubDate>Sat, 18 Mar 2023 16:43:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang-垃圾回收</title>
      <link>https://ch3nnn.github.io/2023/03/18/Golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <guid>https://ch3nnn.github.io/2023/03/18/Golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <pubDate>Sat, 18 Mar 2023 15:21:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。&lt;/p&gt;
&lt;h3 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>目前比较常见的垃圾回收算法有三种：<br><strong>引用计数</strong>：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。</p><ul><li>代表语言：Python、PHP、Swift </li><li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。 </li><li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li></ul><p><strong>标记-清除</strong>：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。</p><ul><li>代表语言：Golang（三色标记法） </li><li>优点：解决了引用计数的缺点。 </li><li>缺点：需要 STW，暂时停掉程序运行。</li></ul><p><strong>分代收集</strong>：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。</p><ul><li>代表语言：Java</li><li>优点：回收性能好</li><li>缺点：算法复杂</li></ul><h3 id="Golang-垃圾回收"><a href="#Golang-垃圾回收" class="headerlink" title="Golang 垃圾回收"></a>Golang 垃圾回收</h3><h4 id="Go1-3之前-标记清除法"><a href="#Go1-3之前-标记清除法" class="headerlink" title="Go1.3之前 标记清除法"></a>Go1.3之前 标记清除法</h4><ol><li>进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的内存占用和可达的内存占用</li><li>开始标记，程序找出可达内存占用并做标记</li><li>标记结束清除未标记的内存占用</li><li>结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束</li></ol><p><img src="https://s2.loli.net/2023/03/18/eaq4SfrMFOHYxVI.png"></p><p>一开始的做法是将垃圾清理结束时才停止 STW，后来优化了方案将清理垃圾放到了 STW 之后，与程序运行同时进行，这样做减小了 STW 的时长。<br>但是 STW 会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的 STW 对于性能较高的程序还是无法接受，但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。<br>因此 Go1.5 采用了三色标记法优化了 STW。</p><h4 id="Go1-5之后-三色并发标记法"><a href="#Go1-5之后-三色并发标记法" class="headerlink" title="Go1.5之后 三色并发标记法"></a>Go1.5之后 三色并发标记法</h4><p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：</p><p>灰色：对象还在标记队列中等待<br>黑色：对象已被标记，gcmarkBits对应位为 1 – 该对象不会在本次 GC 中被回收<br>白色：对象未被标记，gcmarkBits对应位为 0 – 该对象将会在本次 GC 中被清理</p><p>三色标记法分五步进行:</p><ol><li>将所有对象标记为白色</li><li>从根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中</li><li>遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色</li><li>循环这个过程</li><li>直到灰色节点集合为空，回收所有的白色节点</li></ol><p>具体流程如下图:<br><img src="https://s2.loli.net/2023/03/19/Ob69hxsuAJZYmGE.png"></p><p>回收原理:<br>通过上图，应该对三色标记法有了一个比较直观的了解，那么我们现在来讲讲原理。简单的讲，就是标记内存中那些还在使用中（即被引用了）的部分，而内存中不再使用（即未被引用）的部分，就是要回收的垃圾，需要将其回收，以供后续内存分配使用。上图中的 A、B、D 就是被引用正在使用的内存，而C、F、E 曾经被使用过，但现在没有任何对象引用，就需要被回收掉。</p><p><strong>三色标记法缺点</strong><br>将 GC 和程序会放一起执行，会因为 cpu 的调度出现下面这种情况，导致被引用的对象 3 却被GC给“误杀”回收掉了，从而出现错误。<br><img src="https://s2.loli.net/2023/03/19/p1ANEKigV8PbHWS.png"></p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><ul><li>条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)</li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</li></ul><p>如果当以上两个条件同时满足时，就会出现对象丢失现象!</p><p><strong>屏障机制</strong><br>强三色不变式和弱三色不变式</p><ul><li>强三色不变式</li></ul><p><img src="https://s2.loli.net/2023/03/19/nBHRLtXmIQebVgK.png"><br>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><ul><li>弱三色不变式</li></ul><p><img src="https://s2.loli.net/2023/03/19/9QA7HSeZYVUtbIj.png"><br>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p><strong>插入屏障和删除屏障</strong></p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p><ul><li>插入屏障<br>对象被引用时触发的机制，当白色对象被黑色对象引用时，白色对象被标记为灰色（栈上对象无插入屏障）<br><img src="https://s2.loli.net/2023/03/19/zobvNwRKp8nyZj3.png"></li></ul><p>缺点在于：如果对象 1 在栈上新创建了一个对象 6，<strong>由于栈没有屏障机制，所以对象 6 仍为白色节点会被回收</strong><br>栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以<strong>“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中</strong>.</p><p><img src="https://s2.loli.net/2023/03/19/R143m69xfcUSeBI.png"><br>所以栈在 GC 迭代结束时（没有灰色节点），会对栈执行 STW，重新进行扫描清除白色节点。（STW 时间为 10-100ms）</p><ul><li>删除屏障<br>对象被删除时触发的机制。如果灰色对象引用的白色对象被删除时，那么白色对象会被标记为灰色。<br><img src="https://s2.loli.net/2023/03/19/WUq9Yv2MjfoCKeP.png"></li></ul><p>缺点在于：这种做法回收精度较低，一个对象即使被删除仍可以活过这一轮再下一轮被回收。（如果对象 4 没有引用对象 3，此时对象 3 应该作为垃圾被回收，但是对象 3 却要等到下一轮 GC 才会被回收）<br><img src="https://s2.loli.net/2023/03/19/jxFnmhskMlfNqCX.png"><br>同样也存在对栈的二次扫描影响程序的效率。</p><h3 id="Go1-8-三色标记-混合写屏障-hybrid-write-barrier-机制"><a href="#Go1-8-三色标记-混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="Go1.8 三色标记 + 混合写屏障(hybrid write barrier)机制"></a>Go1.8 三色标记 + 混合写屏障(hybrid write barrier)机制</h3><p><strong>插入写屏障和删除写屏障的短板：</strong></p><ul><li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； </li><li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</li></ul><p><strong>混合写屏障规则</strong></p><ol><li>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</li><li>GC期间，任何在栈上创建的新对象，均为黑色。</li><li>被删除的对象标记为灰色。</li><li>被添加的对象标记为灰色。</li></ol><p><img src="https://s2.loli.net/2023/03/19/kIz3o62gVsfSO4r.png"></p><h2 id="触发垃圾回收的时机"><a href="#触发垃圾回收的时机" class="headerlink" title="触发垃圾回收的时机"></a>触发垃圾回收的时机</h2><p>主动触发: </p><ul><li>通过调用 <code>runtime.GC</code> 来触发 GC, 此调用阻塞式等待当前 GC 运行完毕</li></ul><p>被动触发:</p><ul><li>定期触发GC (使用系统监控, 当超过 2 分钟没有产生任何 GC 时, 强制触发 GC)</li><li>内存分配量达到阀值触发GC (堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量 GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发 GC)</li></ul><h2 id="GO-GC-调优"><a href="#GO-GC-调优" class="headerlink" title="GO GC 调优"></a>GO GC 调优</h2><ol><li>控制内存分配的速度, 限制 <code>goroutine</code> 的数量, 从而提高对 CPU 的利用率</li><li>减少并复用内存, 例如使用<code>sysnc.Poll</code> 来复用需要频繁创建的临时对象, 例如提前分配足够的内存来降低多余的复制</li><li>增大 <code>GOGC</code> 的值, 降低 GC 的运行频率</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.yuque.com/aceld/golang/zhzanb#d067ac74">Golang三色标记混合写屏障GC模式全分析</a><br><a href="https://learnku.com/articles/59021#:~:text=%E5%9C%A8Go%20%E4%B8%AD%E6%A0%88%E4%B8%8A,%E5%9E%83%E5%9C%BE%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%82">图解Golang垃圾回收机制！</a><br><a href="https://blog.csdn.net/qq_35246620/article/details/53790350">浅析 Golang 垃圾回收机制</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/18/Golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-Modules的演进史</title>
      <link>https://ch3nnn.github.io/2023/03/13/Golang-Modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</link>
      <guid>https://ch3nnn.github.io/2023/03/13/Golang-Modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid>
      <pubDate>Mon, 13 Mar 2023 03:53:48 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。&lt;/p&gt;
&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。</p><p>使用<code> Go Modules</code> 模式，一般分为以下几个流程：</p><ul><li><code>go mod init</code> 创建一个新模块，初始化 <code>go.mod</code> 文件。</li><li><code>go build</code>、<code>go test</code>、<code>go run</code>、<code>go install</code> 等构建命令，向 <code>go.mod</code>文件中添加模块所需的依赖项。</li><li><code>go list -m -json all</code> 打印当前模块的依赖项。</li><li><code>go get</code> 添加依赖项，或修改依赖项版本。</li><li><code>go mod tidy</code> 删除未使用的依赖项。</li></ul><h2 id="Go-Modules-演进史"><a href="#Go-Modules-演进史" class="headerlink" title="Go Modules 演进史"></a>Go Modules 演进史</h2><p><strong>Go v1.11</strong><br>从 Go v1.11 开始支持 Go Moduls。<br>为了兼容使用 Go v1.11 之前的任意版本的项目，当设置 <code>GO111MODULE=auto</code> 或 <code>GO111MODULE=off</code> 时，Go v1.11 在 <code>$GOPATH/src</code> 中，继续使用 <code>GOPATH</code> 模式。<br>当设置 <code>GO111MODULE=auto</code> 时，其它任意位置，如果当前目录或父目录包含 go.mod 文件，则使用 Modules 模式。</p><blockquote><p>注意：GO111MODULE 包含三个模式，分别是 auto、on 和 off，其中默认值是 auto，即不显式设置 GO111MODULE 的值，默认是 auto 模式。</p></blockquote><p><strong>Go v1.13</strong><br>在 Go v1.13 中，Go Modules 发生一些变化：</p><p>当设置 <code>GO111MODULE=auto</code> 时，如果在任意位置找到 go.mod 文件，则使用 Go Modules 模式，即使在 <code>$GOPATH/src</code> 中。</p><blockquote><p>注意：在 Go v1.13 之前，即使 GO111MODULE&#x3D;auto，在 $GOPATH&#x2F;src 目录中也不会启动 Go Modules 模式。</p></blockquote><p>go get 的变化：</p><ul><li><code>go get -u （不包含任何参数）</code>，现在只升级当前包的直接和间接依赖，并且不再检查整个模块。</li><li><code>go get -u ./...</code> 从模块根升级模块的所有直接和间接依赖项，现在排除测试依赖项。</li><li><code>go get -u -t ./... </code>从模块根升级模块的所有直接和间接依赖项，而且还会升级测试依赖项。</li></ul><p><strong>Go v1.14</strong><br>从 Go v1.14 开始，模块被认为可以用于生产环境，并且鼓励所有用户从其他依赖管理系统迁移到模块。<br>当主模块包含一个顶级 vendor 目录，并且它的 go.mod 文件指定 go 1.14 或更高版本时，对于支持 <code>-mod=vendor</code> 的 go 命令，将默认添加 <code>-mod=vendor</code>。</p><p><strong>Go v1.15</strong><br>模块缓存的位置现在可以使用 <code>GOMODCACHE</code> 环境变量进行设置。<code>GOMODCACHE</code> 的默认值是 <code>GOPATH[0]/pkg/mod</code>，这也是不支持使用 <code>GOMODCACHE</code> 环境变量进行设置之前的模块缓存的位置。</p><blockquote><p>注意：可以使用 GOPATH 环境变量设置多个目录。</p></blockquote><p><strong>Go v1.16</strong><br>模块模式（<code>GO111MODULE=on</code>）默认开启，也就是说默认启用 Go Modules 模式，如果用户想要使用 GOPATH 模式，需要显式设置 <code>GO111MODULE=off</code> 或 <code>GO111MODULE=auto</code>（并且需要在 <code>$GOPATH/src</code> 目录）。<br>使用 <code>go install pkg@version</code> 替换 <code>go get pkg@version</code> 全局安装包和可执行文件。</p><blockquote><p>注意：在 Modules 模式 go get 不再用于构建或安装包，而是专门用于调整 go.mod 中的依赖项，如果在模块外执行 go get 将会报错，因为没有可更新的 go.mod 文件；在 GOPATH 模式（GO111MODULE&#x3D;off） go get 仍然构建和安装包。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍 Go Modules 模式在 Go 语言各个版本中的演进史，限于篇幅，仅介绍的在使用时常用操作的变化，我们最后做一下总结：</p><ol><li>Go v1.11  开始支持 Go Modules 模式</li><li>Go v1.13 在（包含 $GOPATH&#x2F;src ）任意目录找到 go.mod 文件，都开启 Go Modules 模式</li><li>Go v1.14 推荐在生产环境使用</li><li>Go v1.16 默认开启 Go Modules 模式。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/wVUVcppCZ89o7ViMNyTHfw">Go 语言各个版本支持 Go Modules 的演进史</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/13/Golang-Modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-逃逸分析</title>
      <link>https://ch3nnn.github.io/2023/03/07/Golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <guid>https://ch3nnn.github.io/2023/03/07/Golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <pubDate>Tue, 07 Mar 2023 05:38:48 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;什么是堆-x2F-栈&quot;&gt;&lt;a href=&quot;#什么是堆-x2F-栈&quot; class=&quot;headerlink&quot; title=&quot;什么是堆&amp;#x2F;栈&quot;&gt;&lt;/a&gt;什么是堆&amp;#x2F;栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="什么是堆-x2F-栈"><a href="#什么是堆-x2F-栈" class="headerlink" title="什么是堆&#x2F;栈"></a>什么是堆&#x2F;栈</h3><ul><li>堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多</li><li>栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上</li></ul><h3 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h3><p>我们如何知道一个对象是应该放在堆内存，还是栈内存之上呢？可以官网的FAQ（地址：<a href="https://go.dev/doc/faq#stack_or_heap">https://go.dev/doc/faq#stack_or_heap</a>）中找到答案.<br><img src="https://s2.loli.net/2023/03/07/5xzbUkInvQrVpDu.png"></p><p>大致意思是:</p><blockquote><p>从正确性的角度来看，你不需要知道。Go中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。<br>存储位置确实对编写高效的程序有影响。如果可能的话，Go编译器将为该函数的堆栈帧中的函数分配局部变量。但是，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在有垃圾回收的堆上分配该变量，以避免悬空指针错误。此外，如果局部变量非常大，那么将其存储在堆中可能比存储在栈中更有意义。<br>在当前编译器中，如果变量的地址被占用，那么该变量就是堆上分配内存的候选变量。然而，基本的逃逸分析可以识别出某些情况下，这些变量将不会存在于函数返回之后，而可以驻留在栈中。</p></blockquote><h3 id="在什么阶段确立逃逸"><a href="#在什么阶段确立逃逸" class="headerlink" title="在什么阶段确立逃逸"></a>在什么阶段确立逃逸</h3><p>Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的。</p><ul><li>逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析</li><li>如果变量在函数外部没有引用，则优先放到栈中</li><li>如果变量在函数外部存在引用，则必定放在堆中</li></ul><h3 id="逃逸规则"><a href="#逃逸规则" class="headerlink" title="逃逸规则"></a>逃逸规则</h3><p>我们其实都知道一个普遍的规则，就是如果变量需要使用堆空间，那么他就应该进行逃逸。但是实际上Golang并不仅仅把逃逸的规则如此泛泛。Golang会有很多场景具备出现逃逸的现象。</p><p>一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。</p><p>Go语言中的引用类型有<code>func</code>（函数类型），<code>interface</code>（接口类型），<code>slice</code>（切片类型），<code>map</code>（字典类型），<code>channel</code>（管道类型），<code>*</code>（指针类型）等。</p><h3 id="怎么确定是否逃逸"><a href="#怎么确定是否逃逸" class="headerlink" title="怎么确定是否逃逸"></a>怎么确定是否逃逸</h3><p>可以使用编译器提供的指令<code>-gcflags</code> 就可以看到详细的逃逸分析过程，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go build -gcflags &#x27;-m -l&#x27; main.go</span><br></pre></td></tr></table></figure><p>其指令涉及的参数如下：</p><ul><li>-m：打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是这样子调试的信息量较大，一般用一个就足够了。</li><li>-l ：禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。</li></ul><h3 id="常见逃逸案例分析"><a href="#常见逃逸案例分析" class="headerlink" title="常见逃逸案例分析"></a>常见逃逸案例分析</h3><p><strong>new的变量在栈还是堆</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(argVal <span class="type">int</span>)</span></span> (*<span class="type">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fooVal1 = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> fooVal2 = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> fooVal3 = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> fooVal4 = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">var</span> fooVal5 = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处循环是防止go编译器将foo优化成inline(内联函数)</span></span><br><span class="line">    <span class="comment">//如果是内联函数，main调用foo将是原地展开，所以fooVal 1-5 相当于main作用域的变量</span></span><br><span class="line">    <span class="comment">//即使fooVal3发生逃逸，地址与其他也是连续的</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">println</span>(argVal, fooVal1, fooVal2, fooVal3, fooVal4, fooVal5)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fooVal3</span></span><br><span class="line">    <span class="keyword">return</span> fooVal3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainVal := foo(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(*mainVal, mainVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将fooVal 1-5 全部用<code>new</code>的方式来开辟, 编译运行看结果, 显然<code>fooVal3</code>发生了逃逸</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -gcflags <span class="string">&#x27;-m -l&#x27;</span> main.go</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">./main.go:5:29: new(int) does not escape</span><br><span class="line">./main.go:6:29: new(int) does not escape</span><br><span class="line">./main.go:7:29: new(int) escapes to heap</span><br><span class="line">./main.go:8:29: new(int) does not escape</span><br><span class="line">./main.go:9:29: new(int) does not escape</span><br></pre></td></tr></table></figure><p><strong>暴露外部指针</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">a := <span class="number">666</span></span><br><span class="line"><span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_ = foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析如下，变量<code>a</code>发生了逃逸</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -gcflags <span class="string">&#x27;-m -l&#x27;</span> main.go</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">./main.go:4:2: moved to heap: a</span><br></pre></td></tr></table></figure><p>这种情况直接满足我们上述中的原则：变量在函数外部存在引用。这个很好理解，因为当函数执行完毕，对应的栈帧就被销毁，但是引用已经被返回到函数之外。<br>如果这时外部从引用地址取值，虽然地址还在，但是这块内存已经被释放回收了，这就是非法内存，问题可就大了。所以，很明显，这种情况必须分配到堆上。</p><p><strong>变量所占内存过大</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">s[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析如下，变量<code>make([]int, 10000, 10000)</code>发生了逃逸</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build -gcflags <span class="string">&#x27;-m -l&#x27;</span> main.go</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">./main.go:4:11: make([]int, 10000, 10000) escapes to heap</span><br></pre></td></tr></table></figure><p>当我们创建了一个容量为10000的int类型的底层数组对象时，由于对象过大，它也会被分配到堆上。这里我们不禁要想一个问题，为啥大对象需要分配到堆上。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>逃逸分析是在编译器完成的，不是在运行时分析。</li><li>静态分配到栈上，性能一般会比动态分配到堆上好。</li><li>底层分配到堆，还是栈，实际上对你来说是透明的，不需要过度关心、纠结。</li><li>每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）。</li><li>到处都用指针传递并不一定是最好的，要合理的用对。</li><li>遇到怀疑，直接通过 <code>go build -gcflags &#39;-m -l&#39;</code> 可以看到逃逸分析的过程和结果，胜过道听途说。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://golang2.eddycjy.com/posts/ch6/08-stack-heap/">逃逸分析：变量在哪儿</a></li><li><a href="https://mp.weixin.qq.com/s/xUt3E3yxJIwvCJWuHRxOVw">不喜欢水文？详解 Go 逃逸分析卷给你看</a></li><li><a href="https://www.yuque.com/aceld/golang/yyrlis">Golang中逃逸现象, 变量“何时栈?何时堆?”</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/07/Golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-GMP模型</title>
      <link>https://ch3nnn.github.io/2023/03/02/Golang-GMP%E6%A8%A1%E5%9E%8B/</link>
      <guid>https://ch3nnn.github.io/2023/03/02/Golang-GMP%E6%A8%A1%E5%9E%8B/</guid>
      <pubDate>Thu, 02 Mar 2023 08:45:39 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下面通过一段简单的代码展示一下 Go 应用程序在运行时的 goroutine，方便大家更好的理解。</p><blockquote><p>The Go scheduler is part of the Go runtime, and the Go runtime is built into your application</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br></pre></td></tr></table></figure><p>上面这段代码的输出为：<code>5</code> 说明当前这个应用程序中存在 <code>goroutine</code> 的数量是 <code>5</code>，事实上也符合我们的预期。那么问题来了，这 5 个 goroutine 作为操作系统用户态的基本调度单元是无法直接占用操作系统的资源来执行的，必须经过内核级线程的分发，这是操作系统内部线程调度的基本模型，根据用户级线程和内核级线程的对应关系可以分为 1 对 1，N 对 1 以及 M 对 N 这三种模型，那么上述的 5 个 goroutine 在内核级线程上是怎么被分发的，这就是 Go语言的 goroutine 调度器决定的。</p><p><img src="https://s2.loli.net/2023/03/02/xfMIESaWZh3t2Fj.png"></p><h3 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h3><p>整个 <code>goroutine</code> 调度器的实现基于 GMP 的三级模型来实现。</p><ul><li>G：goroutine (go 代码)</li><li>M：内核级线程，运行在操作系统的核心态。(在 Go 中支持最大的 M 的数量是 10000，但是操作系统中通常情况是不可以创建这么多的线程。) </li><li>P：processor，可以理解成一个等待分发给 M 调度执行的 goroutine 队列。(P的个数是由 runtime 的 GOMAXPROCS 来决定的。)</li></ul><p>M 和 P 存在一一对应的绑定关系。大致的结构图如下所示：</p><p><img src="https://s2.loli.net/2023/03/02/A1lVJpuRBYIT3HL.png"></p><p>GMP 模型图如下:<br><img src="https://s2.loli.net/2023/03/02/GwURAv8zVTyZhpJ.png"></p><ol><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li><li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li></ol><p><strong>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。</strong></p><h3 id="goroutine-之旅"><a href="#goroutine-之旅" class="headerlink" title="goroutine 之旅"></a>goroutine 之旅</h3><p>通常情况下，我们在代码中执行 <code>go func()&#123;&#125;</code>后，GMP 模型是如何工作的？通过一个详细的图来展示一下。</p><p><img src="https://s2.loli.net/2023/03/02/1mlGgDUisLpfwCK.png"></p><ol><li>首先创建一个新的 <code>goroutine</code></li><li>如果本地的局部队列中有足够的空间可以存放，则放入局部队列中；<strong>如果局部队列满，则放入一个全局队列（所有的 <code>M</code> 都可以从全局队列中拉取 <code>G</code> 来执行）</strong></li><li>所有的 <code>G</code> 都必须在 <code>M</code> 上才可以被执行，<code>M</code> 和 <code>P</code> <strong>存在一一绑定的关系</strong>，如果 <code>M</code> 绑定的 <code>P</code> 中存在可以被执行的 <code>G</code>，则从 <code>P</code> 中拉取 <code>G</code> 来执行；如果 <code>P</code> 中为空，没有可执行的 <code>G</code>，则  <code>M</code> 从全局队列中拉取；如果全局队列也为空，则从其他的 <code>P</code> 中拉取 <code>G</code></li><li>为 <code>G</code> 的运行分配必要的资源，等待 CPU 的调度</li><li>分配到 CPU，执行 <code>func()&#123;&#125;</code></li></ol><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>整个 goroutine 调度器最重要的调度策略是：<strong>复用</strong>，避免频繁的资源创建和销毁，最大限度的提升系统的吞吐量和并发程度。这也是操作系统进行线程调度的终极目标。复用（reuse）也是很多「池化技术」的基础。</p><p>围绕着这一原则，goroutine 调度器在以下几个方面进行调度策略的优化。</p><ol><li><strong>工作队列的窃取机制</strong>：这个跟 <code>Java</code> 中的 <code>ForkJoin Pool</code> 的窃取机制同一原理，都是当线程 <code>M</code> 空闲时，从其他繁忙的队列 <code>P</code> 中”窃取”任务 <code>G</code> 过来执行，而不是销毁空闲的 M。因为线程的创建和销毁是需要消耗系统资源的，避免线程的频繁创建和销毁可以极大的提升系统的并发程度。</li><li><strong>交接机制</strong>：当线程M被阻塞的时候，<code>M</code> 会主动将 <code>P</code> 交接给其他空闲的 <code>M</code>。</li></ol><p>另外，在 go 的 1.14 版本中，go 语言的技术团队尝试在调度器中添加了可抢占的技术. (<a href="https://github.com/golang/go/issues/24543)[https://github.com/golang/go/issues/24543]">https://github.com/golang/go/issues/24543)[https://github.com/golang/go/issues/24543]</a></p><p>抢占技术的出现一方面解决了线程 M 在执行计算密集型任务时长时间占用 CPU，导致与之绑定的 P 上的其他 G 得不到执行而造成的”饥饿现象”；<br>另一方面，抢占技术的出现对 GC 来讲解决 GC 时可能出现的 deadLock，相关的 issue 见：关于 GC 时 tight loops 应该可以被抢占的讨论(<a href="https://github.com/golang/go/issues/10958)[https://github.com/golang/go/issues/10958]">https://github.com/golang/go/issues/10958)[https://github.com/golang/go/issues/10958]</a></p><h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="https://s2.loli.net/2023/03/02/Gtfui5noD6pvgSC.png"></p><p>特殊的 M0 和 G0</p><ul><li><strong>M0</strong> 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</li><li><strong>G0</strong> 是每次启动一个 M 都会第一个创建的 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</li></ul><h3 id="最开始的-MG-模型"><a href="#最开始的-MG-模型" class="headerlink" title="最开始的 MG 模型"></a>最开始的 MG 模型</h3><p>在 go 语言的早期，goroutine 调度器的模型并不是 GMP，而是 GM。整个调度器维护一个全局的 G 的等待队列，所有的 M 从这个全局的队列中拉取 G 来执行，在 go1.1 中将这种模型直接干掉，取而代之的是现在的 GMP 模型，在 GM 模型的基础上增加 P 局部队列。官方之所有这么这么做，原因有三：</p><ol><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。</li><li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。</li><li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><p><img src="https://s2.loli.net/2023/03/02/aZFKq7k34tECHGu.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learnku.com/articles/41728">[Golang三关-典藏版] Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="https://mp.weixin.qq.com/s/1CY3E5daJ5U42orVwzCpaw">Go Scheduler 的 GMP 模型</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/02/Golang-GMP%E6%A8%A1%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Filebeat轻量型日志采集器-自定义processors处理器</title>
      <link>https://ch3nnn.github.io/2023/02/23/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</link>
      <guid>https://ch3nnn.github.io/2023/02/23/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</guid>
      <pubDate>Thu, 23 Feb 2023 10:14:25 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;引入对beat的依赖&quot;&gt;&lt;a href=&quot;#引入对beat的依赖&quot; class=&quot;headerlink&quot; title=&quot;引入对beat的依赖&quot;&gt;&lt;/a&gt;引入对beat的依赖&lt;/h2&gt;&lt;p&gt;&lt;code&gt;go get github.com/elastic/beats/</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="引入对beat的依赖"><a href="#引入对beat的依赖" class="headerlink" title="引入对beat的依赖"></a>引入对beat的依赖</h2><p><code>go get github.com/elastic/beats/v7</code></p><h2 id="定义在filebeat中的配置文件"><a href="#定义在filebeat中的配置文件" class="headerlink" title="定义在filebeat中的配置文件"></a>定义在filebeat中的配置文件</h2><p>filebeat通常以配置文件的方式加载插件。让定义一下自定义配置。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">example/example.log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="comment"># 自定义处理器插件  </span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">parse_text:</span></span><br><span class="line">      <span class="attr">file_has_suffix:</span> <span class="string">example.log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">output.console:</span></span><br><span class="line">  <span class="attr">pretty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="go文件中的配置"><a href="#go文件中的配置" class="headerlink" title="go文件中的配置"></a>go文件中的配置</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> actions</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">FileHasSuffix <span class="type">string</span> <span class="string">`config:&quot;file_has_suffix&quot; validate:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化加载插件"><a href="#初始化加载插件" class="headerlink" title="初始化加载插件"></a>初始化加载插件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">processors.RegisterPlugin(<span class="string">&quot;parse_text&quot;</span>,</span><br><span class="line">checks.ConfigChecked(NewParseText,</span><br><span class="line">checks.RequireFields(<span class="string">&quot;file_has_suffix&quot;</span>)),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Run接口"><a href="#Run接口" class="headerlink" title="Run接口"></a>Run接口</h2><p>处理 <strong>filebeat</strong> 读取到的每行日志数据<code>message</code>, 这里我们就可以自定义一些处理解析逻辑, 下面逻辑是将日志数据按<code>,</code>切分,重新组装到<code>event.Fields</code>字段里.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p parseText)</span></span> Run(event *beat.Event) (*beat.Event, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> !p.isParseFile(event) &#123;</span><br><span class="line"><span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">message, err := p.getMessage(event)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按空格切分文本</span></span><br><span class="line">split := strings.Split(message, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">p.result[<span class="string">&quot;split&quot;</span>] = split</span><br><span class="line">_, err = event.Fields.Put(<span class="string">&quot;parse_text&quot;</span>, p.result)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">&quot;filebeat-plugin/pkg/processors/actions&quot;</span>  <span class="comment">// 这里需要将自定义插件注册</span></span><br><span class="line"><span class="string">&quot;github.com/elastic/beats/v7/filebeat/cmd&quot;</span></span><br><span class="line">inputs <span class="string">&quot;github.com/elastic/beats/v7/filebeat/input/default-inputs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := cmd.Filebeat(inputs.Init, cmd.FilebeatSettings()).Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包-build"><a href="#打包-build" class="headerlink" title="打包 build"></a>打包 build</h2><p>项目路径下执行 <code>go build -o filebeat.exe  ./cmd/filebeat/</code></p><h2 id="解析结果及源日志"><a href="#解析结果及源日志" class="headerlink" title="解析结果及源日志"></a>解析结果及源日志</h2><p>源日志如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">I,am,Bat,I</span><br></pre></td></tr></table></figure><p>解析后 <code>parse_text</code> 字段数据如下:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;parse_text&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;am&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;Bat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;I&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>完整解析结果如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@timestamp&quot;: &quot;2023-02-23T10:26:05.154Z&quot;,</span><br><span class="line">  &quot;@metadata&quot;: &#123;</span><br><span class="line">    &quot;beat&quot;: &quot;filebeat&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;_doc&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;7.13.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;host&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;chentong.local&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;agent&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;7.13.4&quot;,</span><br><span class="line">    &quot;hostname&quot;: &quot;chentong.local&quot;,</span><br><span class="line">    &quot;ephemeral_id&quot;: &quot;02d53454-19dc-4fff-9182-8f04a402e399&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;f10cf835-535b-4714-8bc4-1c0b3636ae1d&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;chentong.local&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;filebeat&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ecs&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.8.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;parse_text&quot;: &#123;</span><br><span class="line">    &quot;split&quot;: [</span><br><span class="line">      &quot;I&quot;,</span><br><span class="line">      &quot;am&quot;,</span><br><span class="line">      &quot;Bat&quot;,</span><br><span class="line">      &quot;I&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;log&quot;: &#123;</span><br><span class="line">    &quot;offset&quot;: 187,</span><br><span class="line">    &quot;file&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;filebeat-plugin/example/example.log&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: &quot;I,am,Bat,I&quot;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/ch3nnn/filebeat-plugin">https://github.com/ch3nnn/filebeat-plugin</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/02/23/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
