<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ch3nnn个人博客</title>
    <link>https://ch3nnn.github.io/</link>
    
    <atom:link href="https://ch3nnn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>小站主要用来分享和记录学习经验,教程,记录个人生活的点滴以及一些随笔.</description>
    <pubDate>Thu, 02 Feb 2023 08:54:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang-代码断行规则</title>
      <link>https://ch3nnn.github.io/2023/02/02/Golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</link>
      <guid>https://ch3nnn.github.io/2023/02/02/Golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</guid>
      <pubDate>Thu, 02 Feb 2023 08:37:59 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。&lt;/p&gt;
&lt;h2 id=&quot;分号插入规则&quot;&gt;&lt;a href=&quot;#分号插入规则&quot; class=&quot;headerli</description>
        
      
      
      
      <content:encoded><![CDATA[<p>如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。</p><h2 id="分号插入规则"><a href="#分号插入规则" class="headerlink" title="分号插入规则"></a>分号插入规则</h2><p>我们在Go编程中常遵循的一个规则是：一个显式代码块的起始左大括号{不放在下一行。 比如，下面这个for循环代码块编译将失败。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i--</span><br><span class="line">&#123; <span class="comment">// error: 未预料到的新行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让上面这个for循环代码块编译成功，我们不能在起始左大括号{前断行，而应该像下面这样进行修改：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，有时候起始左大括号{却可以放在一个新行上，比如下面这个for循环代编译时没有问题的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，Go代码中的根本性换行规则究竟是如何定义的呢？ 在回答这个问题之前，我们应该知道一个事实：正式的Go语法是使用（英文）分号;做为结尾标识符的。 但是，我们很少在Go代码中使用和看到分号。为什么呢？原因是大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。</p><p>比如，下面这个程序中的十个分号都是可以被省略掉的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">i   <span class="type">int</span>;</span><br><span class="line">sum <span class="type">int</span>;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">6</span> &#123;</span><br><span class="line">sum += i;</span><br><span class="line">i++;</span><br><span class="line">&#125;;</span><br><span class="line">fmt.Println(sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设上面这个程序存储在一个semicolons.go文件中，我们可以运行go fmt semicolons.go将此程序中的不必要的分号去除掉。 在编译时刻，编译器会自动此插入这些去除掉的分号（至此文件的内存中的版本）。</p><p>自动插入分号的规则是什么呢？Go白皮书这样描述：</p><ul><li>在Go代码中，注释除外，如果一个代码行的最后一个语法词段（token）为下列所示之一，则一个分号将自动插入在此字段后（即行尾）：<ul><li>一个标识符；</li><li>一个整数、浮点数、虚部、码点或者字符串字面量；</li><li>这几个跳转关键字之一：<code>break</code>、<code>continue</code>、<code>fallthrough</code>和<code>return</code>； </li><li>自增运算符++或者自减运算符–；</li><li>一个右括号：<code>)</code>、<code>]</code>或<code>&#125;</code>。</li></ul></li><li>为了允许一条复杂语句完全显示在一个代码行中，分号可能被插入在一个右小括号)或者右大括号}之前。<br> 对于上述第一条规则描述的情形，我们当然也可以手动插入这些分号，就像此前的例子中所示。换句话说，这些分号在编程时是可选的。</li></ul><p>上述第二条规则允许我们写出如下的代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (_ <span class="string">&quot;math&quot;</span>; <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> (a <span class="type">int</span>; b <span class="type">string</span>)</span><br><span class="line"><span class="keyword">const</span> (M = <span class="literal">iota</span>; N)</span><br><span class="line"><span class="keyword">type</span> (MyInt <span class="type">int</span>; T <span class="keyword">struct</span>&#123;x <span class="type">bool</span>; y <span class="type">int32</span>&#125;)</span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span>&#123;m1(<span class="type">int</span>) <span class="type">int</span>; m2() <span class="type">string</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>); <span class="built_in">panic</span>(<span class="literal">nil</span>)&#125;</span><br></pre></td></tr></table></figure><p>编译器在编译时刻将自动插入所需的分号，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (a <span class="type">int</span>; b <span class="type">string</span>;);</span><br><span class="line"><span class="keyword">const</span> (M = <span class="literal">iota</span>; N;);</span><br><span class="line"><span class="keyword">type</span> (MyInt <span class="type">int</span>; T <span class="keyword">struct</span>&#123;x <span class="type">bool</span>; y <span class="type">int32</span>;&#125;;);</span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span>&#123;m1(<span class="type">int</span>) <span class="type">int</span>; m2() <span class="type">string</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>); <span class="built_in">panic</span>(<span class="literal">nil</span>);&#125;;</span><br></pre></td></tr></table></figure><p>编译器不会为其它任何情形插入分号。如果其它任何情形需要一个分号，我们必须手动插入此分号。 比如，上例中的每行中的第一个分号必须手动插入。下例中的分号也都需要手动插入。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line">a++; b = !b</span><br><span class="line"><span class="built_in">print</span>(a); <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>从以上两条规则可以看出，一个分号永远不会插入在<code>for</code>关键字后，这就是为什么上面的裸<code>for</code>循环例子是合法的。</p><p>分号自动插入规则导致的一个结果是：自增和自减运算必须呈现为单独的语句，它们不能被当作表达式使用。 比如，下面的代码是编译不通过的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="built_in">println</span>(a++)</span><br><span class="line"><span class="built_in">println</span>(a--)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码编译不通过的原因是它等价于下面的代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="built_in">println</span>(a++;)</span><br><span class="line"><span class="built_in">println</span>(a--;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分号自动插入规则导致的另一个结果是：我们不能在选择器中的句点.之前断行。 在选择器中的句点之后断行是允许的，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anObject.</span><br><span class="line">    MethodA().</span><br><span class="line">    MethodB().</span><br><span class="line">    MethodC()</span><br></pre></td></tr></table></figure><p>而下面这样是非法的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anObject</span><br><span class="line">    .MethodA()</span><br><span class="line">    .MethodB()</span><br><span class="line">    .MethodC()</span><br></pre></td></tr></table></figure><p>此代码片段是非法的原因是编译器将自动在每个右小括号)后插入一个分号，如下面所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anObject;</span><br><span class="line">    .MethodA();</span><br><span class="line">    .MethodB();</span><br><span class="line">    .MethodC();</span><br></pre></td></tr></table></figure><p>上述分号自动插入规则可以让我们写出更简洁的代码，同时也允许我们写出一些合法的但看上去有些怪异的代码，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span></span> <span class="type">bool</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">i &lt; <span class="number">6</span></span><br><span class="line">i++ &#123;</span><br><span class="line"><span class="comment">// 使用i ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x := alwaysFalse()</span><br><span class="line">!x &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> alwaysFalse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中所有的流程控制代码块都是合法的。编译器将在这些行的行尾自动插入一个分号：第9行、第10行、第15行和第20行。</p><p>注意，上例中的<code>switch-case</code>代码块将输出<code>true</code>，而不是<code>false</code>。 此代码块和下面这个是不同的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> alwaysFalse() &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用<code>go fmt</code>命令格式化前者，一个分号将自动添加到<code>alwaysFalse()</code>函数调用之后，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> alwaysFalse();</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入此分号后，此代码块将和下者等价：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> alwaysFalse(); <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是它输出true的原因。</p><p>常使用go fmt和go vet命令来格式化和发现可能的逻辑错误是一个好习惯。</p><p>下面是一个很少见的情形，此情形中所示的代码看上去是合法的，但是实际上是编译不通过的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> A</span><br><span class="line">A: <span class="comment">// 这里编译没问题</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">goto</span> B</span><br><span class="line">B: <span class="comment">// syntax error: 跳转标签后缺少语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> C</span><br><span class="line">C: <span class="comment">// 这里编译没问题</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误信息表明跳转标签的声明之后必须跟一条语句。 但是，看上去，上例中的三个标签声明没什么不同，它们都没有跟随一条语句。 那为什么只有B:标签声明是不合法的呢？ 原因是，根据上述第二条分号自动插入规则，编译器将在A:和C:标签声明之后的右大括号}字符之前插入一个分号，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> A</span><br><span class="line">A:</span><br><span class="line">;&#125; <span class="comment">// 一个分号插入到了这里</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">goto</span> B</span><br><span class="line">B: <span class="comment">// syntax error: 跳转标签后缺少语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> C</span><br><span class="line">C:</span><br><span class="line">;&#125; <span class="comment">// 一个分号插入到了这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个单独的分号实际上表示一条空语句。 这就意味着A:和C:标签声明之后确实跟随了一条语句，所以它们是合法的。 而B:标签声明跟随的case 0:不是一条语句，所以它是不合法的。</p><p>我们可以在B:标签声明之后手动插入一个分号使之变得合法。</p><h2 id="逗号-从不会被自动插入"><a href="#逗号-从不会被自动插入" class="headerlink" title="逗号,从不会被自动插入"></a>逗号,从不会被自动插入</h2><p>一些包含多个类似项目的语法形式多用逗号,来做为这些项目之间的分割符，比如组合字面量和函数参数列表等。 在这样的一个语法形式中，最后一个项目后总可以跟一个可选的逗号。 如果此逗号为它所在代码行的最后一个有效字符，则此逗号是必需的；否则，此逗号可以省略。 编译器在任何情况下都不会自动插入逗号。</p><p>比如，下面的代码是合法的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a <span class="type">int</span>, b <span class="type">string</span>,)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span>,) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="number">789</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f2 <span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">string</span>)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> f3 <span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">string</span>, // 最后一个逗号是必需的</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span>,             <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>,&#125; <span class="comment">// 最后一个逗号是可选的</span></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>,  <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span>,) <span class="comment">// 最后一个逗号是可选的</span></span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span>,  <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span>)</span><br><span class="line"><span class="comment">// 对于显式转换也是一样的：</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="type">string</span>(<span class="number">65</span>,) <span class="comment">// 最后一个逗号是可选的</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="type">string</span>(<span class="number">65</span>,  <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而下面这段代码是不合法的，因为编译器将自动在每一行的行尾插入一个分号（除了第二行）。 其中三行在插入分号后将导致编译错误。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a <span class="type">int</span>, b <span class="type">string</span>,)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span> <span class="comment">// error</span></span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="number">789</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> <span class="comment">// error: unexpected newline</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span> <span class="comment">// error: unexpected newline</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后，根据上面的解释，在这里描述一下Go代码中的断行规则。</p><p>在Go代码中，以下断行是没问题的（不影响程序行为的）：</p><ul><li>在除了<code>break</code>、<code>continue</code>和<code>return</code>这几个跳转关键字之外的任何关键字之后断行，或者在不跟随标签的<code>break</code>和<code>continue</code>关键字以及不跟随返回值的<code>return</code>关键字之后断行；</li><li>在（显式输入的或者隐式被编译器插入的）分号;之后断行；</li><li>在不会导致新的隐式分号被编译器插入的情况下断行。</li></ul><p>和很多Go中的其它设计细节一样，Go代码断行规则设计的评价也是褒贬不一。 有些程序员不太喜欢这样的断行规则，因为这样的规则限制了代码风格的自由度。 但是这些规则不但使得代码编译速度大大提高，另一方面也使得不同Go程序员写出的代码风格大体一致，从而相互可以比较轻松地读懂对方的代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gfw.go101.org/article/line-break-rules.html">Go代码断行规则</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/02/02/Golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Facebook 开源 Golang 实体框架 Ent</title>
      <link>https://ch3nnn.github.io/2023/01/16/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</link>
      <guid>https://ch3nnn.github.io/2023/01/16/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Mon, 16 Jan 2023 09:29:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs16738590832901.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs16738590832901.jpg"></p><p>ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。</p><ul><li><strong>图就是代码</strong> - 将任何数据库表建模为Go对象。</li><li><strong>轻松地遍历任何图形</strong> - 可以轻松地运行查询、聚合和遍历任何图形结构。</li><li><strong>静态类型和显式API</strong> - 使用代码生成静态类型和显式API，查询数据更加便捷。</li><li><strong>多存储驱动程序</strong> - 支持MySQL, PostgreSQL, SQLite 和 Gremlin。</li><li><strong>可扩展</strong> - 简单地扩展和使用Go模板自定义。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">go install entgo.io/ent/cmd/ent@latest</span><br></pre></td></tr></table></figure><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod init &lt;project&gt;</span><br></pre></td></tr></table></figure><h3 id="创建你的第一个项目"><a href="#创建你的第一个项目" class="headerlink" title="创建你的第一个项目"></a>创建你的第一个项目</h3><p>进入你项目的根目录，然后运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run -mod=mod entgo.io/ent/cmd/ent init User</span><br></pre></td></tr></table></figure><p>以上的命令会在<code>&lt;project&gt;/ent/schema/</code>目录下产生<code>User</code>的数据模式（数据模式是数据库系统设计中的专业术语，若对该部分有任何理解问题，请查阅数据库系统的相关书籍）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> schema</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;entgo.io/ent&quot;</span></span><br><span class="line"><span class="comment">// User在User实体中组合了ent默认的数据库模式定义</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ent.Schema</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User的字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> Fields() []ent.Field &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User的边</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> Edges() []ent.Edge &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为<code>User</code> 模式添加两个字段：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> schema</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;entgo.io/ent&quot;</span></span><br><span class="line">    <span class="string">&quot;entgo.io/ent/schema/field&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// User的字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> Fields() []ent.Field &#123;</span><br><span class="line">    <span class="keyword">return</span> []ent.Field&#123;</span><br><span class="line">        field.Int(<span class="string">&quot;age&quot;</span>).</span><br><span class="line">            Positive(),</span><br><span class="line">        field.String(<span class="string">&quot;name&quot;</span>).</span><br><span class="line">            Default(<span class="string">&quot;unknown&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从项目的根目录下像如下命令那样，运行<code>go generate</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go generate ./ent</span><br></pre></td></tr></table></figure><p>上述命令，将产生如下的文件：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ent</span><br><span class="line">├── client.go</span><br><span class="line">├── config.go</span><br><span class="line">├── context.go</span><br><span class="line">├── ent.go</span><br><span class="line">├── generate.go</span><br><span class="line">├── mutation.go</span><br><span class="line">... truncated</span><br><span class="line">├── schema</span><br><span class="line">│   └── user.go</span><br><span class="line">├── tx.go</span><br><span class="line">├── user</span><br><span class="line">│   ├── user.go</span><br><span class="line">│   └── where.go</span><br><span class="line">├── user.go</span><br><span class="line">├── user_create.go</span><br><span class="line">├── user_delete.go</span><br><span class="line">├── user_query.go</span><br><span class="line">└── user_update.go</span><br></pre></td></tr></table></figure><h3 id="创建你的第一个实体"><a href="#创建你的第一个实体" class="headerlink" title="创建你的第一个实体"></a>创建你的第一个实体</h3><p>首先，创建一个<code>ent.Client</code>。</p><blockquote><p>Sqlite3</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;project&gt;/ent&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/mattn/go-sqlite3&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := ent.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;file:ent?mode=memory&amp;cache=shared&amp;_fk=1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed opening connection to sqlite: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line">    <span class="comment">// 运行自动迁移工具。</span></span><br><span class="line">    <span class="keyword">if</span> err := client.Schema.Create(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed creating schema resources: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Postgres</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;project&gt;/ent&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := ent.Open(<span class="string">&quot;postgres&quot;</span>,<span class="string">&quot;host=&lt;host&gt; port=&lt;port&gt; user=&lt;user&gt; dbname=&lt;database&gt; password=&lt;pass&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed opening connection to postgres: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line">    <span class="comment">// 运行自动迁移工具。</span></span><br><span class="line">    <span class="keyword">if</span> err := client.Schema.Create(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed creating schema resources: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Mysql</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;project&gt;/ent&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := ent.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;&lt;user&gt;:&lt;pass&gt;@tcp(&lt;host&gt;:&lt;port&gt;)/&lt;database&gt;?parseTime=True&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed opening connection to mysql: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line">    <span class="comment">// 运行自动迁移工具。</span></span><br><span class="line">    <span class="keyword">if</span> err := client.Schema.Create(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed creating schema resources: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单CURD"><a href="#简单CURD" class="headerlink" title="简单CURD"></a>简单CURD</h3><p>现在，我们准备创建我们的用户。 让我们写一个 <code>CreateUser</code> 函数，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateUser 新建用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line">u, err := client.User.Create().</span><br><span class="line">SetAge(<span class="number">18</span>).</span><br><span class="line">SetName(<span class="string">&quot;a8m&quot;</span>).</span><br><span class="line">SetPhone(<span class="string">&quot;12345678&quot;</span>).</span><br><span class="line">Save(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed creating user: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;user was created: &quot;</span>, u)</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ent</code> 为每个实体结构生成一个package，包含其条件、默认值、验证器、有关存储元素的附加信息 (字段名、主键等) 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QueryUser 查询用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// `Only` 如果没有发现用户则报错,</span></span><br><span class="line"><span class="comment">// 否则正常返回。</span></span><br><span class="line">u, err := client.User.Query().Where(user.Name(<span class="string">&quot;a8m&quot;</span>)).Only(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed querying user: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;user returned: &quot;</span>, u)</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line">u, _ := QueryUser(ctx, client)</span><br><span class="line"><span class="keyword">if</span> err := client.User.DeleteOne(u).Exec(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed delete user: %w&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新用户</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line">u, _ := QueryUser(ctx, client)</span><br><span class="line">u, err := client.User.UpdateOne(u).SetAge(<span class="number">28</span>).Save(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed update user: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>完整示例请参阅 <a href="https://github.com/ch3nnn/go-study/tree/main/12-%E5%85%B6%E4%BB%96/ent">GitHub</a>.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ent.ryansu.pro/#/zh-cn/getting-started">Ent 中文文档</a></p><p><a href="https://github.com/ent/ent">Ent Github</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/16/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang:停止Goroutine有几种方法</title>
      <link>https://ch3nnn.github.io/2023/01/12/Golang-%E5%81%9C%E6%AD%A2Goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <guid>https://ch3nnn.github.io/2023/01/12/Golang-%E5%81%9C%E6%AD%A2Goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Thu, 12 Jan 2023 10:23:23 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;goroutine介绍&quot;&gt;&lt;a href=&quot;#goroutine介绍&quot; class=&quot;headerlink&quot; title=&quot;goroutine介绍&quot;&gt;&lt;/a&gt;goroutine介绍&lt;/h3&gt;&lt;p&gt;goroutine 是 Go 语言实现并发编程的利器，是 Go语言中</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="goroutine介绍"><a href="#goroutine介绍" class="headerlink" title="goroutine介绍"></a>goroutine介绍</h3><p>goroutine 是 Go 语言实现并发编程的利器，是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理，简单的一个指令go function就能启动一个 goroutine；Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。</p><p>但是，Go语言并没有提供终止goroutine的接口，也就是说，我们不能从外部去停止一个goroutine，只能由goroutine内部退出(main函数终止除外)；</p><h3 id="goroutine-案例"><a href="#goroutine-案例" class="headerlink" title="goroutine 案例"></a>goroutine 案例</h3><p>日常开发开启一个 goroutine go代码, 只需一个 go 关键字即可:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 等待组，用来阻塞程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 等待组 +1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;开启 goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="几种停止的办法"><a href="#几种停止的办法" class="headerlink" title="几种停止的办法"></a>几种停止的办法</h3><p>Go 目前用 channel 或 context 的方式来取消 (cancelation) 给 goroutine。</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><ul><li>第一种方法，就是借助 channel 的 close 机制来完成对 goroutine 的精确控制。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;[go-routine] start&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-msg:</span><br><span class="line">fmt.Println(<span class="string">&quot;[go-routine] done&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 必须 return, 否则 goroutine 不会结束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;close channel&quot;</span>)</span><br><span class="line"><span class="built_in">close</span>(msg) <span class="comment">// 直接关闭通道 程序结束</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二种方法，通过定期轮训 channel 其结合了第一种方法和类似信号量的处理方式。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(in, quit &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;收到退出信号&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//必须return，否则goroutine不会结束</span></span><br><span class="line"><span class="keyword">case</span> v := &lt;-in:</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//退出通道</span></span><br><span class="line">in := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(in, quit)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">in &lt;- i</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quit &lt;- <span class="number">1</span> <span class="comment">//想通道写入退出信号</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Go 语言的上下文（context）来做 goroutine 的控制和关闭, 对于是一种 tree 结构的goroutine, 要停止 sub tree 使用 channel 的方式不太方便</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation1</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 让我们假设这个操作会因为某种原因失败</span></span><br><span class="line"><span class="comment">// 我们使用time.Sleep来模拟一个资源密集型操作</span></span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 我们使用在前面HTTP服务器例子里使用过的类似模式</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;halted operation2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个上下文</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"><span class="comment">// 在初始上下文的基础上创建一个有取消功能的上下文</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx) <span class="comment">//需要取消时，就调用cancel()，发出取消事件。</span></span><br><span class="line"><span class="comment">// 在不同的goroutine中运行operation2</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">operation2(ctx)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">err := operation1(ctx)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="comment">// 如果这个操作返回错误，取消所有使用相同上下文的操作</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&mid=2247489686&idx=1&sn=d2b66bd442edd8249fde3ad90895a2ea&chksm=f9040dcbce7384dd2f24d422c34a48565f5826bf7ddafb980b82be4a434f765e5881afa2f2f1&scene=178&cur_album_id=1751854579329056768#rd">回答我，停止 Goroutine 有几种方法？</a></p><p><a href="https://boy921.medium.com/go-%E5%A6%82%E4%BD%95%E5%8E%BB%E5%81%9C%E6%AD%A2-goroutine-df35accf8428">Go 如何去停止 goroutine</a></p><p><a href="https://www.imooc.com/article/327620">GoLang 使用 goroutine 停止的几种办法</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/12/Golang-%E5%81%9C%E6%AD%A2Goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang:值传递还是引用传递</title>
      <link>https://ch3nnn.github.io/2023/01/09/Golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link>
      <guid>https://ch3nnn.github.io/2023/01/09/Golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
      <pubDate>Mon, 09 Jan 2023 10:09:14 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Go-官方的定义&quot;&gt;&lt;a href=&quot;#Go-官方的定义&quot; class=&quot;headerlink&quot; title=&quot;Go 官方的定义&quot;&gt;&lt;/a&gt;Go 官方的定义&lt;/h2&gt;&lt;p&gt;本部分引用 Go 官方 FAQ 的 “When are function parameter</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Go-官方的定义"><a href="#Go-官方的定义" class="headerlink" title="Go 官方的定义"></a>Go 官方的定义</h2><p>本部分引用 Go 官方 FAQ 的 “When are function parameters passed by value?”，内容如下。</p><p>如同 C 系列的所有语言一样，Go 语言中的所有东西都是以值传递的。也就是说，一个函数总是得到一个被传递的东西的副本，就像有一个赋值语句将值赋给参数一样。</p><h2 id="传值和传引用"><a href="#传值和传引用" class="headerlink" title="传值和传引用"></a>传值和传引用</h2><h3 id="什么是传值（值传递）"><a href="#什么是传值（值传递）" class="headerlink" title="什么是传值（值传递）"></a>什么是传值（值传递）</h3><p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。<strong>其指的是在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</strong> 比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。</p><p>对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。</p><p>test_demo.go</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(ip *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;函数里接收到的指针的内存地址是：%p\n&quot;</span>, &amp;ip)</span><br><span class="line">*ip = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">ip := &amp;i</span><br><span class="line">fmt.Printf(<span class="string">&quot;原始指针的内存地址是：%p\n&quot;</span>, &amp;ip)</span><br><span class="line">modify(ip)</span><br><span class="line">fmt.Println(<span class="string">&quot;int值被修改了，新值为:&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 输出结果:<br> <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">原始指针的内存地址是：0xc00000e038</span><br><span class="line">函数里接收到的指针的内存地址是：0xc00000e040</span><br><span class="line">int值被修改了，新值为: 1</span><br></pre></td></tr></table></figure></p><h3 id="什么是传引用-引用传递"><a href="#什么是传引用-引用传递" class="headerlink" title="什么是传引用(引用传递)"></a>什么是传引用(引用传递)</h3><p>传引用，也叫做引用传递， <strong>指在调用函数时将实际参数的地址直接传递到函数中</strong>，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>在 Go 语言中，官方已经明确了没有传引用，也就是没有引用传递这一情况。</p><p><strong>争议最大的 map 和 slice</strong><br>这时候又有小伙伴疑惑了，你看 Go 语言中的 map 和 slice 类型，能直接修改，难道不是同个内存地址，不是引用了？</p><p>其实在 FAQ 中有一句提醒很重要：“map 和 slice 的行为类似于指针，它们是包含指向底层 map 或 slice 数据的指针的描述符”。</p><p><strong>迷惑map</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(p <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;函数里接收到map的内存地址是：%p\n&quot;</span>, &amp;p)</span><br><span class="line">p[<span class="string">&quot;张三&quot;</span>] = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">persons := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">persons[<span class="string">&quot;张三&quot;</span>] = <span class="number">19</span></span><br><span class="line"></span><br><span class="line">mp := &amp;persons</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;原始map的内存地址是：%p\n&quot;</span>, mp)</span><br><span class="line">modify(persons)</span><br><span class="line">fmt.Println(<span class="string">&quot;map值被修改了，新值为:&quot;</span>, persons)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">原始map的内存地址是：0xc000114028</span><br><span class="line">函数里接收到map的内存地址是：0xc000114030</span><br></pre></td></tr></table></figure><p>确实是值传递，那修改后的 map 的结果应该是什么。既然是值传递，那肯定就是 “这次一定！”，对吗？</p><p>输出结果:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">map值被修改了，新值为: map[张三:20]</span><br></pre></td></tr></table></figure><p>原因:</p><p>指针类型可以修改，非指针类型不行，可以大胆的猜测，使用<code>make</code>函数创建的<code>map</code>是不是一个指针类型呢？看一下源代码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makemap implements a Go map creation make(map[k]v, hint)</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If bucket != nil, bucket can be used as the first bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int64</span>, h *hmap, bucket unsafe.Pointer)</span></span> *hmap &#123;</span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看<code>src/runtime/hashmap.go</code>源代码发现，注意其返回的是 <code>*hmap</code>类型，是一个指针。也就是 Go 语言通过对 <code>map</code> 类型的相关方法进行封装，达到了用户需要关注指针传递的作用。</p><p>现在看<code>func modify(p map)</code>这样的函数，其实就等于<code>func modify(p *hmap)</code>，和前面什么是值传递里举的<code>func modify(ip *int)</code>的例子一样，可以参考分析。</p><p>这类情况我们称其为 <strong>“引用类型”</strong> ，但 “引用类型” 不等同于就是传引用，又或是引用传递了，还是有比较明确的区别的。</p><p><strong>chan类型</strong></p><p>chan类型本质上和map类型是一样的，这里不做过多的介绍，参考下源代码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chan</code>也是一个引用类型，和<code>map</code>相差无几，<code>make</code>返回的是一个<code>*hchan</code>。</p><p><strong>和map、chan都不一样的slice</strong></p><p><code>slice</code>和<code>map</code>、<code>chan</code>都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(ages []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;函数里接收到slice的内存地址是%p\n&quot;</span>, ages)</span><br><span class="line">ages[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ages := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;原始slice的内存地址是%p\n&quot;</span>, ages)</span><br><span class="line">modify(ages)</span><br><span class="line">fmt.Println(ages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果来看，两者的内存地址一样，也成功的变更到了变量 <code>ages</code> 的值。这难道不是引用传递吗?<br>关注两个细节：</p><ul><li>没有用 <code>&amp; </code>来取地址。</li><li>可以直接用 <code>%p</code> 来打印。</li></ul><p>之所以可以同时做到上面这两件事，是因为标准库 <code>fmt</code> 针对在这一块做了优化：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> fmtPointer(value reflect.Value, verb <span class="type">rune</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> u <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">switch</span> value.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:</span><br><span class="line">        u = value.Pointer()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p.badVerb(verb)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源代码发现，对于<code>chan</code>、<code>map</code>、<code>slice</code>等被当成指针处理，通过<code>value.Pointer()</code>获取对应的值的指针。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If v&#x27;s Kind is Slice, the returned pointer is to the first</span></span><br><span class="line"><span class="comment">// element of the slice. If the slice is nil the returned value</span></span><br><span class="line"><span class="comment">// is 0.  If the slice is empty but non-nil the return value is non-zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Pointer() <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> deprecate</span></span><br><span class="line">    k := v.kind()</span><br><span class="line">    <span class="keyword">switch</span> k &#123;</span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">    <span class="keyword">case</span> Slice:</span><br><span class="line">        <span class="keyword">return</span> (*SliceHeader)(v.ptr).Data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显了，当是<code>slice</code>类型的时候，返回是<code>slice</code>这个结构体里，字段<code>Data</code>第一个元素的地址。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">    Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言运行时，传递的也是相应 <code>slice</code> 类型的底层数组的指针，但需要注意，其使用的是指针的副本。严格意义是引用类型，依旧是值传递。<code>slice</code>是一种结构体+元素指针的混合类型，通过元素<code>array(Data)</code>的指针，可以达到修改<code>slice</code>里存储元素的目的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最终可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。</p><p>让最多人犯迷糊的就是 <code>slice</code>、<code>map</code>、<code>chan</code> 等类型，都会认为是 “引用传递”，从而认为 Go 语言的 xxx 就是引用传递。正因为它们还引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</p><p><strong>再记住，Go里只有传值（值传递）。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://eddycjy.com/posts/go/value-quote/">群里又吵起来了，Go 是传值还是传引用？</a><br><a href="https://zhuanlan.zhihu.com/p/34203214">Go语言参数传递是传值还是传引用</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/09/Golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Filebeat轻量型日志采集器及output插件开发</title>
      <link>https://ch3nnn.github.io/2023/01/09/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
      <guid>https://ch3nnn.github.io/2023/01/09/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
      <pubDate>Mon, 09 Jan 2023 08:36:01 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; cl</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Filebeat 是使用 Golang 实现的轻量型日志采集器。本质上是一个 agent ，可以安装在各个节点上，根据配置读取对应位置的日志，并上报到相应的地方去。</p><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Filebeat 并不依赖于 ElasticSearch，可以单独存在。我们可以单独使用Filebeat进行日志的上报和搜集。filebeat 内置了常用的 Output 组件, 例如 kafka、ElasticSearch、redis 等，出于调试考虑，也可以输出到 console 和 file 。我们可以利用现有的 Output 组件，将日志进行上报。</p><h3 id="整体工作原理"><a href="#整体工作原理" class="headerlink" title="整体工作原理"></a>整体工作原理</h3><p>Filebeat 由两个主要组件组成：harvester 和 prospector。</p><ul><li>harvester (采集器) 的主要职责是读取单个文件的内容。读取每个文件，并将内容发送到 the output。 每个文件启动一个 harvester，harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态。如果文件在读取时被删除或重命名，Filebeat 将继续读取文件。</li><li>prospector (查找器) 的主要职责是管理 harvester 并找到所有要读取的文件来源。如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个 harvester。每个 prospector 都在自己的 Go 协程中运行。<blockquote><p><em>注：Filebeat prospector只能读取本地文件， 没有功能可以连接到远程主机来读取存储的文件或日志。</em></p></blockquote></li></ul><p>由以上两个组件一起工作来读取文件（tail file）并将事件数据发送到指定的输出。<br>下图是 Filebeat 官方提供的架构图：<br><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs20230109163928.png"></p><h4 id="Filebeat背后的“老大”"><a href="#Filebeat背后的“老大”" class="headerlink" title="Filebeat背后的“老大”"></a>Filebeat背后的“老大”</h4><p>说到Filebeat，它其实只是<a href="https://links.jianshu.com/go?to=https://github.com/elastic/beats/tree/master/libbeat">beats家族</a>众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：</p><table><thead><tr><th>beat</th><th>功能</th></tr></thead><tbody><tr><td>Filebeat</td><td>收集日志文件</td></tr><tr><td>Metricbeat</td><td>收集各种指标数据</td></tr><tr><td>Packetbeat</td><td>收集网络数据包</td></tr><tr><td>Auditbeat</td><td>收集审计数据</td></tr><tr><td>Heartbeat</td><td>收集服务运行状态监测数据</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>如果你愿意的话，你也可以按照beat的规范来写自己的beat。<br>能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么</p><ul><li>libbeat提供了publisher组件，用于对接input；</li><li>收集到的数据在进入到libbeat后，首先会经过各种 processor的加工处理，比如过滤添加字段，多行合并等等；</li><li>input组件通过publisher组件将收集到的数据推送到publisher内部的队列；</li><li>libbeat本身实现了前面介绍过的多种output, 因此它负责将处理好的数据通过output组件发送出去；</li><li>libbeat本身封装了retry的逻辑；</li><li>libbeat负责将ACK反馈通过到input组件 ；</li></ul><p>由此可见，大部分活儿都是libbeat来作，当“老大”不容易啊～。<br>input仅需要作两件事：</p><ul><li>从不同的介质中收集数据后投递给libbeat;</li><li>接收libbeat反馈回来的ACK, 作相应的持久化;</li></ul><h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><p>Filebeat 基于 Go 语言开发无其他依赖，它最大的特点是性能稳定、配置简单、占用系统资源很少，安装使用也非常简单，可访问 Elastic-Beats 官网获取各版本 Filebeat。因为 Filebeat 各版本之间的差异较大，这里推荐7以上的新版，首先进行下载解压：<br>tar -zxvf filebeat-7.tar.gz mv filebeat-7 filebeat cd filebeat</p><h3 id="FileBeat启停指令："><a href="#FileBeat启停指令：" class="headerlink" title="FileBeat启停指令："></a>FileBeat启停指令：</h3><ul><li>调试模式下采用：终端启动（退出终端或 ctrl+c 会退出运行）</li></ul><p><code>./filebeat -e -c filebeat.yml</code></p><ul><li>线上环境配合 error 级别使用：以后台守护进程启动启动 filebeats</li></ul><p><code>nohup ./filebeat -e -c filebeat.yml &amp;</code></p><ul><li>零输出启动（不推荐）：将所有标准输出及标准错误输出到&#x2F;dev&#x2F;null空设备，即没有任何输出信息。</li></ul><p><code>nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</code></p><ul><li>停止运行 FileBeat 进程</li></ul><p><code>ps -ef | grep filebeat Kill -9 线程号</code></p><h3 id="FileBeat配置文件"><a href="#FileBeat配置文件" class="headerlink" title="FileBeat配置文件"></a>FileBeat配置文件</h3><p>FileBeat 的配置文件定义了在读取文件的位置，输出流的位置以及相应的性能参数，本实例是以 Kafka 消息中间件作为缓冲，所有的日志收集器都向 Kafka 输送日志流，相应的配置项如下，并附配置说明：</p><p>filebeat.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/wls/applogs/rtlog/app.log</span></span><br><span class="line">  <span class="attr">fields:</span> </span><br><span class="line">    <span class="attr">log_topic:</span> <span class="string">appName</span></span><br><span class="line">  <span class="attr">multiline:</span></span><br><span class="line">        <span class="comment"># pattern for error log, if start with space or cause by </span></span><br><span class="line">        <span class="attr">pattern:</span> <span class="string">&#x27;^[[:space:]]+(at|\.&#123;3&#125;)\b|^Caused by:&#x27;</span></span><br><span class="line">        <span class="attr">negate:</span>  <span class="literal">false</span></span><br><span class="line">        <span class="attr">match:</span>   <span class="string">after</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.kafka:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">hosts:</span> [<span class="string">&quot;kafka-1:9092&quot;</span>,<span class="string">&quot;kafka-2:9092&quot;</span>]</span><br><span class="line">   <span class="attr">topic:</span> <span class="string">applog</span></span><br><span class="line">   <span class="attr">version:</span> <span class="string">&quot;0.10.2.0&quot;</span></span><br><span class="line">   <span class="attr">compression:</span> <span class="string">gzip</span></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">drop_fields:</span> </span><br><span class="line">   <span class="attr">fields:</span> [<span class="string">&quot;beat&quot;</span>, <span class="string">&quot;input&quot;</span>, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;offset&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level:</span> <span class="string">error</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">app-server-ip</span></span><br></pre></td></tr></table></figure><ul><li><strong>paths</strong>:定义了日志文件路径，可以采用模糊匹配模式，如*.log</li><li><strong>fields</strong>：topic 对应的消息字段或自定义增加的字段。</li><li><strong>output.kafka</strong>：filebeat 支持多种输出，支持向 kafka，logstash，elasticsearch 输出数据，此处设置数据输出到 kafka。</li><li><strong>enabled</strong>：这个启动这个模块。</li><li><strong>topic</strong>：指定要发送数据给 kafka 集群的哪个 topic，若指定的 topic 不存在，则会自动创建此 topic。</li><li><strong>version</strong>：指定 kafka 的版本。</li><li><strong>drop_fields</strong>：舍弃字段，filebeat 会 json 日志信息，适当舍弃无用字段节省空间资源。</li><li><strong>name</strong>：收集日志中对应主机的名字，<strong>建议 name 这里设置为 IP</strong>，便于区分多台主机的日志信息。</li></ul><p>以上参数信息，需要用户个性化修改的主要是：paths，hosts，topic，version 和 name。</p><h3 id="Filebeat-input-配置热加载"><a href="#Filebeat-input-配置热加载" class="headerlink" title="Filebeat input 配置热加载"></a>Filebeat input 配置热加载</h3><p>filebeat.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.config.inputs:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">../configs/input*.yml</span></span><br><span class="line">  <span class="attr">reload.enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">reload.period:</span> <span class="string">5s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.syslog:</span></span><br><span class="line">  <span class="attr">network:</span> <span class="string">tcp</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:5140</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">tag</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fields:</span></span><br><span class="line">  <span class="attr">prober_id:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>input.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/Users/chentong/project/log-prober-go/prober-filebeat/cmd/filebeat/example.log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Filebeat-写入-kafka-示例"><a href="#Filebeat-写入-kafka-示例" class="headerlink" title="Filebeat 写入 kafka 示例"></a>Filebeat 写入 kafka 示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">    - type: log</span><br><span class="line">      paths:</span><br><span class="line">        - /var/log/*.log</span><br><span class="line">        - /Users/chentong/project/log-prober-go/logs/app.log</span><br><span class="line">output.kafka:</span><br><span class="line">    hosts:</span><br><span class="line">        - 127.0.0.1:9092</span><br><span class="line">    topic: test_filebeat</span><br><span class="line">    keep_alive: 10s</span><br><span class="line">fields:</span><br><span class="line">    prober_id: 999</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Filebeat-output-syslog插件开发"><a href="#Filebeat-output-syslog插件开发" class="headerlink" title="Filebeat output syslog插件开发"></a>Filebeat output syslog插件开发</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>filebeat 自带只支持 es、logstash、kafka、redis、file、console 数据输出. 需要自定义输出 syslog </p></blockquote><h3 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h3><h4 id="引入对beat的依赖"><a href="#引入对beat的依赖" class="headerlink" title="引入对beat的依赖"></a>引入对<code>beat</code>的依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/elastic/beats/v7</span><br></pre></td></tr></table></figure><p>定义在filebeat中的配置文件<br><code>filebeat</code>通常以配置文件的方式加载插件。让我们定义一下必须的配置，就像<code>elasticsearch</code>中的连接地址等等一样。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">output.syslog:</span></span><br><span class="line">  <span class="comment"># 接收方式</span></span><br><span class="line">  <span class="attr">network:</span> <span class="string">tcp</span>   </span><br><span class="line">  <span class="comment"># syslog 地址</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:5140</span></span><br><span class="line">  <span class="comment"># 自定义消息tag</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">tag</span></span><br></pre></td></tr></table></figure><h4 id="go文件中的配置"><a href="#go文件中的配置" class="headerlink" title="go文件中的配置"></a>go文件中的配置</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> syslogConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Network <span class="type">string</span> <span class="string">`config:&quot;network&quot;`</span></span><br><span class="line">Addr    <span class="type">string</span> <span class="string">`config:&quot;addr&quot;`</span></span><br><span class="line">Tag     <span class="type">string</span> <span class="string">`config:&quot;tag&quot;`</span></span><br><span class="line"><span class="comment">// 发布日志事件的 worker goroutines 数量</span></span><br><span class="line">Workers <span class="type">int</span> <span class="string">`config:&quot;workers&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line"><span class="comment">// Max number of events in a batch to send to a single client</span></span><br><span class="line">BatchSize <span class="type">int</span> <span class="string">`config:&quot;batch_size&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line"><span class="comment">// Max number of retries for single batch of events</span></span><br><span class="line">RetryLimit <span class="type">int</span> <span class="string">`config:&quot;retry_limit&quot; validate:&quot;min=1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="初始化加载插件"><a href="#初始化加载插件" class="headerlink" title="初始化加载插件"></a>初始化加载插件</h4><h4 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h4><p>在某个init函数中注册插件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">outputs.RegisterType(<span class="string">&quot;syslog&quot;</span>, newSyslogOutPut)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>newSyslogOutPut</code>中卸载配置，并提供配置给<code>Syslog</code>客户端</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSyslogOutPut</span><span class="params">(_ outputs.IndexManager, _ beat.Info, stats outputs.Observer, cfg *common.Config)</span></span> (outputs.Group, <span class="type">error</span>) &#123;</span><br><span class="line">config := syslogConfig&#123;Workers: <span class="number">1</span>, BatchSize: <span class="number">1</span>, RetryLimit: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">if</span> err := cfg.Unpack(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> outputs.Fail(err)</span><br><span class="line">&#125;</span><br><span class="line">clients := <span class="built_in">make</span>([]outputs.NetworkClient, config.Workers)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; config.Workers; i++ &#123;</span><br><span class="line">clients[i] = &amp;SyslogClient&#123;</span><br><span class="line">network: config.Network,</span><br><span class="line">addr:    config.Addr,</span><br><span class="line">tag:     config.Tag,</span><br><span class="line">stats:   stats,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> outputs.SuccessNet(<span class="literal">true</span>, config.BatchSize, config.RetryLimit, clients)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="初始化syslog客户端"><a href="#初始化syslog客户端" class="headerlink" title="初始化syslog客户端"></a>初始化<code>syslog</code>客户端</h4><p><code>syslog</code>客户端不仅仅是一个<code>syslog</code>客户端，而且还需要实现<code>filebeat</code>中的<code>NetworkClient</code>接口，接下来，让我们来关注接口中的每一个方法的作用及实现</p><h3 id="String-接口"><a href="#String-接口" class="headerlink" title="String()接口"></a>String()接口</h3><p><code>String</code>作为客户端的名字，用来标识日志以及指标。是最简单的一个接口</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;syslog&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Connect-接口"><a href="#Connect-接口" class="headerlink" title="Connect()接口"></a>Connect()接口</h3><p><code>Connect</code>用来初始化客户端</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> Connect() <span class="type">error</span> &#123;</span><br><span class="line">dial, err := gsyslog.DialLogger(c.network, c.addr, gsyslog.LOG_NOTICE, <span class="string">&quot;LOCAL0&quot;</span>, c.tag)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">c.client = dial</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里初始化失败，需要<code>Sleep</code>一段时间，否则，filebeat会一直重试。这绝非是你想要的。或许对于场景来说，退避重试可能会更好</p><h3 id="Close-接口"><a href="#Close-接口" class="headerlink" title="Close()接口"></a>Close()接口</h3><p>关闭客户端，也是很简单的接口</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.client.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Publish-接口"><a href="#Publish-接口" class="headerlink" title="Publish()接口"></a>Publish()接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> Publish(_ context.Context, batch publisher.Batch) <span class="type">error</span> &#123;</span><br><span class="line">events := batch.Events()</span><br><span class="line"><span class="comment">// 记录这批日志</span></span><br><span class="line">c.stats.NewBatch(<span class="built_in">len</span>(events))</span><br><span class="line">retryEvents, err := c.PublishEvents(events)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 发送失败，则重试 受RetryLimit的限制</span></span><br><span class="line">batch.RetryEvents(retryEvents)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.stats.Acked(<span class="built_in">len</span>(events))</span><br><span class="line">batch.ACK()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布 syslog 数据</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SyslogClient)</span></span> PublishEvents(events []publisher.Event) ([]publisher.Event, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i, event := <span class="keyword">range</span> events &#123;</span><br><span class="line">message, err := event.Content.Fields.GetValue(<span class="string">&quot;message&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> events[i:], err</span><br><span class="line">&#125;</span><br><span class="line">m, ok := message.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> events[i:], errors.New(<span class="string">&quot;cast log to str failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// syslog 发送数据</span></span><br><span class="line">_, err = c.client.Write([]<span class="type">byte</span>(m))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> events[i:], err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最后是SyslogClient"><a href="#最后是SyslogClient" class="headerlink" title="最后是SyslogClient"></a>最后是<code>SyslogClient</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyslogClient <span class="keyword">struct</span> &#123;</span><br><span class="line">network <span class="type">string</span></span><br><span class="line">addr    <span class="type">string</span></span><br><span class="line">tag     <span class="type">string</span></span><br><span class="line"></span><br><span class="line">stats  outputs.Observer</span><br><span class="line">client gsyslog.Syslogger</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/09/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
