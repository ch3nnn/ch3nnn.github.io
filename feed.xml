<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ch3nnn个人博客</title>
    <link>https://ch3nnn.github.io/</link>
    
    <atom:link href="https://ch3nnn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>小站主要用来分享和记录学习经验,教程,记录个人生活的点滴以及一些随笔.</description>
    <pubDate>Thu, 02 Mar 2023 09:24:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang-GMP模型</title>
      <link>https://ch3nnn.github.io/2023/03/02/Golang-GMP%E6%A8%A1%E5%9E%8B/</link>
      <guid>https://ch3nnn.github.io/2023/03/02/Golang-GMP%E6%A8%A1%E5%9E%8B/</guid>
      <pubDate>Thu, 02 Mar 2023 08:45:39 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下面通过一段简单的代码展示一下 Go 应用程序在运行时的 goroutine，方便大家更好的理解。</p><blockquote><p>The Go scheduler is part of the Go runtime, and the Go runtime is built into your application</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(runtime.NumGoroutine())</span><br></pre></td></tr></table></figure><p>上面这段代码的输出为：<code>5</code> 说明当前这个应用程序中存在 <code>goroutine</code> 的数量是 <code>5</code>，事实上也符合我们的预期。那么问题来了，这 5 个 goroutine 作为操作系统用户态的基本调度单元是无法直接占用操作系统的资源来执行的，必须经过内核级线程的分发，这是操作系统内部线程调度的基本模型，根据用户级线程和内核级线程的对应关系可以分为 1 对 1，N 对 1 以及 M 对 N 这三种模型，那么上述的 5 个 goroutine 在内核级线程上是怎么被分发的，这就是 Go语言的 goroutine 调度器决定的。</p><p><img src="https://s2.loli.net/2023/03/02/xfMIESaWZh3t2Fj.png"></p><h3 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h3><p>整个 <code>goroutine</code> 调度器的实现基于 GMP 的三级模型来实现。</p><ul><li>G：goroutine (go 代码)</li><li>M：内核级线程，运行在操作系统的核心态。(在 Go 中支持最大的 M 的数量是 10000，但是操作系统中通常情况是不可以创建这么多的线程。) </li><li>P：processor，可以理解成一个等待分发给 M 调度执行的 goroutine 队列。(P的个数是由 runtime 的 GOMAXPROCS 来决定的。)</li></ul><p>M 和 P 存在一一对应的绑定关系。大致的结构图如下所示：</p><p><img src="https://s2.loli.net/2023/03/02/A1lVJpuRBYIT3HL.png"></p><p>GMP 模型图如下:<br><img src="https://s2.loli.net/2023/03/02/GwURAv8zVTyZhpJ.png"></p><ol><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li><li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li></ol><p><strong>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。</strong></p><h3 id="goroutine-之旅"><a href="#goroutine-之旅" class="headerlink" title="goroutine 之旅"></a>goroutine 之旅</h3><p>通常情况下，我们在代码中执行 <code>go func()&#123;&#125;</code>后，GMP 模型是如何工作的？通过一个详细的图来展示一下。</p><p><img src="https://s2.loli.net/2023/03/02/1mlGgDUisLpfwCK.png"></p><ol><li>首先创建一个新的 <code>goroutine</code></li><li>如果本地的局部队列中有足够的空间可以存放，则放入局部队列中；<strong>如果局部队列满，则放入一个全局队列（所有的 <code>M</code> 都可以从全局队列中拉取 <code>G</code> 来执行）</strong></li><li>所有的 <code>G</code> 都必须在 <code>M</code> 上才可以被执行，<code>M</code> 和 <code>P</code> <strong>存在一一绑定的关系</strong>，如果 <code>M</code> 绑定的 <code>P</code> 中存在可以被执行的 <code>G</code>，则从 <code>P</code> 中拉取 <code>G</code> 来执行；如果 <code>P</code> 中为空，没有可执行的 <code>G</code>，则  <code>M</code> 从全局队列中拉取；如果全局队列也为空，则从其他的 <code>P</code> 中拉取 <code>G</code></li><li>为 <code>G</code> 的运行分配必要的资源，等待 CPU 的调度</li><li>分配到 CPU，执行 <code>func()&#123;&#125;</code></li></ol><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>整个 goroutine 调度器最重要的调度策略是：<strong>复用</strong>，避免频繁的资源创建和销毁，最大限度的提升系统的吞吐量和并发程度。这也是操作系统进行线程调度的终极目标。复用（reuse）也是很多「池化技术」的基础。</p><p>围绕着这一原则，goroutine 调度器在以下几个方面进行调度策略的优化。</p><ol><li><strong>工作队列的窃取机制</strong>：这个跟 <code>Java</code> 中的 <code>ForkJoin Pool</code> 的窃取机制同一原理，都是当线程 <code>M</code> 空闲时，从其他繁忙的队列 <code>P</code> 中”窃取”任务 <code>G</code> 过来执行，而不是销毁空闲的 M。因为线程的创建和销毁是需要消耗系统资源的，避免线程的频繁创建和销毁可以极大的提升系统的并发程度。</li><li><strong>交接机制</strong>：当线程M被阻塞的时候，<code>M</code> 会主动将 <code>P</code> 交接给其他空闲的 <code>M</code>。</li></ol><p>另外，在 go 的 1.14 版本中，go 语言的技术团队尝试在调度器中添加了可抢占的技术. (<a href="https://github.com/golang/go/issues/24543)[https://github.com/golang/go/issues/24543]">https://github.com/golang/go/issues/24543)[https://github.com/golang/go/issues/24543]</a></p><p>抢占技术的出现一方面解决了线程 M 在执行计算密集型任务时长时间占用 CPU，导致与之绑定的 P 上的其他 G 得不到执行而造成的”饥饿现象”；<br>另一方面，抢占技术的出现对 GC 来讲解决 GC 时可能出现的 deadLock，相关的 issue 见：关于 GC 时 tight loops 应该可以被抢占的讨论(<a href="https://github.com/golang/go/issues/10958)[https://github.com/golang/go/issues/10958]">https://github.com/golang/go/issues/10958)[https://github.com/golang/go/issues/10958]</a></p><h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="https://s2.loli.net/2023/03/02/Gtfui5noD6pvgSC.png"></p><p>特殊的 M0 和 G0</p><ul><li><strong>M0</strong> 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</li><li><strong>G0</strong> 是每次启动一个 M 都会第一个创建的 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</li></ul><h3 id="最开始的-MG-模型"><a href="#最开始的-MG-模型" class="headerlink" title="最开始的 MG 模型"></a>最开始的 MG 模型</h3><p>在 go 语言的早期，goroutine 调度器的模型并不是 GMP，而是 GM。整个调度器维护一个全局的 G 的等待队列，所有的 M 从这个全局的队列中拉取 G 来执行，在 go1.1 中将这种模型直接干掉，取而代之的是现在的 GMP 模型，在 GM 模型的基础上增加 P 局部队列。官方之所有这么这么做，原因有三：</p><ol><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。</li><li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。</li><li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><p><img src="https://s2.loli.net/2023/03/02/aZFKq7k34tECHGu.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learnku.com/articles/41728">[Golang三关-典藏版] Golang 调度器 GMP 原理与调度全分析</a></li><li><a href="https://mp.weixin.qq.com/s/1CY3E5daJ5U42orVwzCpaw">Go Scheduler 的 GMP 模型</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/03/02/Golang-GMP%E6%A8%A1%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Filebeat轻量型日志采集器-自定义processors处理器</title>
      <link>https://ch3nnn.github.io/2023/02/23/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</link>
      <guid>https://ch3nnn.github.io/2023/02/23/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</guid>
      <pubDate>Thu, 23 Feb 2023 10:14:25 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;引入对beat的依赖&quot;&gt;&lt;a href=&quot;#引入对beat的依赖&quot; class=&quot;headerlink&quot; title=&quot;引入对beat的依赖&quot;&gt;&lt;/a&gt;引入对beat的依赖&lt;/h2&gt;&lt;p&gt;&lt;code&gt;go get github.com/elastic/beats/</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="引入对beat的依赖"><a href="#引入对beat的依赖" class="headerlink" title="引入对beat的依赖"></a>引入对beat的依赖</h2><p><code>go get github.com/elastic/beats/v7</code></p><h2 id="定义在filebeat中的配置文件"><a href="#定义在filebeat中的配置文件" class="headerlink" title="定义在filebeat中的配置文件"></a>定义在filebeat中的配置文件</h2><p>filebeat通常以配置文件的方式加载插件。让定义一下自定义配置。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">example/example.log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="comment"># 自定义处理器插件  </span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">parse_text:</span></span><br><span class="line">      <span class="attr">file_has_suffix:</span> <span class="string">example.log</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">output.console:</span></span><br><span class="line">  <span class="attr">pretty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="go文件中的配置"><a href="#go文件中的配置" class="headerlink" title="go文件中的配置"></a>go文件中的配置</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> actions</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">FileHasSuffix <span class="type">string</span> <span class="string">`config:&quot;file_has_suffix&quot; validate:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化加载插件"><a href="#初始化加载插件" class="headerlink" title="初始化加载插件"></a>初始化加载插件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">processors.RegisterPlugin(<span class="string">&quot;parse_text&quot;</span>,</span><br><span class="line">checks.ConfigChecked(NewParseText,</span><br><span class="line">checks.RequireFields(<span class="string">&quot;file_has_suffix&quot;</span>)),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Run接口"><a href="#Run接口" class="headerlink" title="Run接口"></a>Run接口</h2><p>处理 <strong>filebeat</strong> 读取到的每行日志数据<code>message</code>, 这里我们就可以自定义一些处理解析逻辑, 下面逻辑是将日志数据按<code>,</code>切分,重新组装到<code>event.Fields</code>字段里.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p parseText)</span></span> Run(event *beat.Event) (*beat.Event, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> !p.isParseFile(event) &#123;</span><br><span class="line"><span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">message, err := p.getMessage(event)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按空格切分文本</span></span><br><span class="line">split := strings.Split(message, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">p.result[<span class="string">&quot;split&quot;</span>] = split</span><br><span class="line">_, err = event.Fields.Put(<span class="string">&quot;parse_text&quot;</span>, p.result)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">&quot;filebeat-plugin/pkg/processors/actions&quot;</span>  <span class="comment">// 这里需要将自定义插件注册</span></span><br><span class="line"><span class="string">&quot;github.com/elastic/beats/v7/filebeat/cmd&quot;</span></span><br><span class="line">inputs <span class="string">&quot;github.com/elastic/beats/v7/filebeat/input/default-inputs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := cmd.Filebeat(inputs.Init, cmd.FilebeatSettings()).Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包-build"><a href="#打包-build" class="headerlink" title="打包 build"></a>打包 build</h2><p>项目路径下执行 <code>go build -o filebeat.exe  ./cmd/filebeat/</code></p><h2 id="解析结果及源日志"><a href="#解析结果及源日志" class="headerlink" title="解析结果及源日志"></a>解析结果及源日志</h2><p>源日志如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">I,am,Bat,I</span><br></pre></td></tr></table></figure><p>解析后 <code>parse_text</code> 字段数据如下:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;parse_text&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;I&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;am&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;Bat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;I&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>完整解析结果如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@timestamp&quot;: &quot;2023-02-23T10:26:05.154Z&quot;,</span><br><span class="line">  &quot;@metadata&quot;: &#123;</span><br><span class="line">    &quot;beat&quot;: &quot;filebeat&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;_doc&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;7.13.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;host&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;chentong.local&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;agent&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;7.13.4&quot;,</span><br><span class="line">    &quot;hostname&quot;: &quot;chentong.local&quot;,</span><br><span class="line">    &quot;ephemeral_id&quot;: &quot;02d53454-19dc-4fff-9182-8f04a402e399&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;f10cf835-535b-4714-8bc4-1c0b3636ae1d&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;chentong.local&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;filebeat&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ecs&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.8.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;parse_text&quot;: &#123;</span><br><span class="line">    &quot;split&quot;: [</span><br><span class="line">      &quot;I&quot;,</span><br><span class="line">      &quot;am&quot;,</span><br><span class="line">      &quot;Bat&quot;,</span><br><span class="line">      &quot;I&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;log&quot;: &#123;</span><br><span class="line">    &quot;offset&quot;: 187,</span><br><span class="line">    &quot;file&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;filebeat-plugin/example/example.log&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: &quot;I,am,Bat,I&quot;,</span><br><span class="line">  &quot;input&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/ch3nnn/filebeat-plugin">https://github.com/ch3nnn/filebeat-plugin</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/02/23/Filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-数组与切片常见错误及陷阱</title>
      <link>https://ch3nnn.github.io/2023/02/15/Golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</link>
      <guid>https://ch3nnn.github.io/2023/02/15/Golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</guid>
      <pubDate>Wed, 15 Feb 2023 08:34:35 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;nil切片、空切片、零切片&quot;&gt;&lt;a href=&quot;#nil切片、空切片、零切片&quot; class=&quot;headerlink&quot; title=&quot;nil切片、空切片、零切片&quot;&gt;&lt;/a&gt;nil切片、空切片、零切片&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;零切片&lt;/strong&gt;&lt;/p&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="nil切片、空切片、零切片"><a href="#nil切片、空切片、零切片" class="headerlink" title="nil切片、空切片、零切片"></a>nil切片、空切片、零切片</h2><p><strong>零切片</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">------------</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>表示底层数组的二进制内容都是零</p><p><strong>「空切片」和 「nil 切片」</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// new 函数返回是指针类型，所以需要使用 * 号来解引用</span></span><br><span class="line"><span class="keyword">var</span> s4 = *<span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2), <span class="built_in">len</span>(s3), <span class="built_in">len</span>(s4))</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s1), <span class="built_in">cap</span>(s2), <span class="built_in">cap</span>(s3), <span class="built_in">cap</span>(s4))</span><br><span class="line">fmt.Println(s1, s2, s3, s4)</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">[] [] [] []</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这四种形式从输出结果上来看，似乎一摸一样，没区别。但是实际上是有区别的，我们要讲的两种特殊类型「空切片」和「 nil 切片」，就隐藏在上面的四种形式之中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> s4 = *<span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s1))</span><br><span class="line"><span class="keyword">var</span> a2 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s2))</span><br><span class="line"><span class="keyword">var</span> a3 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s3))</span><br><span class="line"><span class="keyword">var</span> a4 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s4))</span><br><span class="line">fmt.Println(a1)</span><br><span class="line">fmt.Println(a2)</span><br><span class="line">fmt.Println(a3)</span><br><span class="line">fmt.Println(a4)</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">824634199592</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">824634199592</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中输出为 [0 0 0] 的 s1 和 s4 变量就是「 nil 切片」，s2 和 s3 变量就是「空切片」。824634199592 这个值是一个特殊的内存地址，所有类型的「空切片」都共享这一个内存地址。</p><p>用图形来表示「空切片」和「 nil 切片」如下</p><p><img src="https://s2.loli.net/2023/02/20/k7rE2iY4cyqPHhN.png"></p><p>空切片指向的 zerobase 内存地址是一个神奇的地址，从 Go 语言的源代码中可以看到它的定义</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//// runtime/malloc.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// base address for all 0-byte allocations</span></span><br><span class="line"><span class="keyword">var</span> zerobase <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配对象内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// runtime/slice.go</span></span><br><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">  ...</span><br><span class="line">     p := mallocgc(et.size*<span class="type">uintptr</span>(<span class="built_in">cap</span>), et, <span class="literal">true</span>)</span><br><span class="line"> <span class="keyword">return</span> slice&#123;p, <span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个问题是：「 nil 切片」和 「空切片」在使用上有什么区别么？</p><p>答案是完全没有任何区别！No！不对，还有一个小小的区别！请看下面的代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s1 == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(s2 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, s1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">[]<span class="type">int</span>(<span class="literal">nil</span>)</span><br><span class="line">[]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>「空切片」和「 nil 切片」有时候会隐藏在结构体中，这时候它们的区别就被太多的人忽略了，下面我们看个例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Something <span class="keyword">struct</span> &#123;</span><br><span class="line">values []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Something&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s2 = Something&#123;[]<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">fmt.Println(s1.values == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(s2.values == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以发现这两种创建结构体的结果是不一样的！</p><p>「空切片」和「 nil 切片」还有一个极为不同的地方在于 JSON 序列化</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Something <span class="keyword">struct</span> &#123;</span><br><span class="line">Values []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Something&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s2 = Something&#123;[]<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">bs1, _ := json.Marshal(s1)</span><br><span class="line">bs2, _ := json.Marshal(s2)</span><br><span class="line">fmt.Println(<span class="type">string</span>(bs1))</span><br><span class="line">fmt.Println(<span class="type">string</span>(bs2))</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">&#123;<span class="string">&quot;Values&quot;</span>:null&#125;</span><br><span class="line">&#123;<span class="string">&quot;Values&quot;</span>:[]&#125;</span><br></pre></td></tr></table></figure><p>Ban! Ban! Ban! 它们的 json 序列化结果居然也不一样！</p><h2 id="数组与切片有什么区别"><a href="#数组与切片有什么区别" class="headerlink" title="数组与切片有什么区别"></a>数组与切片有什么区别</h2><p><code>slice</code> 的底层数据是数组，<code>slice</code> 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型</p><p>而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。</p><p>数组就是一片连续的内存， <code>slice</code> 实际上是一个结构体，包含三个字段：<strong>长度</strong>、<strong>容量</strong>、<strong>底层数组</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>slice</code> 的数据结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs202302151639786.png"></p><p>注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><p>【引申1】 [3]int 和 [4]int 是同一个类型吗？</p><p>不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。</p><p>【引申2】 下面的代码输出是什么？</p><p>说明：例子来自雨痕大佬《Go学习笔记》第四版，P43页。这里我会进行扩展，并会作图详细分析。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">s1 := slice[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">s2 := s1[<span class="number">2</span>:<span class="number">6</span>:<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">s1[<span class="number">2</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/qiYbH43hu1-">Go Playground 运行上面代码</a></p><p>结果：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">20</span>]</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">100</span> <span class="number">200</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">20</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">100</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>s1 从 slice 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 s2 从 s1 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。</p><p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs202302151645001.png"></p><p>接着，向 <code>s2</code> 尾部追加一个元素 100：</p><p><code>s2 = append(s2, 100)</code></p><p><code>s2</code> 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 <code>s1</code> 都可以看得到。</p><p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs202302151645001.png"></p><p>再次向 <code>s2</code> 追加元素200：</p><p><code>s2 = append(s2, 100)</code></p><p>这时，<code>s2</code> 的容量不够用，该扩容了。于是，<code>s2</code> 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 <code>append</code> 带来的再一次扩容，<code>s2</code> 会在此次扩容的时候多留一些 buffer，将新的容量将扩大为原始容量的2倍，也就是10了。</p><p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs202302151652982.png"></p><p>最后，修改 <code>s1</code> 索引为2位置的元素：</p><p><code>s1[2] = 20</code></p><p>这次只会影响原始数组相应位置的元素。它影响不到 <code>s2</code> 了，人家已经远走高飞了。</p><p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs202302151652982.png"></p><p>再提一点，打印 <code>s1</code> 的时候，只会打印出 <code>s1</code> 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。</p><h2 id="切片作为函数参数"><a href="#切片作为函数参数" class="headerlink" title="切片作为函数参数"></a>切片作为函数参数</h2><p>slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址</p><p>当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。</p><p>值得注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，尽管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。</p><p>通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 s[i]&#x3D;10 这种操作改变 slice 底层数组元素值。</p><p>另外，值得注意的是，Go 语言的函数参数传递，只有值传递，没有引用传递。</p><p>来看一个代码片段：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">f(s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// i只是一个副本，不能改变s中元素的值</span></span><br><span class="line"><span class="comment">/*for _, i := range s &#123;</span></span><br><span class="line"><span class="comment">i++</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">s[i] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/6suD2P5RSPJ">Go Playground 运行上面代码</a></p><p>运行一下，程序输出：</p><p><code>[2 2 2]</code></p><p>果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 f 函数中，s 只是 main 函数中 s 的一个拷贝。在f 函数内部，对 s 的作用并不会改变外层 main 函数的 s。</p><p>要想真的改变外层 slice，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 这里 s 虽然改变了，但并不会影响外层函数的 s</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppendPtr</span><span class="params">(s *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 会改变外层 s 本身</span></span><br><span class="line">*s = <span class="built_in">append</span>(*s, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">newS := myAppend(s)</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(newS)</span><br><span class="line"></span><br><span class="line">s = newS</span><br><span class="line"></span><br><span class="line">myAppendPtr(&amp;s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/quuhfFdEb08">Go Playground 运行上面代码</a></p><p>运行一下，程序输出：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">100</span> <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>myAppend 函数里，虽然改变了 s，但它只是一个值传递，并不会影响外层的 s，因此第一行打印出来的结果仍然是 [1 1 1]。</p><p>而 newS 是一个新的 slice，它是基于 s 得到的。因此它打印的是追加了一个 100 之后的结果： [1 1 1 100]。</p><p>最后，将 newS 赋值给了 s，s 这时才真正变成了一个新的slice。之后，再给 myAppendPtr 函数传入一个 s 指针，这回它真的被改变了：[1 1 1 100 100]。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903712654098446">深度解析 Go 语言中「切片」的三种特殊状态</a><br><a href="https://golang.design/go-questions/slice/vs-array/">Go 程序员面试笔试宝典-数组与切片</a><br><a href="https://golang.design/go-questions/slice/as-func-param/">Go 程序员面试笔试宝典-切片作为函数参数</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/02/15/Golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-代码断行规则</title>
      <link>https://ch3nnn.github.io/2023/02/02/Golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</link>
      <guid>https://ch3nnn.github.io/2023/02/02/Golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</guid>
      <pubDate>Thu, 02 Feb 2023 08:37:59 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。&lt;/p&gt;
&lt;h2 id=&quot;分号插入规则&quot;&gt;&lt;a href=&quot;#分号插入规则&quot; class=&quot;headerli</description>
        
      
      
      
      <content:encoded><![CDATA[<p>如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。</p><h2 id="分号插入规则"><a href="#分号插入规则" class="headerlink" title="分号插入规则"></a>分号插入规则</h2><p>我们在Go编程中常遵循的一个规则是：一个显式代码块的起始左大括号{不放在下一行。 比如，下面这个for循环代码块编译将失败。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i--</span><br><span class="line">&#123; <span class="comment">// error: 未预料到的新行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让上面这个for循环代码块编译成功，我们不能在起始左大括号{前断行，而应该像下面这样进行修改：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，有时候起始左大括号{却可以放在一个新行上，比如下面这个for循环代编译时没有问题的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，Go代码中的根本性换行规则究竟是如何定义的呢？ 在回答这个问题之前，我们应该知道一个事实：正式的Go语法是使用（英文）分号;做为结尾标识符的。 但是，我们很少在Go代码中使用和看到分号。为什么呢？原因是大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。</p><p>比如，下面这个程序中的十个分号都是可以被省略掉的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">i   <span class="type">int</span>;</span><br><span class="line">sum <span class="type">int</span>;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">6</span> &#123;</span><br><span class="line">sum += i;</span><br><span class="line">i++;</span><br><span class="line">&#125;;</span><br><span class="line">fmt.Println(sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设上面这个程序存储在一个semicolons.go文件中，我们可以运行go fmt semicolons.go将此程序中的不必要的分号去除掉。 在编译时刻，编译器会自动此插入这些去除掉的分号（至此文件的内存中的版本）。</p><p>自动插入分号的规则是什么呢？Go白皮书这样描述：</p><ul><li>在Go代码中，注释除外，如果一个代码行的最后一个语法词段（token）为下列所示之一，则一个分号将自动插入在此字段后（即行尾）：<ul><li>一个标识符；</li><li>一个整数、浮点数、虚部、码点或者字符串字面量；</li><li>这几个跳转关键字之一：<code>break</code>、<code>continue</code>、<code>fallthrough</code>和<code>return</code>； </li><li>自增运算符++或者自减运算符–；</li><li>一个右括号：<code>)</code>、<code>]</code>或<code>&#125;</code>。</li></ul></li><li>为了允许一条复杂语句完全显示在一个代码行中，分号可能被插入在一个右小括号)或者右大括号}之前。<br> 对于上述第一条规则描述的情形，我们当然也可以手动插入这些分号，就像此前的例子中所示。换句话说，这些分号在编程时是可选的。</li></ul><p>上述第二条规则允许我们写出如下的代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (_ <span class="string">&quot;math&quot;</span>; <span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> (a <span class="type">int</span>; b <span class="type">string</span>)</span><br><span class="line"><span class="keyword">const</span> (M = <span class="literal">iota</span>; N)</span><br><span class="line"><span class="keyword">type</span> (MyInt <span class="type">int</span>; T <span class="keyword">struct</span>&#123;x <span class="type">bool</span>; y <span class="type">int32</span>&#125;)</span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span>&#123;m1(<span class="type">int</span>) <span class="type">int</span>; m2() <span class="type">string</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>); <span class="built_in">panic</span>(<span class="literal">nil</span>)&#125;</span><br></pre></td></tr></table></figure><p>编译器在编译时刻将自动插入所需的分号，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (a <span class="type">int</span>; b <span class="type">string</span>;);</span><br><span class="line"><span class="keyword">const</span> (M = <span class="literal">iota</span>; N;);</span><br><span class="line"><span class="keyword">type</span> (MyInt <span class="type">int</span>; T <span class="keyword">struct</span>&#123;x <span class="type">bool</span>; y <span class="type">int32</span>;&#125;;);</span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span>&#123;m1(<span class="type">int</span>) <span class="type">int</span>; m2() <span class="type">string</span>;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>); <span class="built_in">panic</span>(<span class="literal">nil</span>);&#125;;</span><br></pre></td></tr></table></figure><p>编译器不会为其它任何情形插入分号。如果其它任何情形需要一个分号，我们必须手动插入此分号。 比如，上例中的每行中的第一个分号必须手动插入。下例中的分号也都需要手动插入。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line">a++; b = !b</span><br><span class="line"><span class="built_in">print</span>(a); <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>从以上两条规则可以看出，一个分号永远不会插入在<code>for</code>关键字后，这就是为什么上面的裸<code>for</code>循环例子是合法的。</p><p>分号自动插入规则导致的一个结果是：自增和自减运算必须呈现为单独的语句，它们不能被当作表达式使用。 比如，下面的代码是编译不通过的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="built_in">println</span>(a++)</span><br><span class="line"><span class="built_in">println</span>(a--)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码编译不通过的原因是它等价于下面的代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="built_in">println</span>(a++;)</span><br><span class="line"><span class="built_in">println</span>(a--;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分号自动插入规则导致的另一个结果是：我们不能在选择器中的句点.之前断行。 在选择器中的句点之后断行是允许的，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anObject.</span><br><span class="line">    MethodA().</span><br><span class="line">    MethodB().</span><br><span class="line">    MethodC()</span><br></pre></td></tr></table></figure><p>而下面这样是非法的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anObject</span><br><span class="line">    .MethodA()</span><br><span class="line">    .MethodB()</span><br><span class="line">    .MethodC()</span><br></pre></td></tr></table></figure><p>此代码片段是非法的原因是编译器将自动在每个右小括号)后插入一个分号，如下面所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">anObject;</span><br><span class="line">    .MethodA();</span><br><span class="line">    .MethodB();</span><br><span class="line">    .MethodC();</span><br></pre></td></tr></table></figure><p>上述分号自动插入规则可以让我们写出更简洁的代码，同时也允许我们写出一些合法的但看上去有些怪异的代码，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span></span> <span class="type">bool</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">i &lt; <span class="number">6</span></span><br><span class="line">i++ &#123;</span><br><span class="line"><span class="comment">// 使用i ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x := alwaysFalse()</span><br><span class="line">!x &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> alwaysFalse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中所有的流程控制代码块都是合法的。编译器将在这些行的行尾自动插入一个分号：第9行、第10行、第15行和第20行。</p><p>注意，上例中的<code>switch-case</code>代码块将输出<code>true</code>，而不是<code>false</code>。 此代码块和下面这个是不同的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> alwaysFalse() &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用<code>go fmt</code>命令格式化前者，一个分号将自动添加到<code>alwaysFalse()</code>函数调用之后，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> alwaysFalse();</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入此分号后，此代码块将和下者等价：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> alwaysFalse(); <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>: fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>: fmt.Println(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是它输出true的原因。</p><p>常使用go fmt和go vet命令来格式化和发现可能的逻辑错误是一个好习惯。</p><p>下面是一个很少见的情形，此情形中所示的代码看上去是合法的，但是实际上是编译不通过的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> A</span><br><span class="line">A: <span class="comment">// 这里编译没问题</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">goto</span> B</span><br><span class="line">B: <span class="comment">// syntax error: 跳转标签后缺少语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> C</span><br><span class="line">C: <span class="comment">// 这里编译没问题</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误信息表明跳转标签的声明之后必须跟一条语句。 但是，看上去，上例中的三个标签声明没什么不同，它们都没有跟随一条语句。 那为什么只有B:标签声明是不合法的呢？ 原因是，根据上述第二条分号自动插入规则，编译器将在A:和C:标签声明之后的右大括号}字符之前插入一个分号，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> A</span><br><span class="line">A:</span><br><span class="line">;&#125; <span class="comment">// 一个分号插入到了这里</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">goto</span> B</span><br><span class="line">B: <span class="comment">// syntax error: 跳转标签后缺少语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> C</span><br><span class="line">C:</span><br><span class="line">;&#125; <span class="comment">// 一个分号插入到了这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个单独的分号实际上表示一条空语句。 这就意味着A:和C:标签声明之后确实跟随了一条语句，所以它们是合法的。 而B:标签声明跟随的case 0:不是一条语句，所以它是不合法的。</p><p>我们可以在B:标签声明之后手动插入一个分号使之变得合法。</p><h2 id="逗号-从不会被自动插入"><a href="#逗号-从不会被自动插入" class="headerlink" title="逗号,从不会被自动插入"></a>逗号,从不会被自动插入</h2><p>一些包含多个类似项目的语法形式多用逗号,来做为这些项目之间的分割符，比如组合字面量和函数参数列表等。 在这样的一个语法形式中，最后一个项目后总可以跟一个可选的逗号。 如果此逗号为它所在代码行的最后一个有效字符，则此逗号是必需的；否则，此逗号可以省略。 编译器在任何情况下都不会自动插入逗号。</p><p>比如，下面的代码是合法的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a <span class="type">int</span>, b <span class="type">string</span>,)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span>,) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="number">789</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f2 <span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">string</span>)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> f3 <span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>, b <span class="type">string</span>, // 最后一个逗号是必需的</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span>,             <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>,&#125; <span class="comment">// 最后一个逗号是可选的</span></span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>,  <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span>,) <span class="comment">// 最后一个逗号是可选的</span></span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span>,  <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span>)</span><br><span class="line"><span class="comment">// 对于显式转换也是一样的：</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="type">string</span>(<span class="number">65</span>,) <span class="comment">// 最后一个逗号是可选的</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="type">string</span>(<span class="number">65</span>,  <span class="comment">// 最后一个逗号是必需的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而下面这段代码是不合法的，因为编译器将自动在每一行的行尾插入一个分号（除了第二行）。 其中三行在插入分号后将导致编译错误。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a <span class="type">int</span>, b <span class="type">string</span>,)</span></span> (x <span class="type">bool</span>, y <span class="type">int</span> <span class="comment">// error</span></span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="number">789</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> <span class="comment">// error: unexpected newline</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _, _ = f1(<span class="number">123</span>, <span class="string">&quot;Go&quot;</span> <span class="comment">// error: unexpected newline</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后，根据上面的解释，在这里描述一下Go代码中的断行规则。</p><p>在Go代码中，以下断行是没问题的（不影响程序行为的）：</p><ul><li>在除了<code>break</code>、<code>continue</code>和<code>return</code>这几个跳转关键字之外的任何关键字之后断行，或者在不跟随标签的<code>break</code>和<code>continue</code>关键字以及不跟随返回值的<code>return</code>关键字之后断行；</li><li>在（显式输入的或者隐式被编译器插入的）分号;之后断行；</li><li>在不会导致新的隐式分号被编译器插入的情况下断行。</li></ul><p>和很多Go中的其它设计细节一样，Go代码断行规则设计的评价也是褒贬不一。 有些程序员不太喜欢这样的断行规则，因为这样的规则限制了代码风格的自由度。 但是这些规则不但使得代码编译速度大大提高，另一方面也使得不同Go程序员写出的代码风格大体一致，从而相互可以比较轻松地读懂对方的代码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gfw.go101.org/article/line-break-rules.html">Go代码断行规则</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/02/02/Golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Facebook 开源 Golang 实体框架 Ent</title>
      <link>https://ch3nnn.github.io/2023/01/16/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</link>
      <guid>https://ch3nnn.github.io/2023/01/16/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Mon, 16 Jan 2023 09:29:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs16738590832901.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs16738590832901.jpg"></p><p>ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。</p><ul><li><strong>图就是代码</strong> - 将任何数据库表建模为Go对象。</li><li><strong>轻松地遍历任何图形</strong> - 可以轻松地运行查询、聚合和遍历任何图形结构。</li><li><strong>静态类型和显式API</strong> - 使用代码生成静态类型和显式API，查询数据更加便捷。</li><li><strong>多存储驱动程序</strong> - 支持MySQL, PostgreSQL, SQLite 和 Gremlin。</li><li><strong>可扩展</strong> - 简单地扩展和使用Go模板自定义。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">go install entgo.io/ent/cmd/ent@latest</span><br></pre></td></tr></table></figure><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod init &lt;project&gt;</span><br></pre></td></tr></table></figure><h3 id="创建你的第一个项目"><a href="#创建你的第一个项目" class="headerlink" title="创建你的第一个项目"></a>创建你的第一个项目</h3><p>进入你项目的根目录，然后运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run -mod=mod entgo.io/ent/cmd/ent init User</span><br></pre></td></tr></table></figure><p>以上的命令会在<code>&lt;project&gt;/ent/schema/</code>目录下产生<code>User</code>的数据模式（数据模式是数据库系统设计中的专业术语，若对该部分有任何理解问题，请查阅数据库系统的相关书籍）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> schema</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;entgo.io/ent&quot;</span></span><br><span class="line"><span class="comment">// User在User实体中组合了ent默认的数据库模式定义</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ent.Schema</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User的字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> Fields() []ent.Field &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User的边</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> Edges() []ent.Edge &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为<code>User</code> 模式添加两个字段：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> schema</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;entgo.io/ent&quot;</span></span><br><span class="line">    <span class="string">&quot;entgo.io/ent/schema/field&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// User的字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> Fields() []ent.Field &#123;</span><br><span class="line">    <span class="keyword">return</span> []ent.Field&#123;</span><br><span class="line">        field.Int(<span class="string">&quot;age&quot;</span>).</span><br><span class="line">            Positive(),</span><br><span class="line">        field.String(<span class="string">&quot;name&quot;</span>).</span><br><span class="line">            Default(<span class="string">&quot;unknown&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从项目的根目录下像如下命令那样，运行<code>go generate</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go generate ./ent</span><br></pre></td></tr></table></figure><p>上述命令，将产生如下的文件：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ent</span><br><span class="line">├── client.go</span><br><span class="line">├── config.go</span><br><span class="line">├── context.go</span><br><span class="line">├── ent.go</span><br><span class="line">├── generate.go</span><br><span class="line">├── mutation.go</span><br><span class="line">... truncated</span><br><span class="line">├── schema</span><br><span class="line">│   └── user.go</span><br><span class="line">├── tx.go</span><br><span class="line">├── user</span><br><span class="line">│   ├── user.go</span><br><span class="line">│   └── where.go</span><br><span class="line">├── user.go</span><br><span class="line">├── user_create.go</span><br><span class="line">├── user_delete.go</span><br><span class="line">├── user_query.go</span><br><span class="line">└── user_update.go</span><br></pre></td></tr></table></figure><h3 id="创建你的第一个实体"><a href="#创建你的第一个实体" class="headerlink" title="创建你的第一个实体"></a>创建你的第一个实体</h3><p>首先，创建一个<code>ent.Client</code>。</p><blockquote><p>Sqlite3</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;project&gt;/ent&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/mattn/go-sqlite3&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := ent.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;file:ent?mode=memory&amp;cache=shared&amp;_fk=1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed opening connection to sqlite: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line">    <span class="comment">// 运行自动迁移工具。</span></span><br><span class="line">    <span class="keyword">if</span> err := client.Schema.Create(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed creating schema resources: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Postgres</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;project&gt;/ent&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := ent.Open(<span class="string">&quot;postgres&quot;</span>,<span class="string">&quot;host=&lt;host&gt; port=&lt;port&gt; user=&lt;user&gt; dbname=&lt;database&gt; password=&lt;pass&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed opening connection to postgres: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line">    <span class="comment">// 运行自动迁移工具。</span></span><br><span class="line">    <span class="keyword">if</span> err := client.Schema.Create(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed creating schema resources: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Mysql</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;&lt;project&gt;/ent&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := ent.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;&lt;user&gt;:&lt;pass&gt;@tcp(&lt;host&gt;:&lt;port&gt;)/&lt;database&gt;?parseTime=True&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed opening connection to mysql: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line">    <span class="comment">// 运行自动迁移工具。</span></span><br><span class="line">    <span class="keyword">if</span> err := client.Schema.Create(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed creating schema resources: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单CURD"><a href="#简单CURD" class="headerlink" title="简单CURD"></a>简单CURD</h3><p>现在，我们准备创建我们的用户。 让我们写一个 <code>CreateUser</code> 函数，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateUser 新建用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line">u, err := client.User.Create().</span><br><span class="line">SetAge(<span class="number">18</span>).</span><br><span class="line">SetName(<span class="string">&quot;a8m&quot;</span>).</span><br><span class="line">SetPhone(<span class="string">&quot;12345678&quot;</span>).</span><br><span class="line">Save(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed creating user: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;user was created: &quot;</span>, u)</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ent</code> 为每个实体结构生成一个package，包含其条件、默认值、验证器、有关存储元素的附加信息 (字段名、主键等) 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QueryUser 查询用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// `Only` 如果没有发现用户则报错,</span></span><br><span class="line"><span class="comment">// 否则正常返回。</span></span><br><span class="line">u, err := client.User.Query().Where(user.Name(<span class="string">&quot;a8m&quot;</span>)).Only(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed querying user: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;user returned: &quot;</span>, u)</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line">u, _ := QueryUser(ctx, client)</span><br><span class="line"><span class="keyword">if</span> err := client.User.DeleteOne(u).Exec(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed delete user: %w&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新用户</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateUser</span><span class="params">(ctx context.Context, client *ent.Client)</span></span> (*ent.User, <span class="type">error</span>) &#123;</span><br><span class="line">u, _ := QueryUser(ctx, client)</span><br><span class="line">u, err := client.User.UpdateOne(u).SetAge(<span class="number">28</span>).Save(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed update user: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>完整示例请参阅 <a href="https://github.com/ch3nnn/go-study/tree/main/12-%E5%85%B6%E4%BB%96/ent">GitHub</a>.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ent.ryansu.pro/#/zh-cn/getting-started">Ent 中文文档</a></p><p><a href="https://github.com/ent/ent">Ent Github</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/01/16/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
