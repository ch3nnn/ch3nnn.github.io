<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ch3nnn个人博客</title>
    <link>https://ch3nnn.github.io/</link>
    
    <atom:link href="https://ch3nnn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>小站主要用来分享和记录学习经验,教程,记录个人生活的点滴以及一些随笔.</description>
    <pubDate>Fri, 11 Aug 2023 07:45:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Golang-语言源码级调试器 Delve</title>
      <link>https://ch3nnn.github.io/2023/08/11/Golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-Delve/</link>
      <guid>https://ch3nnn.github.io/2023/08/11/Golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-Delve/</guid>
      <pubDate>Fri, 11 Aug 2023 07:43:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Go 目前的调试器有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GDB&lt;/code&gt; 最早期的调试工具，现在用的很少。&lt;/li&gt;
&lt;l</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 目前的调试器有如下几种：</p><ul><li><code>GDB</code> 最早期的调试工具，现在用的很少。</li><li><code>LLDB</code> macOS 系统推荐的标准调试工具，单 Go 的一些专有特性支持的比较少。</li><li><code>Delve</code> 专门为 Go 语言打造的调试工具，使用最为广泛。</li></ul><p>本篇简单说明如何使用 <code>Delve</code> 工具来调试 Go 程序，使用的 <code>delve</code> 版本为 1.20.1。</p><p>delve 的汉语意思是：钻研、探索；用这个来命名一个debug工具还是非常的形象。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>已知以下说明适用于 Linux、macOS、Windows 和 FreeBSD。</p><p>克隆 git 存储库并构建：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/go-delve/delve</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> delve</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go install github.com/go-delve/delve/cmd/dlv</span></span><br></pre></td></tr></table></figure><p>或者，在 Go 版本 1.16 或更高版本上：</p><p><strong>Install the latest release:</strong><br><code>$ go install github.com/go-delve/delve/cmd/dlv@latest</code></p><p><strong>Install at tree head:</strong><br><code>$ go install github.com/go-delve/delve/cmd/dlv@master</code></p><p><strong>安装在一个特定的版本或:</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go install github.com/go-delve/delve/cmd/dlv@v1.7.3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe</span></span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  dlv [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  attach      附加到正在运行的进程并开始调试.</span><br><span class="line">  connect     使用终端客户端连接到无头调试服务器.</span><br><span class="line">  core        检查核心转储.</span><br><span class="line">  dap         启动一个通过调试适配器协议(DAP)通信的无头TCP服务器.</span><br><span class="line">  debug       编译并开始调试当前目录中的主包或指定的包.</span><br><span class="line">  exec        执行预编译的二进制文件，并开始调试会话.</span><br><span class="line">  help        Help about any command</span><br><span class="line">  run         弃用的命令。使用&#x27;debug&#x27;代替.</span><br><span class="line">  test        编译测试二进制文件并开始调试程序.</span><br><span class="line">  trace       编译并开始跟踪程序.</span><br><span class="line">  version     Prints version.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作-示例代码"><a href="#操作-示例代码" class="headerlink" title="[操作] 示例代码"></a>[操作] 示例代码</h2><p>下面是检查操作的代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.test/</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── main_test.go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module debug_sample</span><br><span class="line"></span><br><span class="line">go 1.18</span><br></pre></td></tr></table></figure><p><code>main.go</code> 执行以下处理：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> abc <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">abc = <span class="string">&quot;wakuwaku bank&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;func add %v\n&quot;</span>, abc)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;func sub %v\n&quot;</span>, abc)</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>)</span></span> (addValue, subValue <span class="type">int</span>) &#123;</span><br><span class="line">addValue = add(a, b)</span><br><span class="line">subValue = sub(a, b)</span><br><span class="line"><span class="keyword">return</span> addValue, subValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sampleFunc1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a := i + <span class="number">10</span></span><br><span class="line">b := i</span><br><span class="line">addValue, subValue := calculate(a, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;addValue: %v subValue: %v\n&quot;</span>, addValue, subValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sampleFunc1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main_test.go 执行以下处理：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_add</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">b <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">args args</span><br><span class="line">want <span class="type">int</span></span><br><span class="line">&#125;&#123;&#123;name: <span class="string">&quot;Both positive values&quot;</span>, args: args&#123;<span class="number">10</span>, <span class="number">3</span>&#125;, want: <span class="number">13</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> got := add(tt.args.a, tt.args.b); got != tt.want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;add() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_sub</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">b <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">args args</span><br><span class="line">want <span class="type">int</span></span><br><span class="line">&#125;&#123;&#123;name: <span class="string">&quot;Both positive values&quot;</span>, args: args&#123;<span class="number">10</span>, <span class="number">3</span>&#125;, want: <span class="number">7</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> got := sub(tt.args.a, tt.args.b); got != tt.want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;sub() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试-dlv-调试"><a href="#调试-dlv-调试" class="headerlink" title="[调试] dlv 调试"></a>[调试] dlv 调试</h2><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dlv debug main.go</span></span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) </span><br></pre></td></tr></table></figure><h3 id="检查功能-x2F-代码-funcs-list"><a href="#检查功能-x2F-代码-funcs-list" class="headerlink" title="检查功能&#x2F;代码( funcs list )"></a>检查功能&#x2F;代码( funcs list )</h3><p><code>funcs main\..*</code> 查看 main 文件 所有定义的方法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) funcs main\..*</span><br><span class="line">main.add</span><br><span class="line">main.calculate</span><br><span class="line">main.init.0</span><br><span class="line">main.main</span><br><span class="line">main.sampleFunc1</span><br><span class="line">main.sub</span><br><span class="line">runtime.main.func1</span><br><span class="line">runtime.main.func2</span><br></pre></td></tr></table></figure><p><code>list</code> 您可以在以下位置查看某个方法源代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) list main.main</span><br><span class="line">Showing /debug_sample/main.go:38 (PC: 0x1029dda10)</span><br><span class="line">    33:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    34:                 fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:         &#125;</span><br><span class="line">    36: &#125;</span><br><span class="line">    37: </span><br><span class="line">    38: func main() &#123;</span><br><span class="line">    39:         sampleFunc1()</span><br><span class="line">    40: &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) list main.sampleFunc1:3</span><br><span class="line">Showing /debug_sample/main.go:32 (PC: 0x1029dd8c0)</span><br><span class="line">    27: &#125;</span><br><span class="line">    28: </span><br><span class="line">    29: func sampleFunc1() &#123;</span><br><span class="line">    30:         for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    31:                 a := i + 10</span><br><span class="line">    32:                 b := i</span><br><span class="line">    33:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    34:                 fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:         &#125;</span><br><span class="line">    36: &#125;</span><br><span class="line">    37: </span><br></pre></td></tr></table></figure><h3 id="设置-x2F-删除断点-break-clear"><a href="#设置-x2F-删除断点-break-clear" class="headerlink" title="设置&#x2F;删除断点 (  break clear )"></a>设置&#x2F;删除断点 (  break clear )</h3><p><code>break</code> 您可以使用以下命令设置断点</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) break main.main</span><br><span class="line">Breakpoint 1 set at 0x1029dda10 for main.main() ./main.go:38</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) break main.sampleFunc1:3</span><br><span class="line">Breakpoint 2 set at 0x1029dd8c0 for main.sampleFunc1() ./main.go:32</span><br></pre></td></tr></table></figure><p><code>breakpoints</code> 您可以检查中设置的断点。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) breakpoints</span><br><span class="line">Breakpoint runtime-fatal-throw (enabled) at 0x10296c880 for runtime.throw() /Users/w/.gvm/gos/go1.18/src/runtime/panic.go:982 (0)</span><br><span class="line">Breakpoint unrecovered-panic (enabled) at 0x10296cb90 for runtime.fatalpanic() /Users/w/.gvm/gos/go1.18/src/runtime/panic.go:1065 (0)</span><br><span class="line">        print runtime.curg._panic.arg</span><br><span class="line">Breakpoint 1 (enabled) at 0x1029dda10 for main.main() ./main.go:38 (0)</span><br><span class="line">Breakpoint 2 (enabled) at 0x1029dd8c0 for main.sampleFunc1() ./main.go:32 (0)</span><br></pre></td></tr></table></figure><p><code>clear</code> 您可以使用 删除指定的断点。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) clear 1</span><br><span class="line">Breakpoint 1 cleared at 0x1029dda10 for main.main() ./main.go:38</span><br><span class="line">(dlv) breakpoints</span><br><span class="line">Breakpoint runtime-fatal-throw (enabled) at 0x10296c880 for runtime.throw() /Users/w/.gvm/gos/go1.18/src/runtime/panic.go:982 (0)</span><br><span class="line">Breakpoint unrecovered-panic (enabled) at 0x10296cb90 for runtime.fatalpanic() /Users/w/.gvm/gos/go1.18/src/runtime/panic.go:1065 (0)</span><br><span class="line">        print runtime.curg._panic.arg</span><br><span class="line">Breakpoint 2 (enabled) at 0x1029dd8c0 for main.sampleFunc1() ./main.go:32 (0)</span><br></pre></td></tr></table></figure><p><code>clearall</code> 删除所有断点。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) clearall</span><br><span class="line">Breakpoint 1 cleared at 0x4986e6 for main.main() ./main.go:38</span><br><span class="line">Breakpoint 5 cleared at 0x49858c for main.sampleFunc1() ./main.go:32</span><br></pre></td></tr></table></figure><h3 id="提前处理到断点-continue"><a href="#提前处理到断点-continue" class="headerlink" title="提前处理到断点(  continue )"></a>提前处理到断点(  continue )</h3><p><code>continue</code> 让我们继续执行中设置的断点。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) continue</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.sampleFunc1() ./main.go:32 (hits goroutine(1):1 total:1) (PC: 0x1029dd8c0)</span></span><br><span class="line">    27: &#125;</span><br><span class="line">    28: </span><br><span class="line">    29: func sampleFunc1() &#123;</span><br><span class="line">    30:         for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    31:                 a := i + 10</span><br><span class="line">=&gt;  32:                 b := i</span><br><span class="line">    33:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    34:                 fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:         &#125;</span><br><span class="line">    36: &#125;</span><br><span class="line">    37: </span><br></pre></td></tr></table></figure><p><code>continue</code> 或者，您可以继续执行以下命令。</p><p><code>next</code><br>向前迈出一行（跨过）。<br><code>step</code><br>前进一行。<br><code>stepout</code><br>退出当前功能。</p><h3 id="检查并覆盖变量-locals-set"><a href="#检查并覆盖变量-locals-set" class="headerlink" title="检查并覆盖变量 (  locals set )"></a>检查并覆盖变量 (  locals set )</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@cdh2 test]# dlv debug main.go  // 调试</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line"></span><br><span class="line">(dlv) break main.sampleFunc1:3  // 设置断点</span><br><span class="line">Breakpoint 1 set at 0x49858c for main.sampleFunc1() ./main.go:32</span><br><span class="line"></span><br><span class="line">(dlv) c  // 跳到断点</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.sampleFunc1() ./main.go:32 (hits goroutine(1):1 total:1) (PC: 0x49858c)</span></span><br><span class="line">    27:&#125;</span><br><span class="line">    28:</span><br><span class="line">    29:func sampleFunc1() &#123;</span><br><span class="line">    30:for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    31:a := i + 10</span><br><span class="line">=&gt;  32:b := i</span><br><span class="line">    33:addValue, subValue := calculate(a, b)</span><br><span class="line">    34:fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:&#125;</span><br><span class="line">    36:&#125;</span><br><span class="line">    37:</span><br><span class="line">    </span><br><span class="line">(dlv) locals  // 打印局部变量</span><br><span class="line">i = 0</span><br><span class="line">a = 10</span><br><span class="line"></span><br><span class="line">(dlv) vars main.abc</span><br><span class="line">main.abc = &quot;wakuwaku bank&quot;</span><br><span class="line"></span><br><span class="line">(dlv) print i</span><br><span class="line">0</span><br><span class="line">(dlv) print a</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">(dlv) set i = 2  // 重新给变量赋值</span><br><span class="line">(dlv) print i</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="堆栈跟踪显示-stack-frame"><a href="#堆栈跟踪显示-stack-frame" class="headerlink" title="堆栈跟踪显示(  stack frame )"></a>堆栈跟踪显示(  stack frame )</h3><p>首先，要检查操作，请继续添加功能。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) break main.add</span><br><span class="line">Breakpoint 3 set at 0x1029dd610 for main.add() ./main.go:13</span><br><span class="line">(dlv) c</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.add() ./main.go:13 (hits goroutine(1):1 total:1) (PC: 0x1029dd610)</span></span><br><span class="line">     8: </span><br><span class="line">     9: func init() &#123;</span><br><span class="line">    10:         abc = &quot;wakuwaku bank&quot;</span><br><span class="line">    11: &#125;</span><br><span class="line">    12: </span><br><span class="line">=&gt;  13: func add(a, b int) int &#123;</span><br><span class="line">    14:         fmt.Printf(&quot;func add %v\n&quot;, abc)</span><br><span class="line">    15:         return a + b</span><br><span class="line">    16: &#125;</span><br><span class="line">    17: </span><br><span class="line">    18: func sub(a, b int) int &#123;</span><br></pre></td></tr></table></figure><p>显示堆栈跟踪</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) stack</span><br><span class="line">0  0x00000000004982aa in main.add</span><br><span class="line">   at ./main.go:13</span><br><span class="line">1  0x00000000004984df in main.calculate</span><br><span class="line">   at ./main.go:24</span><br><span class="line">2  0x00000000004985a5 in main.sampleFunc1</span><br><span class="line">   at ./main.go:33</span><br><span class="line">3  0x00000000004986f7 in main.main</span><br><span class="line">   at ./main.go:39</span><br><span class="line">4  0x00000000004372d8 in runtime.main</span><br><span class="line">   at /root/.go/src/runtime/proc.go:250</span><br><span class="line">5  0x0000000000461661 in runtime.goexit</span><br><span class="line">   at /root/.go/src/runtime/asm_amd64.s:1571</span><br></pre></td></tr></table></figure><p><code>frame</code> 您可以通过指定堆栈跟踪编号来检查代码和变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) frame 2 ls</span><br><span class="line">Goroutine 1 frame 2 at /debug_sample/main.go:33 (PC: 0x1029dd8d0)</span><br><span class="line">    28: </span><br><span class="line">    29: func sampleFunc1() &#123;</span><br><span class="line">    30:         for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    31:                 a := i + 10</span><br><span class="line">    32:                 b := i</span><br><span class="line">=&gt;  33:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    34:                 fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:         &#125;</span><br><span class="line">    36: &#125;</span><br><span class="line">    37: </span><br><span class="line">    38: func main() &#123;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) frame 2 locals</span><br><span class="line">i = 2</span><br><span class="line">a = 10</span><br><span class="line">b = 2</span><br></pre></td></tr></table></figure><h3 id="指定条件-condition"><a href="#指定条件-condition" class="headerlink" title="指定条件 (  condition )"></a>指定条件 (  condition )</h3><p>首先，进行for语句的处理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dlv debug main.go</span></span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b main.sampleFunc1:3</span><br><span class="line">Breakpoint 1 set at 0x1050958c0 for main.sampleFunc1() ./main.go:32</span><br><span class="line">(dlv) c</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.sampleFunc1() ./main.go:32 (hits goroutine(1):1 total:1) (PC: 0x1050958c0)</span></span><br><span class="line">    27: &#125;</span><br><span class="line">    28: </span><br><span class="line">    29: func sampleFunc1() &#123;</span><br><span class="line">    30:         for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    31:                 a := i + 10</span><br><span class="line">=&gt;  32:                 b := i</span><br><span class="line">    33:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    34:                 fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:         &#125;</span><br><span class="line">    36: &#125;</span><br><span class="line">    37: </span><br><span class="line">(dlv) locals</span><br><span class="line">i = 0</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure><p><code>condition</code> 您可以使用 设置断点条件。<br><code>i==5</code> 让我们将其设置为停止时</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) condition 1 i==5</span><br><span class="line"></span><br><span class="line">(dlv) c</span><br><span class="line">func add wakuwaku bank</span><br><span class="line">func sub wakuwaku bank</span><br><span class="line">addValue: 10 subValue: 10</span><br><span class="line">func add wakuwaku bank</span><br><span class="line">func sub wakuwaku bank</span><br><span class="line">addValue: 12 subValue: 10</span><br><span class="line">func add wakuwaku bank</span><br><span class="line">func sub wakuwaku bank</span><br><span class="line">addValue: 14 subValue: 10</span><br><span class="line">func add wakuwaku bank</span><br><span class="line">func sub wakuwaku bank</span><br><span class="line">addValue: 16 subValue: 10</span><br><span class="line">func add wakuwaku bank</span><br><span class="line">func sub wakuwaku bank</span><br><span class="line">addValue: 18 subValue: 10</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.sampleFunc1() ./main.go:32 (hits goroutine(1):2 total:2) (PC: 0x1050958c0)</span></span><br><span class="line">    27: &#125;</span><br><span class="line">    28: </span><br><span class="line">    29: func sampleFunc1() &#123;</span><br><span class="line">    30:         for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    31:                 a := i + 10</span><br><span class="line">=&gt;  32:                 b := i</span><br><span class="line">    33:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    34:                 fmt.Printf(&quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br><span class="line">    35:         &#125;</span><br><span class="line">    36: &#125;</span><br><span class="line">    37: </span><br><span class="line">    </span><br><span class="line">(dlv) locals</span><br><span class="line">i = 5</span><br><span class="line">a = 15</span><br></pre></td></tr></table></figure><h3 id="调试结束-exit"><a href="#调试结束-exit" class="headerlink" title="调试结束(  exit )"></a>调试结束(  exit )</h3><p>exit 您可以使用 完成调试。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) exit</span><br></pre></td></tr></table></figure><h2 id="debug-dlv测试（调试测试）"><a href="#debug-dlv测试（调试测试）" class="headerlink" title="[debug] dlv测试（调试测试）"></a>[debug] dlv测试（调试测试）</h2><p>dlv test 您可以使用以下命令调试您的测试代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dlv <span class="built_in">test</span></span></span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) funcs test.Test*  // test.Test*  test 包含 Xxx_test.go 文件夹</span><br><span class="line">debug_sample.Test_add</span><br><span class="line">debug_sample.Test_add.func1</span><br><span class="line">debug_sample.Test_sub</span><br><span class="line">debug_sample.Test_sub.func1</span><br><span class="line"></span><br><span class="line">(dlv) b test.Test_add</span><br><span class="line">Breakpoint 1 set at 0x104891e90 for debug_sample.Test_add() ./main_test.go:5</span><br><span class="line"></span><br><span class="line">(dlv) c</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">debug_sample.Test_add() ./main_test.go:5 (hits goroutine(4):1 total:1) (PC: 0x104891e90)</span></span><br><span class="line">     1: package main</span><br><span class="line">     2: </span><br><span class="line">     3: import &quot;testing&quot;</span><br><span class="line">     4: </span><br><span class="line">=&gt;   5: func Test_add(t *testing.T) &#123;</span><br><span class="line">     6:         type args struct &#123;</span><br><span class="line">     7:                 a int</span><br><span class="line">     8:                 b int</span><br><span class="line">     9:         &#125;</span><br><span class="line">    10:         tests := []struct &#123; </span><br></pre></td></tr></table></figure><h2 id="debug-dlv-Attach（调试运行进程）"><a href="#debug-dlv-Attach（调试运行进程）" class="headerlink" title="[debug] dlv Attach（调试运行进程）"></a>[debug] dlv Attach（调试运行进程）</h2><p>更正操作检查代码</p><p>对其进行修改以保持作为 Web 服务器运行，如下所示。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> abc <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">abc = <span class="string">&quot;wakuwaku bank&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;func add %v\n&quot;</span>, abc)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;func sub %v\n&quot;</span>, abc)</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>)</span></span> (addValue, subValue <span class="type">int</span>) &#123;</span><br><span class="line">addValue = add(a, b)</span><br><span class="line">subValue = sub(a, b)</span><br><span class="line"><span class="keyword">return</span> addValue, subValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sampleFunc1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a := i * <span class="number">2</span></span><br><span class="line">b := i</span><br><span class="line">addValue, subValue := calculate(a, b)</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;addValue: %v subValue: %v\n&quot;</span>, addValue, subValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/sample_func_1&quot;</span>, sampleFunc1)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go build</span>     </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./test</span></span><br></pre></td></tr></table></figure><h3 id="调试运行进程"><a href="#调试运行进程" class="headerlink" title="调试运行进程"></a>调试运行进程</h3><p>检查进程 ID。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep <span class="string">&quot;test&quot;</span></span></span><br><span class="line">root     254882  56889  0 15:24 pts/2    00:00:00 ./test</span><br><span class="line">root     257090  18100  0 15:25 pts/0    00:00:00 grep --color=auto test</span><br></pre></td></tr></table></figure><p>调试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dlv attach 254882</span></span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv)</span><br></pre></td></tr></table></figure><p>设置断点并等待进程被调用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) b main.sampleFunc1</span><br><span class="line">Breakpoint 1 set at 0x1010e8470 for main.sampleFunc1() ./main.go:30</span><br><span class="line"></span><br><span class="line">(dlv) c</span><br></pre></td></tr></table></figure><p>尝试在另一个控制台中向端点发出请求。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://localhost/sample_func_1</span></span><br></pre></td></tr></table></figure><p>处理在设置的断点处停止，如下所示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) c</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">main.sampleFunc1() ./main.go:30 (hits goroutine(21):1 total:1) (PC: 0x1010e8470)</span></span><br><span class="line">Warning: debugging optimized function</span><br><span class="line">    25:         addValue = add(a, b)</span><br><span class="line">    26:         subValue = sub(a, b)</span><br><span class="line">    27:         return addValue, subValue</span><br><span class="line">    28: &#125;</span><br><span class="line">    29: </span><br><span class="line">=&gt;  30: func sampleFunc1(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    31:         for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    32:                 a := i * 2</span><br><span class="line">    33:                 b := i</span><br><span class="line">    34:                 addValue, subValue := calculate(a, b)</span><br><span class="line">    35:                 fmt.Fprintf(w, &quot;addValue: %v subValue: %v\n&quot;, addValue, subValue)</span><br></pre></td></tr></table></figure><h2 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h2><p>以下是一些最常用的命令。</p><h3 id="断点相关"><a href="#断点相关" class="headerlink" title="断点相关"></a>断点相关</h3><table><thead><tr><th align="left">命令</th><th>别名</th><th>解释</th></tr></thead><tbody><tr><td align="left">break</td><td>b</td><td>设置断点</td></tr><tr><td align="left">breakpoints</td><td>bp</td><td>显示活动断点</td></tr><tr><td align="left">clear</td><td></td><td>删除断点</td></tr><tr><td align="left">clearall</td><td></td><td>删除所有断点</td></tr><tr><td align="left">condition</td><td>cond</td><td>设置断点条件</td></tr></tbody></table><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><table><thead><tr><th align="left">命令</th><th>别名</th><th>解释</th></tr></thead><tbody><tr><td align="left">continue</td><td>c</td><td>继续到“下一个断点”或“程序结束”或“指定点”。（例如 c main.add:1 ）</td></tr><tr><td align="left">next</td><td>n</td><td>向前迈出一行（跨过）。</td></tr><tr><td align="left">step</td><td>s</td><td>前进一行。</td></tr><tr><td align="left">stepout</td><td>so</td><td>退出当前功能。</td></tr><tr><td align="left">restart</td><td></td><td>恢复该过程。</td></tr><tr><td align="left">exit</td><td>q</td><td>退出调试器。</td></tr></tbody></table><h2 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h2><table><thead><tr><th align="left">命令</th><th>别名</th><th>解释</th></tr></thead><tbody><tr><td align="left">funcs</td><td></td><td>检查功能列表。（例如 funcs main..* ）</td></tr><tr><td align="left">list</td><td>l</td><td>显示代码。（例如 l 10 l main.main:3 ）</td></tr><tr><td align="left">locals</td><td></td><td>检查局部变量。</td></tr><tr><td align="left">vars</td><td></td><td>检查包变量。</td></tr><tr><td align="left">print</td><td>p</td><td>评估一个表达式。</td></tr><tr><td align="left">set</td><td></td><td>覆盖变量。</td></tr><tr><td align="left">stack</td><td>bt</td><td>显示堆栈跟踪。</td></tr></tbody></table><p>您还可以通过在调试过程中执行来查看如何使用其他命令 <code>help </code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(dlv) help</span><br><span class="line">The following commands are available:</span><br><span class="line"></span><br><span class="line">Running the program:</span><br><span class="line">    call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)</span><br><span class="line">    continue (alias: c) --------- Run until breakpoint or program termination.</span><br><span class="line">    next (alias: n) ------------- Step over to next source line.</span><br><span class="line">    rebuild --------------------- Rebuild the target executable and restarts it. It does not work if the executable was not built by delve.</span><br><span class="line">    restart (alias: r) ---------- Restart process.</span><br><span class="line">    step (alias: s) ------------- Single step through program.</span><br><span class="line">    step-instruction (alias: si)  Single step a single cpu instruction.</span><br><span class="line">    stepout (alias: so) --------- Step out of the current function.</span><br><span class="line"></span><br><span class="line">Manipulating breakpoints:</span><br><span class="line">    break (alias: b) ------- Sets a breakpoint.</span><br><span class="line">    breakpoints (alias: bp)  Print out info for active breakpoints.</span><br><span class="line">    clear ------------------ Deletes breakpoint.</span><br><span class="line">    clearall --------------- Deletes multiple breakpoints.</span><br><span class="line">    condition (alias: cond)  Set breakpoint condition.</span><br><span class="line">    on --------------------- Executes a command when a breakpoint is hit.</span><br><span class="line">    toggle ----------------- Toggles on or off a breakpoint.</span><br><span class="line">    trace (alias: t) ------- Set tracepoint.</span><br><span class="line">    watch ------------------ Set watchpoint.</span><br><span class="line"></span><br><span class="line">Viewing program variables and memory:</span><br><span class="line">    args ----------------- Print function arguments.</span><br><span class="line">    display -------------- Print value of an expression every time the program stops.</span><br><span class="line">    examinemem (alias: x)  Examine raw memory at the given address.</span><br><span class="line">    locals --------------- Print local variables.</span><br><span class="line">    print (alias: p) ----- Evaluate an expression.</span><br><span class="line">    regs ----------------- Print contents of CPU registers.</span><br><span class="line">    set ------------------ Changes the value of a variable.</span><br><span class="line">    vars ----------------- Print package variables.</span><br><span class="line">    whatis --------------- Prints type of an expression.</span><br><span class="line"></span><br><span class="line">Listing and switching between threads and goroutines:</span><br><span class="line">    goroutine (alias: gr) -- Shows or changes current goroutine</span><br><span class="line">    goroutines (alias: grs)  List program goroutines.</span><br><span class="line">    thread (alias: tr) ----- Switch to the specified thread.</span><br><span class="line">    threads ---------------- Print out info for every traced thread.</span><br><span class="line"></span><br><span class="line">Viewing the call stack and selecting frames:</span><br><span class="line">    deferred --------- Executes command in the context of a deferred call.</span><br><span class="line">    down ------------- Move the current frame down.</span><br><span class="line">    frame ------------ Set the current frame, or execute command on a different frame.</span><br><span class="line">    stack (alias: bt)  Print stack trace.</span><br><span class="line">    up --------------- Move the current frame up.</span><br><span class="line"></span><br><span class="line">Other commands:</span><br><span class="line">    config --------------------- Changes configuration parameters.</span><br><span class="line">    disassemble (alias: disass)  Disassembler.</span><br><span class="line">    dump ----------------------- Creates a core dump from the current process state</span><br><span class="line">    edit (alias: ed) ----------- Open where you are in $DELVE_EDITOR or $EDITOR</span><br><span class="line">    exit (alias: quit | q) ----- Exit the debugger.</span><br><span class="line">    funcs ---------------------- Print list of functions.</span><br><span class="line">    help (alias: h) ------------ Prints the help message.</span><br><span class="line">    libraries ------------------ List loaded dynamic libraries</span><br><span class="line">    list (alias: ls | l) ------- Show source code.</span><br><span class="line">    source --------------------- Executes a file containing a list of delve commands</span><br><span class="line">    sources -------------------- Print list of source files.</span><br><span class="line">    transcript ----------------- Appends command output to a file.</span><br><span class="line">    types ---------------------- Print list of types</span><br><span class="line"></span><br><span class="line">Type help followed by a command for full documentation.</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/go-delve/delve">go-delve&#x2F;delve：Delve 是 Go 编程语言的调试器</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/08/11/Golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-Delve/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-上下文</title>
      <link>https://ch3nnn.github.io/2023/05/13/Golang-%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <guid>https://ch3nnn.github.io/2023/05/13/Golang-%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <pubDate>Sat, 13 May 2023 08:46:27 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在Go语言中，&lt;code&gt;context&lt;/code&gt;上下文用于在多个&lt;code&gt;goroutine&lt;/code&gt;之间传递请求作用域的参数、</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Go语言中，<code>context</code>上下文用于在多个<code>goroutine</code>之间传递请求作用域的参数、取消信号和截止时间等数据，通常在处理网络请求或RPC时使用。</p><p>context.Context 是 Go 语言在 1.7 版本中引入标准库的接口，该接口定义了四个需要实现的方法，其中包括：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 context.Context 被取消的时间，也就是完成工作的截止日期</span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel</span></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；</span></span><br><span class="line">    <span class="comment">// 如果 context.Context 被取消，会返回 Canceled 错误；</span></span><br><span class="line">    <span class="comment">// 如果 context.Context 超时，会返回 DeadlineExceeded 错误；</span></span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认上下文</strong><br>context 包中最常用的方法还是 <code>context.Background</code>、<code>context.TODO</code>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>，它们会在同一个 Go 程序中被复用：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码来看，<code>context.Background</code> 和 <code>context.TODO</code> 也只是互为别名，没有太大的差别，只是在使用和语义上稍有不同：</p><ul><li>context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li><li>context.TODO 应该仅在不确定应该使用哪种上下文时使用；</li></ul><p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 <code>context.Background</code> 作为起始的上下文向下传递。</p><p><strong>emptyCtx</strong></p><p>其本质上都是基于 <code>emptyCtx</code> 类型的基本封装。而 <code>emptyCtx</code> 类型本质上是实现了 <code>Context</code> 接口：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 emptyCtx 类型的 context 的实现非常简单，因为他是空 context 的定义，因此没有 deadline，更没有 timeout，可以认为就是一个基础空白 context 模板。</p><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>演示代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">parentCtx := context.Background()</span><br><span class="line">ctx, cancel := context.WithTimeout(parentCtx, <span class="number">1</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>context deadline exceeded</code></p><p>标准库 context 还支持下述方法:</p><p><img src="https://s2.loli.net/2023/05/13/xqFwHyNEDL3SobY.png"></p><ul><li>WithCancel：基于父级 context，创建一个可以取消的新 context。</li><li>WithDeadline：基于父级 context，创建一个具有截止时间（Deadline）的新 context。</li><li>WithTimeout：基于父级 context，创建一个具有超时时间（Timeout）的新 context。</li><li>WithValue：基于某个 context 创建并存储对应的上下文信息。</li><li>Background：创建一个空的 context，一般常用于作为根的父级 context。</li><li>TODO：创建一个空的 context，一般用于未确定时的声明使用。</li></ul><p><strong>基本结构</strong></p><p>在标准库 context 的设计上，一共提供了四类 context 类型来实现上述接口。分别是 emptyCtx、cancelCtx、timerCtx 以及 valueCtx。</p><p><img src="https://s2.loli.net/2023/05/13/UlpWTIuM3i1wsKg.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，context上下文是Go语言中非常重要的一个概念，它可以帮助我们更好地管理请求处理过程中的资源和行为，并且可以在多个goroutine之间方便地传递数据。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#61-%E4%B8%8A%E4%B8%8B%E6%96%87-context">Go 语言设计与实现 - 上下文 Context</a></p><p><a href="https://golang1.eddycjy.com/posts/ch2/context/">Go 语言进阶之旅 - 上下文 </a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/05/13/Golang-%E4%B8%8A%E4%B8%8B%E6%96%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-常见数据结构Slice</title>
      <link>https://ch3nnn.github.io/2023/04/30/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Slice/</link>
      <guid>https://ch3nnn.github.io/2023/04/30/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Slice/</guid>
      <pubDate>Sat, 29 Apr 2023 16:56:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Golang-常见数据结构Slice&quot;&gt;&lt;a href=&quot;#Golang-常见数据结构Slice&quot; class=&quot;headerlink&quot; title=&quot;Golang-常见数据结构Slice&quot;&gt;&lt;/a&gt;Golang-常见数据结构Slice&lt;/h1&gt;&lt;h2 id=&quot;S</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Golang-常见数据结构Slice"><a href="#Golang-常见数据结构Slice" class="headerlink" title="Golang-常见数据结构Slice"></a>Golang-常见数据结构Slice</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>slice 翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。</p><p>了解 slice 的本质, 最简单的方法就是看它的源码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>slice 共有三个属性: </p><ol><li><strong>指针</strong> 指向底层数组</li><li><strong>长度</strong> 表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度</li><li><strong>容量</strong> 底层数组的元素个数，容量 &gt;&#x3D; 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。</li></ol><p><img src="https://cdn.ch3nnn.cn/blog/202304191511106.png"></p><p><strong>注意</strong>: 底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><h2 id="slice-创建"><a href="#slice-创建" class="headerlink" title="slice 创建"></a>slice 创建</h2><table><thead><tr><th>方式</th><th>代码示例</th></tr></thead><tbody><tr><td>直接声明</td><td>var slice []int</td></tr><tr><td>new</td><td>slice :&#x3D; *new([]int)</td></tr><tr><td>字面量</td><td>slice :&#x3D; []int{1,2,3,4}</td></tr><tr><td>make</td><td>slice :&#x3D; make(int[], 5, 10)</td></tr><tr><td>从切片或者数组”截取”</td><td>slice :&#x3D; array[1:5] 或 slice :&#x3D; sourceSlice[1:5]</td></tr></tbody></table><p><strong>直接声明</strong></p><p>第一种创建出来的 <code>slice</code> 其实是一个 <code>nil slice</code>。它的长度和容量都为0。和<code>nil</code>比较的结果为<strong>true</strong>。</p><p>这里比较混淆的是<code>empty slice</code>，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 <code>0xc42003bda0</code>。空切片和 <code>nil</code> 比较的结果为<strong>false</strong>。<br><img src="https://cdn.ch3nnn.cn/blog/2023041916818915555725.jpg" alt="16818915555725"></p><table><thead><tr><th>创建方式</th><th>nil切片</th><th>空切片</th></tr></thead><tbody><tr><td>方式一</td><td>var s1 []int</td><td>var s2 &#x3D; []int{}</td></tr><tr><td>方式二</td><td>var s4 &#x3D; *new([]int)</td><td>var s3 &#x3D; make([]int, 0)</td></tr><tr><td>len</td><td>0</td><td>0</td></tr><tr><td>cap</td><td>0</td><td>0</td></tr><tr><td>和 nil 比较</td><td>true</td><td>false</td></tr></tbody></table><p><code>nil</code> 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p><p>关于nil slice和empty slice的探索可以参考 - <a href="https://juejin.cn/post/6844903712654098446">深度解析 Go 语言中「切片」的三种特殊状态</a></p><p><strong>字面量</strong></p><p>比较简单，直接用初始化表达式创建。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>: <span class="number">100</span>&#125;</span><br><span class="line">    fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>[0 1 2 3 0 0 0 0 100] 9 9</code></p><p>唯一值得注意的是上面的代码例子中使用了索引号，直接赋值，这样，其他未注明的元素则默认 0 值</p><p><strong>make</strong></p><p><code>make</code> 函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等。</p><p>使用 <code>make</code> 关键字创建 <code>slice</code>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packge main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 长度为 5, 容量为 10</span></span><br><span class="line">    slice := <span class="built_in">make</span>(<span class="type">int</span>[], <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 索引为 2 的元素赋值为 2</span></span><br><span class="line">    slice[<span class="number">2</span>] = <span class="number">2</span> </span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>截取</strong></p><p>截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置。</p><p>基于已有 slice 创建新 slice 对象，被称为 reslice。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改都会影响到彼此。</p><p>基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。</p><p>值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 <code>append</code> 操作使得新 slice 底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，问题的关键在于两者<strong>是否会共用底层数组</strong>。</p><p>截取操作采用如下方式：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">// data[low, high, max]</span></span><br><span class="line">slice := data[<span class="number">2</span>:<span class="number">4</span>:<span class="number">6</span>] </span><br></pre></td></tr></table></figure><h2 id="其他易错点"><a href="#其他易错点" class="headerlink" title="其他易错点"></a>其他易错点</h2><p><strong>slice 和数组的区别在哪</strong></p><p>slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p>数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。</p><p>而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。</p><p><strong>append 到底做了什么</strong></p><p>先来看看 append 函数的原型：<br><code>func append(slice []Type, elems ...Type) []Type</code></p><p>append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 … 传入 slice，直接追加一个切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice = <span class="built_in">append</span>(slice, elem1, elem2)</span><br><span class="line">slice = <span class="built_in">append</span>(slice, anotherSlice...)</span><br></pre></td></tr></table></figure><p>注: append函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。</p><p><strong>slice 扩容</strong></p><p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p><p>大多数的文章都是这样描述的:</p><blockquote><p>当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。</p></blockquote><p>其实结论不太准确的</p><p>为了说明上面的规律是错误的，如下代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    oldCap := <span class="built_in">cap</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line"></span><br><span class="line">        newCap := <span class="built_in">cap</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newCap != oldCap &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%d -&gt; %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n&quot;</span>, <span class="number">0</span>, i<span class="number">-1</span>, oldCap, i, newCap)</span><br><span class="line">            oldCap = newCap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span> -&gt;   <span class="number">-1</span>] <span class="built_in">cap</span> = <span class="number">0</span>     |  after <span class="built_in">append</span> <span class="number">0</span>     <span class="built_in">cap</span> = <span class="number">1</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">0</span>] <span class="built_in">cap</span> = <span class="number">1</span>     |  after <span class="built_in">append</span> <span class="number">1</span>     <span class="built_in">cap</span> = <span class="number">2</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">1</span>] <span class="built_in">cap</span> = <span class="number">2</span>     |  after <span class="built_in">append</span> <span class="number">2</span>     <span class="built_in">cap</span> = <span class="number">4</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">3</span>] <span class="built_in">cap</span> = <span class="number">4</span>     |  after <span class="built_in">append</span> <span class="number">4</span>     <span class="built_in">cap</span> = <span class="number">8</span>   </span><br><span class="line">[<span class="number">0</span> -&gt;    <span class="number">7</span>] <span class="built_in">cap</span> = <span class="number">8</span>     |  after <span class="built_in">append</span> <span class="number">8</span>     <span class="built_in">cap</span> = <span class="number">16</span>  </span><br><span class="line">[<span class="number">0</span> -&gt;   <span class="number">15</span>] <span class="built_in">cap</span> = <span class="number">16</span>    |  after <span class="built_in">append</span> <span class="number">16</span>    <span class="built_in">cap</span> = <span class="number">32</span>  </span><br><span class="line">[<span class="number">0</span> -&gt;   <span class="number">31</span>] <span class="built_in">cap</span> = <span class="number">32</span>    |  after <span class="built_in">append</span> <span class="number">32</span>    <span class="built_in">cap</span> = <span class="number">64</span>  </span><br><span class="line">[<span class="number">0</span> -&gt;   <span class="number">63</span>] <span class="built_in">cap</span> = <span class="number">64</span>    |  after <span class="built_in">append</span> <span class="number">64</span>    <span class="built_in">cap</span> = <span class="number">128</span> </span><br><span class="line">[<span class="number">0</span> -&gt;  <span class="number">127</span>] <span class="built_in">cap</span> = <span class="number">128</span>   |  after <span class="built_in">append</span> <span class="number">128</span>   <span class="built_in">cap</span> = <span class="number">256</span> </span><br><span class="line">[<span class="number">0</span> -&gt;  <span class="number">255</span>] <span class="built_in">cap</span> = <span class="number">256</span>   |  after <span class="built_in">append</span> <span class="number">256</span>   <span class="built_in">cap</span> = <span class="number">512</span> </span><br><span class="line">[<span class="number">0</span> -&gt;  <span class="number">511</span>] <span class="built_in">cap</span> = <span class="number">512</span>   |  after <span class="built_in">append</span> <span class="number">512</span>   <span class="built_in">cap</span> = <span class="number">1024</span></span><br><span class="line">[<span class="number">0</span> -&gt; <span class="number">1023</span>] <span class="built_in">cap</span> = <span class="number">1024</span>  |  after <span class="built_in">append</span> <span class="number">1024</span>  <span class="built_in">cap</span> = <span class="number">1280</span></span><br><span class="line">[<span class="number">0</span> -&gt; <span class="number">1279</span>] <span class="built_in">cap</span> = <span class="number">1280</span>  |  after <span class="built_in">append</span> <span class="number">1280</span>  <span class="built_in">cap</span> = <span class="number">1696</span></span><br><span class="line">[<span class="number">0</span> -&gt; <span class="number">1695</span>] <span class="built_in">cap</span> = <span class="number">1696</span>  |  after <span class="built_in">append</span> <span class="number">1696</span>  <span class="built_in">cap</span> = <span class="number">2304</span></span><br></pre></td></tr></table></figure><p>在老 slice 容量小于1024的时候，新 slice 的容量的确是老 slice 的2倍。目前还算正确。</p><p>但是，当老 slice 容量大于等于 1024 的时候，情况就有变化了。当向 slice 中添加元素 1280 的时候，老 slice 的容量为 1280，之后变成了 1696，两者并不是 1.25 倍的关系（1696&#x2F;1280&#x3D;1.325）。添加完 1696 后，新的容量 2304 当然也不是 1696 的 1.25 倍。</p><p>可见，现在网上各种文章中的扩容策略并不正确。我们直接搬出源码：源码面前，了无秘密。</p><p>从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 <code>growslice</code> 函数，所以我们直接看它的代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go 1.9.5 src/runtime/slice.go:82</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">    newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吗？如果只看前半部分，现在网上各种文章里说的 newcap 的规律是对的。现实是，后半部分还对 newcap 作了一个内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍或者1.25倍。</p><p>之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。</p><p><strong>为什么 nil slice 可以直接 append</strong></p><p>其实 nil slice 或者 empty slice 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 mallocgc 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的nil slice 或 empty slice，然后摇身一变，成为“真正”的 slice 了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>切片是对底层数组的一个抽象，描述了它的一个片段。</li><li>切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。</li><li>多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。</li><li>append 函数会在切片容量不够的情况下，调用 growslice 函数获取所需要的内存，这称为扩容，扩容会改变元素原来的位置。</li><li>扩容策略并不是简单的扩为原切片容量的 2 倍或 1.25 倍，还有内存对齐的操作。扩容后的容量 &gt;&#x3D; 原容量的 2 倍或 1.25 倍。</li><li>当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者接收改变后的切片或者将切片指针作为函数参数。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA">深度解密Go语言之Slice</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/04/30/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Slice/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Golang-常见数据结构Map</title>
      <link>https://ch3nnn.github.io/2023/04/11/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map/</link>
      <guid>https://ch3nnn.github.io/2023/04/11/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map/</guid>
      <pubDate>Tue, 11 Apr 2023 02:07:33 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h2&gt;&lt;p&gt;map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。</p><p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表， 有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 <code>O(1)</code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。</p><p>完美哈希函数如图:<br><img src="https://cdn.ch3nnn.cn/img202304111020765.png"></p><p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。</p><p> 不均匀哈希函数如图:<br><img src="https://cdn.ch3nnn.cn/img202304111022378.png"></p><p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p><p><strong>开放寻址法</strong><br>开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从索引开始遍历</p><p>当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置<br>开放地址法写入数据如图:<br><img src="https://cdn.ch3nnn.cn/img202304111027414.png"><br>如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p><p>开放地址法读取数据如图:<br><img src="https://cdn.ch3nnn.cn/img202304111029114.png"></p><p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。</p><p>开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。</p><p><strong>拉链法</strong></p><p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p><p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：<br>拉链法写入数据如图:<br><img src="https://cdn.ch3nnn.cn/img202304111030711.png"></p><p>如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模</p><p>选择了 2 号桶之后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p><p>找到键相同的键值对 —— 更新键对应的值；<br>没有找到键相同的键值对 —— 在链表的末尾追加新键值对；将键值对写入哈希之后，要通过某个键在其中获取映射的值，就会经历如下的过程：<br><img src="https://cdn.ch3nnn.cn/img202304111037651.png"></p><p>Key11 展示了一个键在哈希表中不存在的例子，当哈希表发现它命中 4 号桶时，它会依次遍历桶中的链表，然而遍历到链表的末尾也没有找到期望的键，所以哈希表中没有该键对应的值。</p><p>在一个性能比较好的哈希表中，每一个桶中都应该有 0-1 个元素，有时会有 2-3 个，很少会超过这个数量，计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：<br><code>装载因子 := 元素数量 / 桶数量</code><br>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1&#x2F;10，但是仍然比在链表中直接读写好 1000 倍。</p><h2 id="Map-底层数据结构"><a href="#Map-底层数据结构" class="headerlink" title="Map 底层数据结构"></a>Map 底层数据结构</h2><p>Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 hmap 结构体来表示哈希 其实是 hashmap 的缩写，我们先来看一下这个结构体内部的字段：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// map中存入元素的个数, golang 中调用 len(map) 的时候直接返回该字段</span></span><br><span class="line">    count     <span class="type">int</span></span><br><span class="line"><span class="comment">// 状态标记位，通过与定义的枚举值进行&amp;操作可以判断当前是否处于这种状态</span></span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line"><span class="comment">// 2^B 表示bucket的数量， B 表示取hash后多少位来做bucket的分组</span></span><br><span class="line">    B         <span class="type">uint8</span></span><br><span class="line"><span class="comment">// overflow bucket 的数量的近似数</span></span><br><span class="line">    noverflow <span class="type">uint16</span></span><br><span class="line"><span class="comment">// hash seed （hash 种子） 一般是一个素数</span></span><br><span class="line">    hash0     <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共有2^B个 bucket ，但是如果没有元素存入，这个字段可能为nil</span></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line"><span class="comment">// 在扩容期间，将旧的bucket数组放在这里， 新buckets会是这个的两倍大</span></span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line"><span class="comment">// 表示已经完成扩容迁移的bucket的指针， 地址小于当前指针的bucket已经迁移完成</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// optional fields</span></span><br><span class="line">    extra *mapextra</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>count</code> 表示当前哈希表中的元素数量；<br><code>B</code> 表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 len(buckets) &#x3D;&#x3D; 2^B；<br><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；<br><code>oldbuckets</code> 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；</p><p> 哈希表的数据结构如图:<br><img src="https://cdn.ch3nnn.cn/img202304111044236.png"></p><p>如上图所示哈希表 hmap 的桶就是 bmap，也就是我们常说的”桶”的底层数据结构, 每一个 bmap 都能存储 8 个键值对(key&#x2F;value)，map 使用 hash 函数得到 hash 值决定分配到哪个桶, 然后又根据hash 值的高 8 位来寻找放在桶的那个位置。当哈希表中存储的数据过多，单个桶无法装满时就会使用 extra.overflow 中桶存储溢出的数据。上述两种不同的桶在内存中是连续存储的，我们在这里将它们分别称为正常桶和溢出桶，上图中黄色的 bmap 就是正常桶，绿色的 bmap 是溢出桶，溢出桶是在 Go 语言还使用 C 语言实现时就使用的设计3，由于它能够减少扩容的频率所以一直使用至今。</p><p>这个桶的结构体 bmap 在 Go 语言源代码中的定义只包含一个简单的 tophash 字段，tophash 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bmap 结构体其实不止包含 tophash 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段，但是我们能根据编译期间的 cmd&#x2F;compile&#x2F;internal&#x2F;gc.bmap 函数对它的结构重建：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果哈希表存储的数据逐渐增多，我们会对哈希表进行扩容或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><h2 id="Map-存与取"><a href="#Map-存与取" class="headerlink" title="Map 存与取"></a>Map 存与取</h2><p>在 map 中存与取本质上都是在进行一个工作， 那就是:</p><ol><li>查询当前 k&#x2F;v 应该存储的位置。</li><li>赋值&#x2F;取值， 所以我们理解了 map 中 key 的定位我们就理解了存取。</li></ol><p><strong>底层代码</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hexo_blog</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">//    map 为空，或者元素数为0，直接返回未找到</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    不支持并发读写</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent    map    read    and    map    write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    根据hash 函数算出hash值，注意key的类型不同可能使用的hash函数也不同</span></span><br><span class="line">hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"><span class="comment">//    如果 B = 5，那么结果用二进制表示就是 11111 ,返回的是B位全1的值</span></span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line"><span class="comment">//    根据hash的后B位，定位在bucket数组中的位置</span></span><br><span class="line">b := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="comment">//    当  h.oldbuckets 非空时，说明 map 发生了扩容</span></span><br><span class="line"><span class="comment">//    这时候，新的 buckets 里可能还没有老的内容</span></span><br><span class="line"><span class="comment">//    所以一定要在老的里面找，否则有可能发生“消失”的诡异现象</span></span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">//    说明之前只有一半的    bucket，需要除    2</span></span><br><span class="line">m &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">oldb := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(c) + (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">b = oldb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    tophash 取其 8bit 的值</span></span><br><span class="line">top := tophash(hash)</span><br><span class="line"><span class="comment">//    一个 bucket 在存储满 8 个元素后，就再也放不下了，这时候会创建新的 bucket，挂在原来的 bucket 的 overflow 指针成员上</span></span><br><span class="line"><span class="comment">//    遍历当前bucket的所有链式bucket</span></span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line"><span class="comment">//    在bucket的8个位置上查询</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="comment">//    如果找到了相等的 tophash，那说明就是这个 bucket 了</span></span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    根据内存结构定位key的位置</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 校验找到的key是否匹配</span></span><br><span class="line"><span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line"><span class="comment">// 定位v的位置</span></span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    所有    bucket    都没有找到，返回零值和    false</span></span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Map-扩容"><a href="#Map-扩容" class="headerlink" title="Map 扩容"></a>Map 扩容</h2><p>在 golang 中 map 和 slice 一样都是在初始化时首先申请较小的内存空间, 随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime.mapassign</code> 函数会在以下两种情况发生时触发哈希的扩容：</p><ul><li>装载因子已经超过 6.5(触发增量扩容)；</li><li>哈希使用了太多溢出桶, 桶数量过多(触发等量扩容)；不过由于 Go 语言哈希的扩容不是一个原子的过程，所以 <code>runtime.mapassign</code> 函数还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</li></ul><p>根据触发的条件不同扩容的方式分成两种，<strong>增量扩容</strong>与<strong>等量扩容（重新排列并分配内存）</strong>。如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 sameSizeGrow，sameSizeGrow 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏。runtime: limit the number of map overflow buckets 引入了 sameSizeGrow 通过重用已有的哈希扩容机制，一旦哈希中出现了过多的溢出桶，它就会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存5。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">Go 语言设计与实现-哈希表</a><br><a href="https://juejin.cn/post/7133161294378565668#heading-5">Golang 中 map 探究</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/Go/">Go</category>
      
      
      <comments>https://ch3nnn.github.io/2023/04/11/Golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务 API 网关对比和选型</title>
      <link>https://ch3nnn.github.io/2023/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</link>
      <guid>https://ch3nnn.github.io/2023/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</guid>
      <pubDate>Tue, 04 Apr 2023 08:45:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务&quot;&gt;&lt;/a&gt;什么是微服务&lt;/h2&gt;&lt;p&gt;微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。<br>在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。微服务是互联网业务发展的结果，互联网业务的飞速发展导致系统的架构也在不断地发生变化，总体来说，系统的架构大致经历了：单体应用架构—&gt;<br>SOA 架构—&gt;微服务架构 的演变，具体发展历程和各自的优缺点如下表所示。<br><img src="https://cdn.ch3nnn.cn/img202304041708571.png"></p><p>因此，微服务是互联网发展的必然结果，很多传统公司的系统架构也在逐步微服务化。但是，随着互联网业务的发展，API 的数量也在剧增，使用网关对API统一管理也将面临挑战，选择一个更强大的<br>API 网关，可以有效地增强系统的监控、容灾、鉴权和限流等能力。</p><h2 id="什么是微服务网关"><a href="#什么是微服务网关" class="headerlink" title="什么是微服务网关"></a>什么是微服务网关</h2><p><strong>API网关是一个服务器，是系统的唯一入口。</strong> 从面向对象设计的角度看，它与外观模式类似。</p><p>API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。</p><p><strong>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。</strong> 通常，网关也是提供REST&#x2F;HTTP的访问API。<br><img src="https://cdn.ch3nnn.cn/img202304162258745.png"></p><p>微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：</p><p>数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。<br>控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。</p><p><strong>微服务遇到的挑战</strong></p><p>微服务网关应该首先要具备 API 路由能力，微服务数量变多，API 数量急剧增加，网关还可以根据具体的场景作为流量过滤器来使用，以提供某些额外可选功能，因此对微服务<br>API Gateway 提出了更高要求，比如：</p><ul><li>可观测性：在以往的单体应用中，排查问题往往通过查看日志定位错误信息和异常堆栈；但是在微服务架构中服务繁多，出现问题时的问题定位变得非常困难；因此，如何监控微服务的运行状况、当出现异常时能快速给出报警，这给开发人员带来很大挑战。</li><li></li></ul><p>鉴权认证：而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其它服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在微服务架构下，要考虑外部应用接入的场景、用户 -</p><ul><li>服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。</li><li>系统稳定性：若大量请求超过微服务的处理能力时，可能会将服务打垮，甚至产生雪崩效应、影响系统的整体稳定性。</li><li>服务发现：微服务的分散管理，让微服务的负载均衡的实现也更具有挑战性。</li></ul><p><strong>解决方案</strong></p><p>API 网关作为客户端和服务端的中间桥梁，为微服务系统提供统一的管理机制：<br>除了基础的请求分发、API 管理和条件路由等功能，还包括身份验证、监控报警、调用链追踪、负载均衡、限流隔离和熔断降级。身份认证：下图表示的是微服务联合<br>API 网关如何进行身份认证的，由图可见所有请求都通过网关，从而有效地隐藏了微服务。</p><p><img src="https://cdn.ch3nnn.cn/img202304041714043.png"><br>监控报警&#x2F;调用链追踪：<br>API 作为客户端和服务端的中间桥梁，是微服务监控的最好载体，API 网关监控功能的主要职责是及时发现网关以及后端服务器的连接异常，在 API<br>的监控平台上面用户可以随时查看日志信息，监控信息，调用链等等，并且主机发生的任何异常都会自动报警到控制台。有些网关甚至可以做到给客户端和服务端双向报警。</p><p><img src="https://cdn.ch3nnn.cn/img202304041714673.png"></p><p>限流隔离&#x2F;熔断降级：<br>随着互联网业务规模的增加，系统的并发度增高，多个服务之间相互调用链路，一条核心链路往往可能调用十个服务。如果在链路中，某个服务的<br>rt（响应时间）急剧上升，上游服务不断请求，造成恶性循环，上游等待结果线程数越多，使得更上游服务阻塞最终整条链路无法使用，从而导致服务雪崩，所以对入口流量进行整治管理是很有必要的，下图表示微服务系统是如何结合<br>API 网关进行限流隔离和熔断降级的。</p><p><img src="https://cdn.ch3nnn.cn/img202304041715894.png"></p><h2 id="主流网关选择"><a href="#主流网关选择" class="headerlink" title="主流网关选择"></a>主流网关选择</h2><p>在微服务领域，有许多开源网关实现，有 NGINX、Kong、Apache APISIX 和 Envoy 等，Java 技术栈的有 Netfilx Zuul、Spring Cloud Gateway、Soul 等。或许你会问“有了<br>NGINX 和 Kong，为什么还需要 Apache APISIX？” ，下面做个简单对比。</p><table><thead><tr><th>网关</th><th>痛点</th><th>优势</th></tr></thead><tbody><tr><td>NGINX</td><td>修改配置需要 Reload 才能生效，跟不上云原生的发展。</td><td>1. 老牌应用；2. 稳定可靠，久经考验；3. 高性能。</td></tr><tr><td>Apache APISIX</td><td>文档不够丰富和清晰，需要待改进。</td><td>1. Apache 基金会顶级项目；2. 技术架构更贴合云原生；3. 性能表现优秀；4. 生态丰富；5. 除了支持 Lua 开发插件外，还支持 Java、Go、Python、Node 等语言插件</td></tr><tr><td>Kong</td><td>1. 默认使用 PostgreSQL 或 Cassandra 数据库，使得整个架构非常臃肿，并且会带来高可用的问题；2. 路由使用的是遍历查找，当网关内有超过上千个路由时，它的性能就会出现比较急剧的下降；3. 一些重要功能是需要付费的。</td><td>1. 开源 API 网关的鼻祖，用户数众多；2. 性能满足大部分用户的需求；3. 生态丰富；4. 支持 Lua 和 Go 开发插件。</td></tr><tr><td>Spring Cloud Gateway</td><td>虽然 Spring 社区成熟，但是 Gateway 资源缺乏。</td><td>1. 内置了非常多的开箱即用功能，并且都可以通过 SpringBoot 配置或者手工编码链式调用来使用；2. Spring 系列可扩展性强，易配置，可维护性好；   3. Spring 社区成熟；4. 简单易用；5. 对于 Java 技术栈来说方便</td></tr><tr><td>Traefik</td><td>生产案例不太多</td><td>1. 基于 golang开发 2. 云原生可编程 api&#x2F;对接各种服务发现</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/l9Nvlyg95KSdoo6iU6Fh4Q">微服务为什么要用到 API 网关？</a><br><a href="https://juejin.cn/post/7063244165538119710">5 种主流API网关技术选型，yyds！</a></p>]]></content:encoded>
      
      
      
      <category domain="https://ch3nnn.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <comments>https://ch3nnn.github.io/2023/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
