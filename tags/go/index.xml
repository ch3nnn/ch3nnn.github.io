<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Ch3nnn!Blog</title><link>https://blog.ch3nnn.cn/tags/go/</link><description>Recent content in Go on Ch3nnn!Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 20 Feb 2025 11:05:31 +0800</lastBuildDate><atom:link href="https://blog.ch3nnn.cn/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>优化结构体内存对齐的静态分析工具-fieldalignment</title><link>https://blog.ch3nnn.cn/posts/2025/%E5%B7%A5%E5%85%B7-fieldalignment%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link><pubDate>Thu, 20 Feb 2025 11:05:31 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2025/%E5%B7%A5%E5%85%B7-fieldalignment%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid><description>&lt;p>&lt;code>fieldalignment&lt;/code> 是 Go 官方工具链中用于优化结构体内存对齐的静态分析工具，可自动检测并修复结构体字段排列顺序问题。以下是核心要点：&lt;/p>
&lt;hr>
&lt;h3 id="-安装方式">🔧 安装方式&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="-基础用法">🚀 基础用法&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>命令&lt;/th>
 &lt;th>作用&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>fieldalignment ./...&lt;/code>&lt;/td>
 &lt;td>扫描当前项目所有结构体&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>fieldalignment -fix ./...&lt;/code>&lt;/td>
 &lt;td>&lt;strong>自动修复&lt;/strong>可优化的结构体字段顺序&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>fieldalignment -json ./...&lt;/code>&lt;/td>
 &lt;td>输出 JSON 格式报告&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="-功能特性">🔍 功能特性&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>智能检测&lt;/strong>&lt;br>
识别字段排列顺序导致内存浪费的结构体，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// 检测前 (24 bytes)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> User &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> active &lt;span style="color:#005a5f">bool&lt;/span> &lt;span style="color:#505050">// 1字节 (导致后续填充)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id &lt;span style="color:#005a5f">int64&lt;/span> &lt;span style="color:#505050">// 8字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> age &lt;span style="color:#005a5f">int32&lt;/span> &lt;span style="color:#505050">// 4字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// 检测后自动优化 (16 bytes)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> User &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id &lt;span style="color:#005a5f">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> age &lt;span style="color:#005a5f">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> active &lt;span style="color:#005a5f">bool&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>节省计算&lt;/strong>&lt;br>
报告潜在内存节省量，如：&lt;code>24 -&amp;gt; 16 bytes (saves 33%)&lt;/code>&lt;/p></description></item><item><title>Gorm 分表中间件(Sharding)</title><link>https://blog.ch3nnn.cn/posts/2024/gorm-%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><pubDate>Tue, 27 Aug 2024 00:51:35 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/gorm-%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://github.com/go-gorm/sharding">Sharding&lt;/a> 是一个高性能的 Gorm 分表中间件。它基于 Conn 层做 SQL 拦截、AST 解析、分表路由、自增主键填充，带来的额外开销极小。对开发者友好、透明，使用上与普通
SQL、Gorm 查询无差别，只需要额外注意一下分表键条件。 为您提供高性能的数据库访问&lt;/p>&lt;/blockquote>
&lt;h2 id="一功能特点">一、功能特点&lt;/h2>
&lt;ul>
&lt;li>非侵入式设计， 加载插件，指定配置，既可实现分表。&lt;/li>
&lt;li>轻快， 非基于网络层的中间件，像 Go 一样快&lt;/li>
&lt;li>支持多种数据库。 PostgreSQL 已通过测试，MySQL 和 SQLite 也在路上。&lt;/li>
&lt;li>多种主键生成方式支持（Snowflake, PostgreSQL Sequence, 以及自定义支持）Snowflake 支持从主键中确定分表键。&lt;/li>
&lt;/ul>
&lt;h2 id="二示例代码">二、示例代码&lt;/h2>
&lt;p>注意: 依然保持原来的方式使用 db 来查询数据库。 你只需要注意在 CURD 动作的时候，明确知道 &lt;strong>Sharding Key&lt;/strong> 对应的分表，&lt;strong>查询条件带 Sharding Key，以确保
Sharding 能理解数据需要对应到哪一个子表&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;h3 id="mysql">Mysql&lt;/h3>
&lt;p>Gorm Sharding 中内置了 MySQL 序列主键实现，只需配置PrimaryKeyGenerator: sharding.PKMySQLSequence即可使用。&lt;/p>
&lt;p>您不需要手动创建序列，当 MySQL 序列不存在时，Gorm Sharding 会检查并创建。&lt;/p>
&lt;p>这个序列名后面跟着gorm_sharding_${table_name}_id_seq，例如orders表，序列名就是gorm_sharding_orders_id_seq。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"> * @Author: chentong
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"> * @Date: 2024/08/27 00:09
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;gorm.io/driver/mysql&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;gorm.io/gorm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;gorm.io/sharding&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> Order &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ID &lt;span style="color:#005a5f">int64&lt;/span> &lt;span style="color:#2544bb">`gorm:&amp;#34;primarykey&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserID &lt;span style="color:#005a5f">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProductID &lt;span style="color:#005a5f">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">TestSharding_Mysql&lt;/span>(t &lt;span style="color:#00538b">*&lt;/span>testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dsn &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;root:123456@tcp(localhost:3306)/dev?parseTime=True&amp;amp;timeout=5s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db, err &lt;span style="color:#00538b">:=&lt;/span> gorm.&lt;span style="color:#721045">Open&lt;/span>(mysql.&lt;span style="color:#721045">Open&lt;/span>(dsn))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">panic&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">2&lt;/span>; i &lt;span style="color:#00538b">+=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> table &lt;span style="color:#00538b">:=&lt;/span> fmt.&lt;span style="color:#721045">Sprintf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;orders_%d&amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">`DROP TABLE IF EXISTS `&lt;/span> &lt;span style="color:#00538b">+&lt;/span> table)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;CREATE TABLE &amp;#34;&lt;/span> &lt;span style="color:#00538b">+&lt;/span> table &lt;span style="color:#00538b">+&lt;/span> &lt;span style="color:#2544bb">&amp;#34; ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `product_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Use&lt;/span>(sharding.&lt;span style="color:#721045">Register&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharding.Config{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ShardingKey: &lt;span style="color:#2544bb">&amp;#34;user_id&amp;#34;&lt;/span>, &lt;span style="color:#505050">// 分片key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NumberOfShards: &lt;span style="color:#0000c0">2&lt;/span>, &lt;span style="color:#505050">// 分片数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PrimaryKeyGenerator: sharding.PKMySQLSequence, &lt;span style="color:#505050">// 主键生成器, 这里使用 mysql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> []&lt;span style="color:#005a5f">string&lt;/span>{&lt;span style="color:#2544bb">&amp;#34;orders&amp;#34;&lt;/span>}, &lt;span style="color:#505050">// 需要分片 tables &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this record will insert to orders_02&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Create&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>Order{UserID: &lt;span style="color:#0000c0">2&lt;/span>}).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this record will insert to orders_03&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;INSERT INTO orders(user_id) VALUES(?)&amp;#34;&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">3&lt;/span>)).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this will throw ErrMissingShardingKey error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;INSERT INTO orders(product_id) VALUES(1)&amp;#34;&lt;/span>).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this will redirect query to orders_02&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> orders []Order
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Model&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>Order{}).&lt;span style="color:#721045">Where&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;user_id&amp;#34;&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">2&lt;/span>)).&lt;span style="color:#721045">Find&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>orders).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;%#v\n&amp;#34;&lt;/span>, orders)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// Raw SQL also supported&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Raw&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;SELECT * FROM orders WHERE user_id = ?&amp;#34;&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">3&lt;/span>)).&lt;span style="color:#721045">Scan&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>orders)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;%#v\n&amp;#34;&lt;/span>, orders)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this will throw ErrMissingShardingKey error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Model&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>Order{}).&lt;span style="color:#721045">Where&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;product_id&amp;#34;&lt;/span>, &lt;span style="color:#2544bb">&amp;#34;1&amp;#34;&lt;/span>).&lt;span style="color:#721045">Find&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>orders).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// Update and Delete are similar to create and query&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;UPDATE orders SET product_id = ? WHERE user_id = ?&amp;#34;&lt;/span>, &lt;span style="color:#0000c0">2&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">3&lt;/span>)).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err) &lt;span style="color:#505050">// nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;DELETE FROM orders WHERE product_id = 3&amp;#34;&lt;/span>).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err) &lt;span style="color:#505050">// ErrMissingShardingKey&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>Go 编程风格指南 - 最佳实践</title><link>https://blog.ch3nnn.cn/posts/2024/go%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 03 Jun 2024 10:42:06 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/go%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>&lt;p>原文：&lt;a href="https://google.github.io/styleguide/go">https://google.github.io/styleguide/go&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gocn.github.io/styleguide/docs/01-overview/">概述&lt;/a> | &lt;a href="https://gocn.github.io/styleguide/docs/02-guide/">风格指南&lt;/a> | &lt;a href="https://gocn.github.io/styleguide/docs/03-decisions/">风格决策&lt;/a> | &lt;a href="https://gocn.github.io/styleguide/docs/04-best-practices/">最佳实践&lt;/a>&lt;/p>
&lt;p>&lt;strong>注意：&lt;/strong> 本文是 Google &lt;a href="https://gocn.github.io/styleguide/docs/01-overview/">Go 风格&lt;/a> 系列文档的一部分。本文档是 *
&lt;em>&lt;a href="https://gocn.github.io/styleguide/docs/01-overview/#%E6%A0%87%E5%87%86normative">规范性(normative)&lt;/a>
但不是&lt;a href="https://gocn.github.io/styleguide/docs/01-overview/#%E8%A7%84%E8%8C%83canonical">强制规范(canonical)&lt;/a>&lt;/em>*
，并且从属于&lt;a href="https://gocn.github.io/styleguide/docs/02-guide/">Google 风格指南&lt;/a>
。请参阅&lt;a href="https://gocn.github.io/styleguide/docs/01-overview/#%E5%85%B3%E4%BA%8E">概述&lt;/a>获取更多详细信息。&lt;/p>
&lt;h2 id="关于">关于&lt;/h2>
&lt;p>本文件记录了&lt;strong>关于如何更好地应用 Go 风格指南的指导意见&lt;/strong>。该指导旨在解决经常出现的通用问题，但不一定适用于所有情况。在可能的情况下，我们讨论了多种替代方法，以及决定何时该用和何时不该用这些方法的考虑因素。&lt;/p>
&lt;p>查看&lt;a href="https://gocn.github.io/styleguide/docs/01-overview/#%E5%85%B3%E4%BA%8E">概述&lt;/a>来获取完整的风格指导文档&lt;/p>
&lt;h2 id="命名">命名&lt;/h2>
&lt;h3 id="函数和方法名称">函数和方法名称&lt;/h3>
&lt;h4 id="避免重复">避免重复&lt;/h4>
&lt;p>在为一个函数或方法选择名称时，要考虑该名称将被阅读的环境。请考虑以下建议，以避免在调用地点出现过多的&lt;a href="https://gocn.github.io/styleguide/docs/03-decisions/#%E9%87%8D%E5%A4%8Drepetition">重复&lt;/a>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>以下内容一般可以从函数和方法名称中省略。&lt;/p>
&lt;ul>
&lt;li>输入和输出的类型（当没有冲突的时候）&lt;/li>
&lt;li>方法的接收器的类型&lt;/li>
&lt;li>一个输入或输出是否是一个指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>对于函数，不要&lt;a href="https://gocn.github.io/styleguide/docs/03-decisions/#%E5%8C%85%E5%90%8D-vs-%E5%8F%AF%E5%AF%BC%E5%87%BA%E7%AC%A6%E5%8F%B7%E5%90%8Dpackage-vs-exported-symbol-name">重复软件包的名称&lt;/a>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Bad:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> yamlconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">ParseYAMLConfig&lt;/span>(input &lt;span style="color:#005a5f">string&lt;/span>) (&lt;span style="color:#00538b">*&lt;/span>Config, &lt;span style="color:#005a5f">error&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Good:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> yamlconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">Parse&lt;/span>(input &lt;span style="color:#005a5f">string&lt;/span>) (&lt;span style="color:#00538b">*&lt;/span>Config, &lt;span style="color:#005a5f">error&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>对于方法不要重复方法接收器的名称。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Bad:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> (c &lt;span style="color:#00538b">*&lt;/span>Config) &lt;span style="color:#721045">WriteConfigTo&lt;/span>(w io.Writer) (&lt;span style="color:#005a5f">int64&lt;/span>, &lt;span style="color:#005a5f">error&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Good:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> (c &lt;span style="color:#00538b">*&lt;/span>Config) &lt;span style="color:#721045">WriteTo&lt;/span>(w io.Writer) (&lt;span style="color:#005a5f">int64&lt;/span>, &lt;span style="color:#005a5f">error&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>不要重复传参的变量名称&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Bad:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">OverrideFirstWithSecond&lt;/span>(dest, source &lt;span style="color:#00538b">*&lt;/span>Config) &lt;span style="color:#005a5f">error&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Good:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">Override&lt;/span>(dest, source &lt;span style="color:#00538b">*&lt;/span>Config) &lt;span style="color:#005a5f">error&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>不要重复返回值的名称和类型&lt;/p></description></item><item><title>Protobuf 文档生成器插件</title><link>https://blog.ch3nnn.cn/posts/2024/%E5%B7%A5%E5%85%B7-protobuf%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8%E6%8F%92%E4%BB%B6/</link><pubDate>Wed, 28 Feb 2024 16:20:31 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/%E5%B7%A5%E5%85%B7-protobuf%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8%E6%8F%92%E4%BB%B6/</guid><description>&lt;blockquote>
&lt;p>这是 Google Protocol Buffers 文档生成器插件 (protoc)。
该插件可以根据文件中的注释生成 HTML、JSON、DocBook 和 Markdown 文档。&lt;/p>&lt;/blockquote>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>毫无疑问, 目前后台开发接口协议应用最广泛的除了 HTTP 之外就是 gRPC 了, HTTP 接口有成熟的&lt;code>swagger&lt;/code>工具可以生成界面美观和使用友好的文档，那么对于gRPC呢？&lt;/p>
&lt;p>所以通过 .proto 文件能否生成更易阅读的 HTML 接口文档？&lt;/p>
&lt;h2 id="二安装">二、安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go install github.com/pseudomuto/protoc-gen-doc/cmd/protoc-gen-doc@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="三使用">三、使用&lt;/h2>
&lt;h3 id="userproto-文件">user.proto 文件&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>以&lt;code>user.proto&lt;/code>为例, 如下内容:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>syntax &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;proto3&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">option&lt;/span> go_package &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;./pb&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Messages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">//--------------------------------用户--------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SysUser {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#005a5f">int64&lt;/span> id &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> username &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 用户名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> password &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// 密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> create_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">4&lt;/span>; &lt;span style="color:#505050">// 创建时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> update_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; &lt;span style="color:#505050">// 修改时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> delete_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">6&lt;/span>; &lt;span style="color:#505050">// 删除时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SysUserFilter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> id &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> username &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 用户名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> password &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// 密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> create_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">4&lt;/span>; &lt;span style="color:#505050">// 创建时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> update_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; &lt;span style="color:#505050">// 修改时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> delete_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">6&lt;/span>; &lt;span style="color:#505050">// 删除时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SelectSysUserListReq {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#005a5f">int64&lt;/span> page &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// 页码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> page_size &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 每页数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> SysUserFilter filter &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// SysUserFilter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SelectSysUserListResp {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#005a5f">int64&lt;/span> count &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// 总数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> page_count &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 页码总数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">repeated&lt;/span> SysUser results &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// sys_user
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Rpc Func
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">service&lt;/span> User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//-----------------------用户-----------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// 用户 列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">rpc&lt;/span> SelectSysUserList(SelectSysUserListReq) &lt;span style="color:#5317ac">returns&lt;/span> (SelectSysUserListResp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="1-生成-markdown-文档">1. 生成 markdown 文档&lt;/h3>
&lt;ol>
&lt;li>命令:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>protoc --doc_out&lt;span style="color:#00538b">=&lt;/span>. --doc_opt&lt;span style="color:#00538b">=&lt;/span>markdown,index.md pb/*.proto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>效果:
&lt;img src="https://s2.loli.net/2024/02/28/TwXqVdFvJyNZnfp.png" alt="20240228172356.png">&lt;/li>
&lt;/ol>
&lt;h3 id="2-生成-html-文档">2. 生成 html 文档&lt;/h3>
&lt;ol>
&lt;li>命令:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>protoc --doc_out&lt;span style="color:#00538b">=&lt;/span>. --doc_opt&lt;span style="color:#00538b">=&lt;/span>html,index.html pb/*.proto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>效果:
&lt;img src="https://s2.loli.net/2024/02/28/Jv67NT9cpYdCjre.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="四自定义模板">四、自定义模板&lt;/h2>
&lt;p>如果想使用自己的模板, 只需使用模板文件的路径而不是类型。&lt;/p></description></item><item><title>更严格的代码格式化工具-gofumpt</title><link>https://blog.ch3nnn.cn/posts/2024/golang-%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7gofumpt/</link><pubDate>Mon, 19 Feb 2024 19:56:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/golang-%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7gofumpt/</guid><description>&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>gofmt 是 golang 自带的代码自动格式化工具，是保证 Go 代码风格一致的大杀器。我们这次要推荐的 gofumpt 在 gofmt 的基础上添加了一系列更加严格的格式化规则，并保证了对
gofmt 的兼容。&lt;/p>
&lt;h2 id="二gofumpt-简介">二、gofumpt 简介&lt;/h2>
&lt;p>gofumpt(&lt;a href="https://github.com/mvdan/gofumpt">https://github.com/mvdan/gofumpt&lt;/a>) fork 自 gofmt，支持与 gofmt 几乎相同的命令行参数，因此可以作为 gofmt 的直接替代品使用。gofumpt 是
gofmt 的&amp;quot;超集&amp;quot;，经过 gofumpt 格式化的代码也符合 gofmt 的要求，其本身所扩展的格式化规则也可能在后续被集成进 gofmt。&lt;/p>
&lt;p>gofumpt 有以下特点:&lt;/p>
&lt;ul>
&lt;li>更多的格式化规则(参见 &lt;a href="https://github.com/mvdan/gofumpt#Added-rules">https://github.com/mvdan/gofumpt#Added-rules&lt;/a>)&lt;/li>
&lt;li>默认跳过对 vendor 的格式化&lt;/li>
&lt;li>不对自动生成的代码应用扩展规则&lt;/li>
&lt;li>不支持 -r 参数&lt;/li>
&lt;/ul>
&lt;h2 id="三安装使用命令">三、安装、使用命令&lt;/h2>
&lt;p>安装命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go install mvdan.cc/gofumpt@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>gofumpt -l -w .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="四使用举例">四、使用举例&lt;/h2>
&lt;p>&lt;strong>赋值运算符后面没有空行&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo &lt;span style="color:#00538b">:=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2544bb">&amp;#34;bar&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改为 gofumpt 格式化后：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;bar&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>函数体周围没有空行&lt;/strong>&lt;/p></description></item><item><title>源码级调试器 Delve</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</link><pubDate>Fri, 11 Aug 2023 15:43:40 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Go 目前的调试器有如下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GDB&lt;/code> 最早期的调试工具，现在用的很少。&lt;/li>
&lt;li>&lt;code>LLDB&lt;/code> macOS 系统推荐的标准调试工具，单 Go 的一些专有特性支持的比较少。&lt;/li>
&lt;li>&lt;code>Delve&lt;/code> 专门为 Go 语言打造的调试工具，使用最为广泛。&lt;/li>
&lt;/ul>
&lt;p>本篇简单说明如何使用 &lt;code>Delve&lt;/code> 工具来调试 Go 程序，使用的 &lt;code>delve&lt;/code> 版本为 1.20.1。&lt;/p>
&lt;p>delve 的汉语意思是：钻研、探索；用这个来命名一个debug工具还是非常的形象。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>已知以下说明适用于 Linux、macOS、Windows 和 FreeBSD。&lt;/p>
&lt;p>克隆 git 存储库并构建：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ git clone https://github.com/go-delve/delve
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#8f0075">cd&lt;/span> delve
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ go install github.com/go-delve/delve/cmd/dlv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者，在 Go 版本 1.16 或更高版本上：&lt;/p>
&lt;p>&lt;strong>Install the latest release:&lt;/strong>
&lt;code>$ go install github.com/go-delve/delve/cmd/dlv@latest&lt;/code>&lt;/p>
&lt;p>&lt;strong>Install at tree head:&lt;/strong>
&lt;code>$ go install github.com/go-delve/delve/cmd/dlv@master&lt;/code>&lt;/p>
&lt;p>&lt;strong>安装在一个特定的版本或:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="命令">命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dlv &lt;span style="color:#00538b">[&lt;/span>command&lt;span style="color:#00538b">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Available Commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attach 附加到正在运行的进程并开始调试.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect 使用终端客户端连接到无头调试服务器.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core 检查核心转储.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dap 启动一个通过调试适配器协议&lt;span style="color:#00538b">(&lt;/span>DAP&lt;span style="color:#00538b">)&lt;/span>通信的无头TCP服务器.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> debug 编译并开始调试当前目录中的主包或指定的包.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">exec&lt;/span> 执行预编译的二进制文件，并开始调试会话.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">help&lt;/span> Help about any &lt;span style="color:#8f0075">command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run 弃用的命令。使用&lt;span style="color:#2544bb">&amp;#39;debug&amp;#39;&lt;/span>代替.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">test&lt;/span> 编译测试二进制文件并开始调试程序.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trace 编译并开始跟踪程序.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version Prints version.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="操作-示例代码">[操作] 示例代码&lt;/h2>
&lt;p>下面是检查操作的代码&lt;/p></description></item><item><title>Facebook 开源 Golang 实体框架 Ent</title><link>https://blog.ch3nnn.cn/posts/2023/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 16 Jan 2023 17:29:45 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</guid><description>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs16738590832901.jpg" alt="">&lt;/p>
&lt;p>ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>图就是代码&lt;/strong> - 将任何数据库表建模为Go对象。&lt;/li>
&lt;li>&lt;strong>轻松地遍历任何图形&lt;/strong> - 可以轻松地运行查询、聚合和遍历任何图形结构。&lt;/li>
&lt;li>&lt;strong>静态类型和显式API&lt;/strong> - 使用代码生成静态类型和显式API，查询数据更加便捷。&lt;/li>
&lt;li>&lt;strong>多存储驱动程序&lt;/strong> - 支持MySQL, PostgreSQL, SQLite 和 Gremlin。&lt;/li>
&lt;li>&lt;strong>可扩展&lt;/strong> - 简单地扩展和使用Go模板自定义。&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-console" data-lang="console">&lt;span style="display:flex;">&lt;span>go install entgo.io/ent/cmd/ent@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速开始">快速开始&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go mod init &amp;lt;project&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建你的第一个项目">创建你的第一个项目&lt;/h3>
&lt;p>进入你项目的根目录，然后运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go run -mod&lt;span style="color:#00538b">=&lt;/span>mod entgo.io/ent/cmd/ent init User
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上的命令会在&lt;code>&amp;lt;project&amp;gt;/ent/schema/&lt;/code>目录下产生&lt;code>User&lt;/code>的数据模式（数据模式是数据库系统设计中的专业术语，若对该部分有任何理解问题，请查阅数据库系统的相关书籍）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> &lt;span style="color:#2544bb">&amp;#34;entgo.io/ent&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User在User实体中组合了ent默认的数据库模式定义&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> User &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ent.Schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User的字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> (User) &lt;span style="color:#721045">Fields&lt;/span>() []ent.Field {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User的边&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> (User) &lt;span style="color:#721045">Edges&lt;/span>() []ent.Edge {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为&lt;code>User&lt;/code> 模式添加两个字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;entgo.io/ent&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;entgo.io/ent/schema/field&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User的字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> (User) &lt;span style="color:#721045">Fields&lt;/span>() []ent.Field {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> []ent.Field{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#721045">Int&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;age&amp;#34;&lt;/span>).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#721045">Positive&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#721045">String&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;name&amp;#34;&lt;/span>).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#721045">Default&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;unknown&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从项目的根目录下像如下命令那样，运行&lt;code>go generate&lt;/code>：&lt;/p></description></item><item><title>Filebeat轻量型日志采集器及output插件开发</title><link>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 09 Jan 2023 16:36:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid><description>&lt;blockquote>
&lt;p>无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。&lt;/p>&lt;/blockquote>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>Filebeat 是使用 Golang 实现的轻量型日志采集器。本质上是一个 agent ，可以安装在各个节点上，根据配置读取对应位置的日志，并上报到相应的地方去。&lt;/p>
&lt;h3 id="概要">概要&lt;/h3>
&lt;p>Filebeat 并不依赖于 ElasticSearch，可以单独存在。我们可以单独使用Filebeat进行日志的上报和搜集。filebeat 内置了常用的 Output 组件, 例如 kafka、ElasticSearch、redis 等，出于调试考虑，也可以输出到 console 和 file 。我们可以利用现有的 Output 组件，将日志进行上报。&lt;/p>
&lt;h3 id="整体工作原理">整体工作原理&lt;/h3>
&lt;p>Filebeat 由两个主要组件组成：harvester 和 prospector。&lt;/p>
&lt;ul>
&lt;li>harvester (采集器) 的主要职责是读取单个文件的内容。读取每个文件，并将内容发送到 the output。 每个文件启动一个 harvester，harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态。如果文件在读取时被删除或重命名，Filebeat 将继续读取文件。&lt;/li>
&lt;li>prospector (查找器) 的主要职责是管理 harvester 并找到所有要读取的文件来源。如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个 harvester。每个 prospector 都在自己的 Go 协程中运行。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>注：Filebeat prospector只能读取本地文件， 没有功能可以连接到远程主机来读取存储的文件或日志。&lt;/em>&lt;/p>&lt;/blockquote>
&lt;p>由以上两个组件一起工作来读取文件（tail file）并将事件数据发送到指定的输出。
下图是 Filebeat 官方提供的架构图：
&lt;img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs20230109163928.png" alt="">&lt;/p>
&lt;h4 id="filebeat背后的老大">Filebeat背后的“老大”&lt;/h4>
&lt;p>说到Filebeat，它其实只是&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Felastic%2Fbeats%2Ftree%2Fmaster%2Flibbeat">beats家族&lt;/a>众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>beat&lt;/th>
 &lt;th>功能&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>Filebeat&lt;/td>
 &lt;td>收集日志文件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Metricbeat&lt;/td>
 &lt;td>收集各种指标数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Packetbeat&lt;/td>
 &lt;td>收集网络数据包&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Auditbeat&lt;/td>
 &lt;td>收集审计数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Heartbeat&lt;/td>
 &lt;td>收集服务运行状态监测数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&amp;hellip;&lt;/td>
 &lt;td>&amp;hellip;&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>如果你愿意的话，你也可以按照beat的规范来写自己的beat。
能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么&lt;/p></description></item><item><title>这些最常用的 Go CLI 命令，新手 Gopher 应该掌握</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 02 Jan 2023 10:28:19 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</guid><description>&lt;p>本文将介绍一些最基本的 Go 命令行命令。如果你刚接触 Go 语言，那你有必要记住它们，因为这些命令是 Go 开发者日常工作中所必备的。&lt;/p>
&lt;p>&lt;strong>Go version&lt;/strong>&lt;/p>
&lt;p>开始 Go 项目前，我们应该确保开发机上已经安装好了 Go 编译器。这可以通过 &lt;a href="https://go.dev/doc/install">https://go.dev/doc/install&lt;/a> 进行下载安装。&lt;/p>
&lt;p>通过执行以下命令可以查看安装的 Go 版本信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">go&lt;/span> version go1&lt;span style="color:#0000c0">.18&lt;/span> darwin&lt;span style="color:#00538b">/&lt;/span>amd64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Go env&lt;/strong>&lt;/p>
&lt;p>如果我们可能想查看一些 Go 相关的环境变量，例如 GOROOT 或者 GOPATH。你可以执行这个命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> env
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你想对某个环境变量进行更改，例如修改 Go 代理，你可以这样做。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> env &lt;span style="color:#00538b">-&lt;/span>w GOPROXY=https:&lt;span style="color:#505050">//goproxy.io,direct&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>go mod&lt;/strong>&lt;/p>
&lt;p>在你开始建立第一个 Go 程序时，在项目根目录下，你应该运行这样的命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> mod init &amp;lt;your project name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> mod init demo&lt;span style="color:#00538b">/&lt;/span>firstProject
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，项目根目录将增加 go.mod 文件，它的内容如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ cat &lt;span style="color:#5317ac">go&lt;/span>.mod 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>module demo&lt;span style="color:#00538b">/&lt;/span>firstProject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#0000c0">1.18&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你有其他语言的经验，那么 go.mod 类似于 Python 中的 requirements.txt，Java 中的 pom.xml，它用于管理项目的依赖包。&lt;/p></description></item><item><title>Golang-代码检查工具(golangci-lint)</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</link><pubDate>Thu, 22 Dec 2022 11:05:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</guid><description>&lt;h2 id="一介绍">一、介绍&lt;/h2>
&lt;p>&lt;code>golangci-lint&lt;/code> 是一个代码检查工具的集合，聚集了多种 Go 代码检查工具，如 &lt;code>golint&lt;/code>、&lt;code>go vet&lt;/code> 等。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>运行速度快&lt;/li>
&lt;li>可以集成到 vscode、goland 等开发工具中&lt;/li>
&lt;li>包含了非常多种代码检查器&lt;/li>
&lt;li>可以集成到 CI 中&lt;/li>
&lt;li>这是包含的代码检查器列表：Linters&lt;/li>
&lt;/ul>
&lt;h2 id="二安装">二、安装&lt;/h2>
&lt;p>&lt;code>golangci-lint&lt;/code> 官方不建议使用 &lt;code>go get&lt;/code> 方式安装，推荐使用二进制安装。&lt;/p>
&lt;h3 id="macos">MacOS&lt;/h3>
&lt;p>直接使用 homebrew 安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>brew install golangci-lint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew upgrade golangci-lint
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="linux-和-windows">Linux 和 Windows&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"># binary will be $(go env GOPATH)/bin/golangci-lint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sSfL https://raw.githubusercontent.com/Goci/golangci-lint/master/install.sh | sh -s -- -b &lt;span style="color:#5317ac">$(&lt;/span>go env GOPATH&lt;span style="color:#5317ac">)&lt;/span>/bin v1.42.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>golangci-lint --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>golangci-lint&lt;/code> 将会被安装到 &lt;strong>GOPATH/bin&lt;/strong> 目录中，如果此目录不在环境变量路径中需要加上。&lt;/p>
&lt;h2 id="三使用方式">三、使用方式&lt;/h2>
&lt;h3 id="命令行">命令行&lt;/h3>
&lt;p>在项目根目录下执行以下命令检查整个项目的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>golangci-lint run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其等价于:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>golangci-lint run ./...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者可以指定检查某个目录下的代码文件，指定目录时不会递归分析其子目录，要递归分析其子目录需要加上 /&amp;hellip;：&lt;/p></description></item><item><title>Golang-使用gvm进行版本控制</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</link><pubDate>Sun, 14 Aug 2022 18:00:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</guid><description>&lt;p>当你想为每个项目切换 go 版本时，gvm (Go Version Manager) 很方便。&lt;/p>
&lt;p>这里，我将介绍“如何在Mac上安装gvm”和“如何使用gvm”&lt;/p>
&lt;h2 id="使用准备">使用准备&lt;/h2>
&lt;h3 id="仅适用于-mac-的准备工作">仅适用于 Mac 的准备工作&lt;/h3>
&lt;p>按照MacOSX 要求中的说明执行以下命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>xcode-select --install
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install mercurial
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="gvm安装">gvm安装&lt;/h3>
&lt;p>我使用 zsh 作为我的 shell。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#8f0075">echo&lt;/span> &lt;span style="color:#00538b">$SHELL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/zsh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 zsh，您可以这样安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ zsh &amp;lt; &amp;lt;&lt;span style="color:#00538b">(&lt;/span>curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer&lt;span style="color:#00538b">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cloning from https://github.com/moovweb/gvm.git to /Users/user_name/.gvm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>No existing Go versions detected
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed GVM v1.0.22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please restart your terminal session or to get started right away run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">`&lt;/span>&lt;span style="color:#8f0075">source&lt;/span> /Users/user_name/.gvm/scripts/gvm&lt;span style="color:#2544bb">`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>~/.zshrc&lt;/code> 以下行被添加到最后一行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">[[&lt;/span> -s &lt;span style="color:#2544bb">&amp;#34;/Users/user_name/.gvm/scripts/gvm&amp;#34;&lt;/span> &lt;span style="color:#00538b">]]&lt;/span> &lt;span style="color:#00538b">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#8f0075">source&lt;/span> &lt;span style="color:#2544bb">&amp;#34;/Users/user_name/.gvm/scripts/gvm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新启动终端 gvm 即可使用&lt;/p></description></item><item><title>Golang-常见数据结构 Slice</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</link><pubDate>Sat, 30 Apr 2022 00:56:46 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</guid><description>&lt;h1 id="golang-常见数据结构slice">Golang-常见数据结构Slice&lt;/h1>
&lt;h2 id="slice">Slice&lt;/h2>
&lt;p>slice 翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。&lt;/p>
&lt;p>了解 slice 的本质, 最简单的方法就是看它的源码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// runtime/slice.go&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> slice &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> array unsafe.Pointer &lt;span style="color:#505050">// 元素指针&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len &lt;span style="color:#005a5f">int&lt;/span> &lt;span style="color:#505050">// 长度 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cap &lt;span style="color:#005a5f">int&lt;/span> &lt;span style="color:#505050">// 容量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>slice 共有三个属性:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>指针&lt;/strong> 指向底层数组&lt;/li>
&lt;li>&lt;strong>长度&lt;/strong> 表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度&lt;/li>
&lt;li>&lt;strong>容量&lt;/strong> 底层数组的元素个数，容量 &amp;gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/blog/202304191511106.png" alt="">&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>: 底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。&lt;/p>
&lt;h2 id="slice-创建">slice 创建&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>方式&lt;/th>
 &lt;th>代码示例&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>直接声明&lt;/td>
 &lt;td>var slice []int&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>new&lt;/td>
 &lt;td>slice := *new([]int)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>字面量&lt;/td>
 &lt;td>slice := []int{1,2,3,4}&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>make&lt;/td>
 &lt;td>slice := make(int[], 5, 10)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>从切片或者数组&amp;quot;截取&amp;quot;&lt;/td>
 &lt;td>slice := array[1:5] 或 slice := sourceSlice[1:5]&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>直接声明&lt;/strong>&lt;/p></description></item><item><title>Golang-常见数据结构 Map</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</link><pubDate>Mon, 11 Apr 2022 10:07:33 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</guid><description>&lt;h2 id="map">Map&lt;/h2>
&lt;p>map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。&lt;/p>
&lt;p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。&lt;/p>
&lt;h2 id="哈希表">哈希表&lt;/h2>
&lt;p>哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表， 有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。&lt;/p>
&lt;h2 id="设计原理">设计原理&lt;/h2>
&lt;p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 &lt;code>O(1)&lt;/code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。&lt;/p>
&lt;h3 id="哈希函数">哈希函数&lt;/h3>
&lt;p>实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。&lt;/p>
&lt;p>完美哈希函数如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111020765.png" alt="">&lt;/p>
&lt;p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。&lt;/p>
&lt;p>不均匀哈希函数如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111022378.png" alt="">&lt;/p>
&lt;p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。&lt;/p>
&lt;h3 id="冲突解决">冲突解决&lt;/h3>
&lt;p>哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。&lt;/p>
&lt;p>&lt;strong>开放寻址法&lt;/strong>
开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从索引开始遍历&lt;/p>
&lt;p>当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置
开放地址法写入数据如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111027414.png" alt="">
如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。&lt;/p>
&lt;p>开放地址法读取数据如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111029114.png" alt="">&lt;/p>
&lt;p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。&lt;/p>
&lt;p>开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。&lt;/p>
&lt;p>&lt;strong>拉链法&lt;/strong>&lt;/p>
&lt;p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。&lt;/p>
&lt;p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：
拉链法写入数据如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111030711.png" alt="">&lt;/p></description></item><item><title>Golang-channel通道</title><link>https://blog.ch3nnn.cn/posts/2022/golang-channel%E9%80%9A%E9%81%93/</link><pubDate>Sat, 19 Mar 2022 17:41:05 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-channel%E9%80%9A%E9%81%93/</guid><description>&lt;blockquote>
&lt;p>goroutine 和 channel (通道)并成为 Go 并发的两大基石。channel 可以放心地在多个 goroutine 之间使用, 因为它是并发安全的。&lt;/p>&lt;/blockquote>
&lt;h2 id="channel-有哪些应用">channel 有哪些应用&lt;/h2>
&lt;p>&lt;strong>停止信号&lt;/strong>
channel 用于停止信号的场景很多，通常是通过关闭某个channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作，如停止某个循环等。&lt;/p>
&lt;p>&lt;strong>定时任务&lt;/strong>
与计时器结合，一般有两种做法：实现超时控制、实现定期执行某个任务。
有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定。这就是时控制：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span> time.&lt;span style="color:#721045">After&lt;/span>(&lt;span style="color:#0000c0">100&lt;/span>&lt;span style="color:#00538b">*&lt;/span>time.Millisecond):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span> s.stopc:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。&lt;/p>
&lt;p>定时执行某个任务，也比较简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">worker&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ticker &lt;span style="color:#00538b">:=&lt;/span> time.&lt;span style="color:#721045">Tick&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span> ticker:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#505050">// 执行定时任务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;执行 1s 定时任务&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每隔 1 秒种，执行一次定时任务。&lt;/p>
&lt;p>&lt;strong>解耦生产方和消费方&lt;/strong>
服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行：&lt;/p></description></item><item><title>Golang-垃圾回收</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Fri, 18 Mar 2022 23:21:06 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>&lt;p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。&lt;/p>
&lt;h3 id="垃圾回收算法">垃圾回收算法&lt;/h3>
&lt;p>目前比较常见的垃圾回收算法有三种：
&lt;strong>引用计数&lt;/strong>：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。&lt;/p>
&lt;ul>
&lt;li>代表语言：Python、PHP、Swift&lt;/li>
&lt;li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。&lt;/li>
&lt;li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>标记-清除&lt;/strong>：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。&lt;/p>
&lt;ul>
&lt;li>代表语言：Golang（三色标记法）&lt;/li>
&lt;li>优点：解决了引用计数的缺点。&lt;/li>
&lt;li>缺点：需要 STW，暂时停掉程序运行。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>分代收集&lt;/strong>：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。&lt;/p>
&lt;ul>
&lt;li>代表语言：Java&lt;/li>
&lt;li>优点：回收性能好&lt;/li>
&lt;li>缺点：算法复杂&lt;/li>
&lt;/ul>
&lt;h3 id="golang-垃圾回收">Golang 垃圾回收&lt;/h3>
&lt;h4 id="go13之前-标记清除法">Go1.3之前 标记清除法&lt;/h4>
&lt;ol>
&lt;li>进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的内存占用和可达的内存占用&lt;/li>
&lt;li>开始标记，程序找出可达内存占用并做标记&lt;/li>
&lt;li>标记结束清除未标记的内存占用&lt;/li>
&lt;li>结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://s2.loli.net/2023/03/18/eaq4SfrMFOHYxVI.png" alt="">&lt;/p>
&lt;p>一开始的做法是将垃圾清理结束时才停止 STW，后来优化了方案将清理垃圾放到了 STW 之后，与程序运行同时进行，这样做减小了 STW 的时长。
但是 STW 会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的 STW 对于性能较高的程序还是无法接受，但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。
因此 Go1.5 采用了三色标记法优化了 STW。&lt;/p>
&lt;h4 id="go15之后-三色并发标记法">Go1.5之后 三色并发标记法&lt;/h4>
&lt;p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：&lt;/p>
&lt;p>灰色：对象还在标记队列中等待
黑色：对象已被标记，gcmarkBits对应位为 1 – 该对象不会在本次 GC 中被回收
白色：对象未被标记，gcmarkBits对应位为 0 – 该对象将会在本次 GC 中被清理&lt;/p></description></item><item><title>Golang-Modules的演进史</title><link>https://blog.ch3nnn.cn/posts/2022/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</link><pubDate>Sun, 13 Mar 2022 11:53:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid><description>&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。&lt;/p>
&lt;p>使用&lt;code> Go Modules&lt;/code> 模式，一般分为以下几个流程：&lt;/p>
&lt;ul>
&lt;li>&lt;code>go mod init&lt;/code> 创建一个新模块，初始化 &lt;code>go.mod&lt;/code> 文件。&lt;/li>
&lt;li>&lt;code>go build&lt;/code>、&lt;code>go test&lt;/code>、&lt;code>go run&lt;/code>、&lt;code>go install&lt;/code> 等构建命令，向 &lt;code>go.mod&lt;/code>文件中添加模块所需的依赖项。&lt;/li>
&lt;li>&lt;code>go list -m -json all&lt;/code> 打印当前模块的依赖项。&lt;/li>
&lt;li>&lt;code>go get&lt;/code> 添加依赖项，或修改依赖项版本。&lt;/li>
&lt;li>&lt;code>go mod tidy&lt;/code> 删除未使用的依赖项。&lt;/li>
&lt;/ul>
&lt;h2 id="go-modules-演进史">Go Modules 演进史&lt;/h2>
&lt;p>&lt;strong>Go v1.11&lt;/strong>
从 Go v1.11 开始支持 Go Moduls。
为了兼容使用 Go v1.11 之前的任意版本的项目，当设置 &lt;code>GO111MODULE=auto&lt;/code> 或 &lt;code>GO111MODULE=off&lt;/code> 时，Go v1.11 在 &lt;code>$GOPATH/src&lt;/code> 中，继续使用 &lt;code>GOPATH&lt;/code> 模式。
当设置 &lt;code>GO111MODULE=auto&lt;/code> 时，其它任意位置，如果当前目录或父目录包含 go.mod 文件，则使用 Modules 模式。&lt;/p></description></item><item><title>Golang-逃逸分析</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link><pubDate>Mon, 07 Mar 2022 13:38:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid><description>&lt;h3 id="什么是堆栈">什么是堆/栈&lt;/h3>
&lt;ul>
&lt;li>堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多&lt;/li>
&lt;li>栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上&lt;/li>
&lt;/ul>
&lt;h3 id="什么是逃逸分析">什么是逃逸分析&lt;/h3>
&lt;p>我们如何知道一个对象是应该放在堆内存，还是栈内存之上呢？可以官网的FAQ（地址：&lt;a href="https://go.dev/doc/faq#stack_or_heap">https://go.dev/doc/faq#stack_or_heap&lt;/a>）中找到答案.
&lt;img src="https://s2.loli.net/2023/03/07/5xzbUkInvQrVpDu.png" alt="">&lt;/p>
&lt;p>大致意思是:&lt;/p>
&lt;blockquote>
&lt;p>从正确性的角度来看，你不需要知道。Go中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。
存储位置确实对编写高效的程序有影响。如果可能的话，Go编译器将为该函数的堆栈帧中的函数分配局部变量。但是，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在有垃圾回收的堆上分配该变量，以避免悬空指针错误。此外，如果局部变量非常大，那么将其存储在堆中可能比存储在栈中更有意义。
在当前编译器中，如果变量的地址被占用，那么该变量就是堆上分配内存的候选变量。然而，基本的逃逸分析可以识别出某些情况下，这些变量将不会存在于函数返回之后，而可以驻留在栈中。&lt;/p>&lt;/blockquote>
&lt;h3 id="在什么阶段确立逃逸">在什么阶段确立逃逸&lt;/h3>
&lt;p>Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的。&lt;/p>
&lt;ul>
&lt;li>逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析&lt;/li>
&lt;li>如果变量在函数外部没有引用，则优先放到栈中&lt;/li>
&lt;li>如果变量在函数外部存在引用，则必定放在堆中&lt;/li>
&lt;/ul>
&lt;h3 id="逃逸规则">逃逸规则&lt;/h3>
&lt;p>我们其实都知道一个普遍的规则，就是如果变量需要使用堆空间，那么他就应该进行逃逸。但是实际上Golang并不仅仅把逃逸的规则如此泛泛。Golang会有很多场景具备出现逃逸的现象。&lt;/p>
&lt;p>一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。&lt;/p>
&lt;p>Go语言中的引用类型有&lt;code>func&lt;/code>（函数类型），&lt;code>interface&lt;/code>（接口类型），&lt;code>slice&lt;/code>（切片类型），&lt;code>map&lt;/code>（字典类型），&lt;code>channel&lt;/code>（管道类型），&lt;code>*&lt;/code>（指针类型）等。&lt;/p>
&lt;h3 id="怎么确定是否逃逸">怎么确定是否逃逸&lt;/h3>
&lt;p>可以使用编译器提供的指令&lt;code>-gcflags&lt;/code> 就可以看到详细的逃逸分析过程，命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go build -gcflags &lt;span style="color:#2544bb">&amp;#39;-m -l&amp;#39;&lt;/span> main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其指令涉及的参数如下：&lt;/p>
&lt;ul>
&lt;li>-m：打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是这样子调试的信息量较大，一般用一个就足够了。&lt;/li>
&lt;li>-l ：禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。&lt;/li>
&lt;/ul>
&lt;h3 id="常见逃逸案例分析">常见逃逸案例分析&lt;/h3>
&lt;p>&lt;strong>new的变量在栈还是堆&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">foo&lt;/span>(argVal &lt;span style="color:#005a5f">int&lt;/span>) (&lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#005a5f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal1 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal2 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal3 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal4 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal5 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//此处循环是防止go编译器将foo优化成inline(内联函数)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//如果是内联函数，main调用foo将是原地展开，所以fooVal 1-5 相当于main作用域的变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//即使fooVal3发生逃逸，地址与其他也是连续的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">5&lt;/span>; i&lt;span style="color:#00538b">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">println&lt;/span>(argVal, fooVal1, fooVal2, fooVal3, fooVal4, fooVal5)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//fooVal3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> fooVal3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainVal &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#721045">foo&lt;/span>(&lt;span style="color:#0000c0">666&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">println&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>mainVal, mainVal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将fooVal 1-5 全部用&lt;code>new&lt;/code>的方式来开辟, 编译运行看结果, 显然&lt;code>fooVal3&lt;/code>发生了逃逸&lt;/p></description></item><item><title>Golang-GMP模型</title><link>https://blog.ch3nnn.cn/posts/2022/golang-gmp%E6%A8%A1%E5%9E%8B/</link><pubDate>Wed, 02 Mar 2022 16:45:39 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-gmp%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h3 id="写在前面">写在前面&lt;/h3>
&lt;p>Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下面通过一段简单的代码展示一下 Go 应用程序在运行时的 goroutine，方便大家更好的理解。&lt;/p>
&lt;blockquote>
&lt;p>The Go scheduler is part of the Go runtime, and the Go runtime is built into your application&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">4&lt;/span>; i&lt;span style="color:#00538b">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#5317ac">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.&lt;span style="color:#721045">Sleep&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(runtime.&lt;span style="color:#721045">NumGoroutine&lt;/span>())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这段代码的输出为：&lt;code>5&lt;/code> 说明当前这个应用程序中存在 &lt;code>goroutine&lt;/code> 的数量是 &lt;code>5&lt;/code>，事实上也符合我们的预期。那么问题来了，这 5 个 goroutine 作为操作系统用户态的基本调度单元是无法直接占用操作系统的资源来执行的，必须经过内核级线程的分发，这是操作系统内部线程调度的基本模型，根据用户级线程和内核级线程的对应关系可以分为 1 对 1，N 对 1 以及 M 对 N 这三种模型，那么上述的 5 个 goroutine 在内核级线程上是怎么被分发的，这就是 Go语言的 goroutine 调度器决定的。&lt;/p></description></item><item><title>Golang-数组与切片常见错误及陷阱</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</link><pubDate>Tue, 15 Feb 2022 16:34:35 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</guid><description>&lt;h2 id="nil切片空切片零切片">nil切片、空切片、零切片&lt;/h2>
&lt;p>&lt;strong>零切片&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s = &lt;span style="color:#8f0075">make&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>, &lt;span style="color:#0000c0">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示底层数组的二进制内容都是零&lt;/p>
&lt;p>&lt;strong>「空切片」和 「nil 切片」&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s1 []&lt;span style="color:#005a5f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s2 = []&lt;span style="color:#005a5f">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s3 = &lt;span style="color:#8f0075">make&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>, &lt;span style="color:#0000c0">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// new 函数返回是指针类型，所以需要使用 * 号来解引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s4 = &lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#8f0075">new&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#8f0075">len&lt;/span>(s1), &lt;span style="color:#8f0075">len&lt;/span>(s2), &lt;span style="color:#8f0075">len&lt;/span>(s3), &lt;span style="color:#8f0075">len&lt;/span>(s4))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#8f0075">cap&lt;/span>(s1), &lt;span style="color:#8f0075">cap&lt;/span>(s2), &lt;span style="color:#8f0075">cap&lt;/span>(s3), &lt;span style="color:#8f0075">cap&lt;/span>(s4))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(s1, s2, s3, s4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">----------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[] [] [] []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这四种形式从输出结果上来看，似乎一摸一样，没区别。但是实际上是有区别的，我们要讲的两种特殊类型「空切片」和「 nil 切片」，就隐藏在上面的四种形式之中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s1 []&lt;span style="color:#005a5f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s2 = []&lt;span style="color:#005a5f">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s3 = &lt;span style="color:#8f0075">make&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>, &lt;span style="color:#0000c0">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s4 = &lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#8f0075">new&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a1 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a2 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s2))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a3 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s3))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a4 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s4))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">---------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">824634199592&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">824634199592&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中输出为 [0 0 0] 的 s1 和 s4 变量就是「 nil 切片」，s2 和 s3 变量就是「空切片」。824634199592 这个值是一个特殊的内存地址，所有类型的「空切片」都共享这一个内存地址。&lt;/p></description></item><item><title>Golang-代码断行规则</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</link><pubDate>Wed, 02 Feb 2022 16:37:59 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</guid><description>&lt;p>如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。&lt;/p>
&lt;h2 id="分号插入规则">分号插入规则&lt;/h2>
&lt;p>我们在Go编程中常遵循的一个规则是：一个显式代码块的起始左大括号{不放在下一行。 比如，下面这个for循环代码块编译将失败。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; i &amp;gt; &lt;span style="color:#0000c0">0&lt;/span>; i&lt;span style="color:#00538b">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#505050">// error: 未预料到的新行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了让上面这个for循环代码块编译成功，我们不能在起始左大括号{前断行，而应该像下面这样进行修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; i &amp;gt; &lt;span style="color:#0000c0">0&lt;/span>; i&lt;span style="color:#00538b">--&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，有时候起始左大括号{却可以放在一个新行上，比如下面这个for循环代编译时没有问题的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// do something ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，Go代码中的根本性换行规则究竟是如何定义的呢？ 在回答这个问题之前，我们应该知道一个事实：正式的Go语法是使用（英文）分号;做为结尾标识符的。 但是，我们很少在Go代码中使用和看到分号。为什么呢？原因是大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。&lt;/p>
&lt;p>比如，下面这个程序中的十个分号都是可以被省略掉的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> &lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i &lt;span style="color:#005a5f">int&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		sum &lt;span style="color:#005a5f">int&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> i &amp;lt; &lt;span style="color:#0000c0">6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		sum &lt;span style="color:#00538b">+=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i&lt;span style="color:#00538b">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设上面这个程序存储在一个semicolons.go文件中，我们可以运行go fmt semicolons.go将此程序中的不必要的分号去除掉。 在编译时刻，编译器会自动此插入这些去除掉的分号（至此文件的内存中的版本）。&lt;/p>
&lt;p>自动插入分号的规则是什么呢？Go白皮书这样描述：&lt;/p></description></item><item><title>Golang-停止Goroutine有几种方法</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 12 Jan 2022 18:23:23 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>&lt;h3 id="goroutine介绍">goroutine介绍&lt;/h3>
&lt;p>goroutine 是 Go 语言实现并发编程的利器，是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理，简单的一个指令go function就能启动一个 goroutine；Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。&lt;/p>
&lt;p>但是，Go语言并没有提供终止goroutine的接口，也就是说，我们不能从外部去停止一个goroutine，只能由goroutine内部退出(main函数终止除外)；&lt;/p>
&lt;h3 id="goroutine-案例">goroutine 案例&lt;/h3>
&lt;p>日常开发开启一个 goroutine go代码, 只需一个 go 关键字即可:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> wg sync.WaitGroup &lt;span style="color:#505050">// 等待组，用来阻塞程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Add&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span>) &lt;span style="color:#505050">// 等待组 +1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#5317ac">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;开启 goroutine&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="几种停止的办法">几种停止的办法&lt;/h3>
&lt;p>Go 目前用 channel 或 context 的方式来取消 (cancelation) 给 goroutine。&lt;/p>
&lt;h4 id="channel">Channel&lt;/h4>
&lt;ul>
&lt;li>第一种方法，就是借助 channel 的 close 机制来完成对 goroutine 的精确控制。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	msg &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#8f0075">make&lt;/span>(&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#5317ac">struct&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#5317ac">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;[go-routine] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span>msg:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;[go-routine] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#505050">// 必须 return, 否则 goroutine 不会结束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;close channel&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#8f0075">close&lt;/span>(msg) &lt;span style="color:#505050">// 直接关闭通道 程序结束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第二种方法，通过定期轮训 channel 其结合了第一种方法和类似信号量的处理方式。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> wg sync.WaitGroup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">worker&lt;/span>(in, quit &lt;span style="color:#00538b">&amp;lt;-&lt;/span>&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#005a5f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">defer&lt;/span> wg.&lt;span style="color:#721045">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span>quit:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;收到退出信号&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#505050">//必须return，否则goroutine不会结束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> v &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span>in:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	quit &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#8f0075">make&lt;/span>(&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#005a5f">int&lt;/span>) &lt;span style="color:#505050">//退出通道&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	in &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#8f0075">make&lt;/span>(&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Add&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#721045">worker&lt;/span>(in, quit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">3&lt;/span>; i&lt;span style="color:#00538b">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		in &lt;span style="color:#00538b">&amp;lt;-&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	quit &lt;span style="color:#00538b">&amp;lt;-&lt;/span> &lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#505050">//想通道写入退出信号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="context">Context&lt;/h4>
&lt;p>Go 语言的上下文（context）来做 goroutine 的控制和关闭, 对于是一种 tree 结构的goroutine, 要停止 sub tree 使用 channel 的方式不太方便&lt;/p></description></item><item><title>Golang-值传递还是引用传递</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link><pubDate>Sun, 09 Jan 2022 18:09:14 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid><description>&lt;h2 id="go-官方的定义">Go 官方的定义&lt;/h2>
&lt;p>本部分引用 Go 官方 FAQ 的 “When are function parameters passed by value?”，内容如下。&lt;/p>
&lt;p>如同 C 系列的所有语言一样，Go 语言中的所有东西都是以值传递的。也就是说，一个函数总是得到一个被传递的东西的副本，就像有一个赋值语句将值赋给参数一样。&lt;/p>
&lt;h2 id="传值和传引用">传值和传引用&lt;/h2>
&lt;h3 id="什么是传值值传递">什么是传值（值传递）&lt;/h3>
&lt;p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。&lt;strong>其指的是在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。&lt;/strong> 比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。&lt;/p>
&lt;p>对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。&lt;/p>
&lt;p>test_demo.go&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">modify&lt;/span>(ip &lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#005a5f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;函数里接收到的指针的内存地址是：%p\n&amp;#34;&lt;/span>, &lt;span style="color:#00538b">&amp;amp;&lt;/span>ip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#00538b">*&lt;/span>ip = &lt;span style="color:#0000c0">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">TestDemo&lt;/span>(t &lt;span style="color:#00538b">*&lt;/span>testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ip &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#00538b">&amp;amp;&lt;/span>i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;原始指针的内存地址是：%p\n&amp;#34;&lt;/span>, &lt;span style="color:#00538b">&amp;amp;&lt;/span>ip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#721045">modify&lt;/span>(ip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;int值被修改了，新值为:&amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>原始指针的内存地址是：0xc00000e038
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>函数里接收到的指针的内存地址是：0xc00000e040
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int值被修改了，新值为: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="什么是传引用引用传递">什么是传引用(引用传递)&lt;/h3>
&lt;p>传引用，也叫做引用传递， &lt;strong>指在调用函数时将实际参数的地址直接传递到函数中&lt;/strong>，那么在函数中对参数所进行的修改，将影响到实际参数。&lt;/p>
&lt;p>在 Go 语言中，官方已经明确了没有传引用，也就是没有引用传递这一情况。&lt;/p>
&lt;p>&lt;strong>争议最大的 map 和 slice&lt;/strong>
这时候又有小伙伴疑惑了，你看 Go 语言中的 map 和 slice 类型，能直接修改，难道不是同个内存地址，不是引用了？&lt;/p></description></item></channel></rss>