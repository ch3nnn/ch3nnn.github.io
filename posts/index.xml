<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Ch3nnn!Blog</title><link>https://blog.ch3nnn.cn/posts/</link><description>Recent content in Posts on Ch3nnn!Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 27 Aug 2024 00:51:35 +0800</lastBuildDate><atom:link href="https://blog.ch3nnn.cn/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Gorm 分表中间件(Sharding)</title><link>https://blog.ch3nnn.cn/posts/2024/gorm-%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><pubDate>Tue, 27 Aug 2024 00:51:35 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/gorm-%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://github.com/go-gorm/sharding">Sharding&lt;/a> 是一个高性能的 Gorm 分表中间件。它基于 Conn 层做 SQL 拦截、AST 解析、分表路由、自增主键填充，带来的额外开销极小。对开发者友好、透明，使用上与普通
SQL、Gorm 查询无差别，只需要额外注意一下分表键条件。 为您提供高性能的数据库访问&lt;/p>
&lt;/blockquote>
&lt;h2 id="一功能特点">一、功能特点&lt;/h2>
&lt;ul>
&lt;li>非侵入式设计， 加载插件，指定配置，既可实现分表。&lt;/li>
&lt;li>轻快， 非基于网络层的中间件，像 Go 一样快&lt;/li>
&lt;li>支持多种数据库。 PostgreSQL 已通过测试，MySQL 和 SQLite 也在路上。&lt;/li>
&lt;li>多种主键生成方式支持（Snowflake, PostgreSQL Sequence, 以及自定义支持）Snowflake 支持从主键中确定分表键。&lt;/li>
&lt;/ul>
&lt;h2 id="二示例代码">二、示例代码&lt;/h2>
&lt;p>注意: 依然保持原来的方式使用 db 来查询数据库。 你只需要注意在 CURD 动作的时候，明确知道 &lt;strong>Sharding Key&lt;/strong> 对应的分表，&lt;strong>查询条件带 Sharding Key，以确保
Sharding 能理解数据需要对应到哪一个子表&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;h3 id="mysql">Mysql&lt;/h3>
&lt;p>Gorm Sharding 中内置了 MySQL 序列主键实现，只需配置PrimaryKeyGenerator: sharding.PKMySQLSequence即可使用。&lt;/p>
&lt;p>您不需要手动创建序列，当 MySQL 序列不存在时，Gorm Sharding 会检查并创建。&lt;/p>
&lt;p>这个序列名后面跟着gorm_sharding_${table_name}_id_seq，例如orders表，序列名就是gorm_sharding_orders_id_seq。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"> * @Author: chentong
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"> * @Date: 2024/08/27 00:09
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;gorm.io/driver/mysql&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;gorm.io/gorm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;gorm.io/sharding&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> Order &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ID &lt;span style="color:#005a5f">int64&lt;/span> &lt;span style="color:#2544bb">`gorm:&amp;#34;primarykey&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserID &lt;span style="color:#005a5f">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProductID &lt;span style="color:#005a5f">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">TestSharding_Mysql&lt;/span>(t &lt;span style="color:#00538b">*&lt;/span>testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dsn &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;root:123456@tcp(localhost:3306)/dev?parseTime=True&amp;amp;timeout=5s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db, err &lt;span style="color:#00538b">:=&lt;/span> gorm.&lt;span style="color:#721045">Open&lt;/span>(mysql.&lt;span style="color:#721045">Open&lt;/span>(dsn))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">panic&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">2&lt;/span>; i &lt;span style="color:#00538b">+=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> table &lt;span style="color:#00538b">:=&lt;/span> fmt.&lt;span style="color:#721045">Sprintf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;orders_%d&amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">`DROP TABLE IF EXISTS `&lt;/span> &lt;span style="color:#00538b">+&lt;/span> table)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;CREATE TABLE &amp;#34;&lt;/span> &lt;span style="color:#00538b">+&lt;/span> table &lt;span style="color:#00538b">+&lt;/span> &lt;span style="color:#2544bb">&amp;#34; ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `product_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#721045">Use&lt;/span>(sharding.&lt;span style="color:#721045">Register&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharding.Config{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ShardingKey: &lt;span style="color:#2544bb">&amp;#34;user_id&amp;#34;&lt;/span>, &lt;span style="color:#505050">// 分片key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> NumberOfShards: &lt;span style="color:#0000c0">2&lt;/span>, &lt;span style="color:#505050">// 分片数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> PrimaryKeyGenerator: sharding.PKMySQLSequence, &lt;span style="color:#505050">// 主键生成器, 这里使用 mysql
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> []&lt;span style="color:#005a5f">string&lt;/span>{&lt;span style="color:#2544bb">&amp;#34;orders&amp;#34;&lt;/span>}, &lt;span style="color:#505050">// 需要分片 tables 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> ))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this record will insert to orders_02
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> err = db.&lt;span style="color:#721045">Create&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>Order{UserID: &lt;span style="color:#0000c0">2&lt;/span>}).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this record will insert to orders_03
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;INSERT INTO orders(user_id) VALUES(?)&amp;#34;&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">3&lt;/span>)).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this will throw ErrMissingShardingKey error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;INSERT INTO orders(product_id) VALUES(1)&amp;#34;&lt;/span>).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this will redirect query to orders_02
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">var&lt;/span> orders []Order
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = db.&lt;span style="color:#721045">Model&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>Order{}).&lt;span style="color:#721045">Where&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;user_id&amp;#34;&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">2&lt;/span>)).&lt;span style="color:#721045">Find&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>orders).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;%#v\n&amp;#34;&lt;/span>, orders)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// Raw SQL also supported
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> db.&lt;span style="color:#721045">Raw&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;SELECT * FROM orders WHERE user_id = ?&amp;#34;&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">3&lt;/span>)).&lt;span style="color:#721045">Scan&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>orders)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;%#v\n&amp;#34;&lt;/span>, orders)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// this will throw ErrMissingShardingKey error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> err = db.&lt;span style="color:#721045">Model&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>Order{}).&lt;span style="color:#721045">Where&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;product_id&amp;#34;&lt;/span>, &lt;span style="color:#2544bb">&amp;#34;1&amp;#34;&lt;/span>).&lt;span style="color:#721045">Find&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>orders).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// Update and Delete are similar to create and query
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;UPDATE orders SET product_id = ? WHERE user_id = ?&amp;#34;&lt;/span>, &lt;span style="color:#0000c0">2&lt;/span>, &lt;span style="color:#8f0075">int64&lt;/span>(&lt;span style="color:#0000c0">3&lt;/span>)).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err) &lt;span style="color:#505050">// nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> err = db.&lt;span style="color:#721045">Exec&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;DELETE FROM orders WHERE product_id = 3&amp;#34;&lt;/span>).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#721045">Println&lt;/span>(err) &lt;span style="color:#505050">// ErrMissingShardingKey
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>动手不求人，记录一次 Mac Pro 拆机清灰</title><link>https://blog.ch3nnn.cn/posts/2024/%E5%8A%A8%E6%89%8B%E4%B8%8D%E6%B1%82%E4%BA%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1macpro%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/</link><pubDate>Sat, 27 Apr 2024 23:28:09 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/%E5%8A%A8%E6%89%8B%E4%B8%8D%E6%B1%82%E4%BA%BA%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1macpro%E6%8B%86%E6%9C%BA%E6%B8%85%E7%81%B0/</guid><description>&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>自从换了新的吃饭家伙后(M3 Pro 女朋友送的!啊哈哈~)，老的 Mac Pro 退役后其实也没停下来，偶尔会用它搬砖调试。在使用过程中风扇的噪音变得非常大，整个键盘区域非常长烫手。
仔细一算，这台家伙从18年到23年也已经快陪我走过了5年，但是一次拆机清灰都还没有过，于是找好了工具准备大干一场(其实是第三方清灰太贵了)。&lt;/p>
&lt;h2 id="二准备工具">二、准备工具&lt;/h2>
&lt;p>本以为我觉得很简单的，在淘宝搜了一下 &amp;ldquo;Mac 拆机螺丝刀&amp;quot;随便买了一套工具(找的价格最低的)。等拿到工具时居然所有螺丝刀头都不匹配，当时心情直接裂开。本想大展身手的这下好了螺丝刀白买(12 合一螺丝刀)。
&lt;img src="https://s2.loli.net/2024/04/28/ysjv69PqG8HaV7l.png" alt="">&lt;/p>
&lt;p>只能怪自己没有提前做好功课， Mac 底部需要五角梅花螺丝刀才能拧开。这次做好功课选好工具，重新购买:&lt;/p>
&lt;ul>
&lt;li>梅花 T4 (电池处螺丝)&lt;/li>
&lt;li>五星 P5 (后盖螺丝)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://s2.loli.net/2024/04/28/BXsjM59xA27HuGO.png" alt="">&lt;/p>
&lt;h2 id="三拆机大干一场">三、拆机(大干一场!)&lt;/h2>
&lt;p>拆机过程其实非常简单，只需要把底部六个梅花螺丝拧开就可以轻松打开后盖。看到内部所有零件确实挺震撼，佩服苹果一贯的简约风格(秩序感)，从来没见过这么整齐的内部排布。
(请忽视主板和电池表面浮灰，确实没清理过一次。5 年下来其实没有太脏，个人感觉)&lt;/p>
&lt;p>注: &lt;strong>记得断开电池排线&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2024/04/28/iWHldMhrCKgV7IG.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2024/04/28/EVFPeYr58nkMISo.png" alt="">&lt;/p>
&lt;h2 id="四清理工作">四、清理工作&lt;/h2>
&lt;p>对于更深度的拆机操作没有太敢做(拆除主板、CPU、风扇)。只是把内部、风扇和排风口灰尘毛屑清理干净。内部、风扇拿刷子和吹风机进行清理，排风口用镊子把毛屑夹出，
总体难度不是太大。顺带将买来的硅脂条也贴在热管后，提高一下散热。
&lt;img src="https://s2.loli.net/2024/04/28/HwpW5KJ4Lc2n6Qf.png" alt="">&lt;/p>
&lt;h2 id="五完美收工">五、完美收工&lt;/h2>
&lt;p>这下应该整体机温可以下降 1 到 2 度了吧。其实整体拆机清灰难度不大，最主要是前期想当然了螺丝刀工具买错耽误几天时间，清理完成并没有出现主板短路、开不了机情况。总的来说算是比较不错。&lt;/p></description></item><item><title>Go 1.22的新功能 Cmp.Or</title><link>https://blog.ch3nnn.cn/posts/2024/go-1.22%E6%96%B0%E5%8A%9F%E8%83%BD-cmp.or/</link><pubDate>Sat, 27 Apr 2024 22:45:54 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/go-1.22%E6%96%B0%E5%8A%9F%E8%83%BD-cmp.or/</guid><description>&lt;h2 id="一介绍">一、介绍&lt;/h2>
&lt;p>&lt;a href="https://go.dev/doc/go1.22">截至撰写本文时， Go 1.22&lt;/a>已经发布几个月了。&lt;/p>
&lt;p>Go 1.22提出并实现的最终函数是&lt;code>cmp.Or&lt;/code>。&lt;/p>
&lt;p>首先我们看一下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Or returns the first of its arguments that is not equal to the zero value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// If no argument is non-zero, it returns the zero value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">func&lt;/span> Or[T comparable](vals &lt;span style="color:#00538b">...&lt;/span>T) T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">var&lt;/span> zero T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> _, val &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#5317ac">range&lt;/span> vals {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">if&lt;/span> val &lt;span style="color:#00538b">!=&lt;/span> zero {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#5317ac">return&lt;/span> val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">return&lt;/span> zero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>它非常简短。它只是比较其参数并返回第一个不是 &lt;code>0&lt;/code> or &lt;code>nil&lt;/code> or &lt;code>&amp;quot;&amp;quot;&lt;/code> 或&lt;strong>其类型的零值&lt;/strong>的参数。&lt;/p>
&lt;/blockquote>
&lt;h2 id="二如何使用它">二、如何使用它?&lt;/h2>
&lt;p>主要用途&lt;code>cmp.Or&lt;/code>是获取数字并返回第一个非0数字。例如，一个 API 获取列表页中的 &lt;code>page&lt;/code> 和 &lt;code>pageSize&lt;/code>参数值, 给一些默认值。&lt;/p></description></item><item><title>Go Sync并发包之errgroup</title><link>https://blog.ch3nnn.cn/posts/2024/go-sync%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8Berrgroup/</link><pubDate>Wed, 24 Apr 2024 10:44:21 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/go-sync%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8Berrgroup/</guid><description>&lt;p>你是否写过一个函数，它之所以很长，是因为它要完成很多任务，即使这些任务之间并不相互依赖？ 你是否写过一个很长的函数，因为它要完成很多任务，即使这些任务并不相互依赖？我就遇到过这种情况。&lt;/p>
&lt;p>想想看，你有一个函数可以做 3 件事：&lt;/p>
&lt;ul>
&lt;li>按用户 ID 从数据库中获取用户详细信息。&lt;/li>
&lt;li>调用外部服务，按用户 ID 获取用户最近的活动信息&lt;/li>
&lt;li>访问日志服务，按用户 ID 获取用户上次登录的详细信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">FetchUserData&lt;/span>(userID &lt;span style="color:#005a5f">string&lt;/span>) &lt;span style="color:#005a5f">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g &lt;span style="color:#00538b">:=&lt;/span> errgroup.Group{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// 获取用户详细信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> userDetail, _ &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#721045">fetchUserDetails&lt;/span>(userID)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// 获取用户活动
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> userAct, _ &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#721045">fetchUserActivity&lt;/span>(userID)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// 获取用户登录详细信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> userLoginInfo, _ &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#721045">fetchUserLoginDetails&lt;/span>(userID)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有这些任务都只需要用户 ID，而不使用其他任务的数据。&lt;/p>
&lt;p>您可以尝试使用 goroutines 来实现这一点，但您需要自己处理细节问题。让我们来回答这些问题：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>同步&lt;/strong>：如何确保一切完成？&lt;/li>
&lt;li>&lt;strong>错误处理&lt;/strong>：如果一项任务出错，你该怎么办？或者三项任务中有两项不成功？&lt;/li>
&lt;li>&lt;strong>取消&lt;/strong>：如果一个任务出现问题，如何停止所有其他正在运行的程序？&lt;/li>
&lt;li>&lt;strong>限制&lt;/strong>：你是否考虑过限制同时运行多少个 goroutines？&lt;/li>
&lt;li>&lt;strong>可重复使用&lt;/strong>：一旦找到解决方案，如何在类似情况下再次使用？&lt;/li>
&lt;/ul>
&lt;h2 id="1什么是-errgroup">1.什么是 errgroup？&lt;/h2>
&lt;blockquote>
&lt;p>errgroup 软件包可让您同时处理多项任务。&lt;/p>
&lt;/blockquote>
&lt;p>通过它，可以轻松地以安全的方式一起运行，保持同步，处理错误，并控制何时停止 goroutines。下面是一个如何使用它的快速示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">FetchUserData&lt;/span>() &lt;span style="color:#005a5f">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	g &lt;span style="color:#00538b">:=&lt;/span> errgroup.Group{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// 获取用户详细信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	g.&lt;span style="color:#721045">Go&lt;/span>(&lt;span style="color:#5317ac">func&lt;/span>() &lt;span style="color:#005a5f">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Fetched user details...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// 获取用户活动
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> g.&lt;span style="color:#721045">Go&lt;/span>(&lt;span style="color:#5317ac">func&lt;/span>() &lt;span style="color:#005a5f">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Fetched user activity...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// 获取用户登录详细信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	g.&lt;span style="color:#721045">Go&lt;/span>(&lt;span style="color:#5317ac">func&lt;/span>() &lt;span style="color:#005a5f">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">2&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Fetched user login details...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// 等待所有goroutines完成并返回第一个错误 (如果有)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	&lt;span style="color:#5317ac">return&lt;/span> g.&lt;span style="color:#721045">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因此，errgroup 的工作就是运行这些任务，并通过 &lt;code>g.Wait()&lt;/code> 等待任务结束，我们需要做的就是添加任务。
&lt;img src="https://s2.loli.net/2024/04/24/GMLih1vYBzDbWsO.png" alt="什么是 errgroup？">&lt;/p></description></item><item><title>使用 go-elasticsearch v8 请求示例</title><link>https://blog.ch3nnn.cn/posts/2024/%E4%BD%BF%E7%94%A8go-elasticsearch-v8%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/</link><pubDate>Tue, 19 Mar 2024 23:07:33 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/%E4%BD%BF%E7%94%A8go-elasticsearch-v8%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/</guid><description>&lt;h2 id="一简介">一、简介&lt;/h2>
&lt;p>&lt;a href="https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/getting-started-go.html">你可以通过参考Go 官方文档&lt;/a>找到简单的示例，所以我认为先看看这个是个好主意。&lt;/p>
&lt;p>连接客户端有两种方式&lt;/p>
&lt;p>至于两者的特点，TypedClient 有类型，更容易编写，但文档较少。另外，批量索引不支持TypedClient。由于普通客户端都是基于json的，所以我觉得从文档转换到代码还是比较容易的。&lt;/p>
&lt;p>我的建议基本上是使用 TypedClient！
虽然文档很稀疏，但它是基于规律性的类型化的，所以你越习惯它（特别是当涉及到有很多变化的东西时，比如查询），从 json 转换为类型化代码就越容易。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// client
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> es, err &lt;span style="color:#00538b">:=&lt;/span> elasticsearch.&lt;span style="color:#721045">NewClient&lt;/span>(elasticsearch.Config{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Addresses: []&lt;span style="color:#005a5f">string&lt;/span>{&lt;span style="color:#2544bb">&amp;#34;http://localhost:9200&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#721045">Fatalf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Error creating the client: %s&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// typed client
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> es, err &lt;span style="color:#00538b">:=&lt;/span> elasticsearch.&lt;span style="color:#721045">NewTypedClient&lt;/span>(elasticsearch.Config{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Addresses: []&lt;span style="color:#005a5f">string&lt;/span>{&lt;span style="color:#2544bb">&amp;#34;http://localhost:9200&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#721045">Fatalf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Error creating the client: %s&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="二index-createdelete">二、Index Create/Delete&lt;/h2>
&lt;p>关于索引创建，Go官方文档中有一个示例，所以我简单介绍一下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	es, err &lt;span style="color:#00538b">:=&lt;/span> elasticsearch.&lt;span style="color:#721045">NewTypedClient&lt;/span>(elasticsearch.Config{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Addresses: []&lt;span style="color:#005a5f">string&lt;/span>{&lt;span style="color:#2544bb">&amp;#34;http://localhost:9200&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		log.&lt;span style="color:#721045">Fatalf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Error creating the client: %s&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ignoreAbove &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">256&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	keywordProperty &lt;span style="color:#00538b">:=&lt;/span> types.&lt;span style="color:#721045">NewKeywordProperty&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	keywordProperty.IgnoreAbove = &lt;span style="color:#00538b">&amp;amp;&lt;/span>ignoreAbove
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	dateProperty &lt;span style="color:#00538b">:=&lt;/span> types.&lt;span style="color:#721045">NewDateProperty&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	format &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;yyyy/MM/dd||yyyy/MM||MM/dd||yyyy||MM||dd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	dateProperty.Format = &lt;span style="color:#00538b">&amp;amp;&lt;/span>format
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// index作成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	_, err = es.Indices.&lt;span style="color:#721045">Create&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;sample_index&amp;#34;&lt;/span>).&lt;span style="color:#721045">Request&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>create.Request{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Settings: &lt;span style="color:#00538b">&amp;amp;&lt;/span>types.IndexSettings{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			IndexSettings: &lt;span style="color:#5317ac">map&lt;/span>[&lt;span style="color:#005a5f">string&lt;/span>]json.RawMessage{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#505050">// 設定項目
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>				&lt;span style="color:#505050">// bulk index里面的数据更新感觉。如果不需要频繁更新，设置得更长会提高性能。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>				&lt;span style="color:#2544bb">&amp;#34;refresh_interval&amp;#34;&lt;/span>: json.&lt;span style="color:#721045">RawMessage&lt;/span>(&lt;span style="color:#2544bb">`&amp;#34;30s&amp;#34;`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#505050">// 可取得的最大件数的上限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>				&lt;span style="color:#2544bb">&amp;#34;max_result_window&amp;#34;&lt;/span>: json.&lt;span style="color:#721045">RawMessage&lt;/span>(&lt;span style="color:#2544bb">`&amp;#34;1000000&amp;#34;`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Mappings: &lt;span style="color:#00538b">&amp;amp;&lt;/span>types.TypeMapping{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			Properties: &lt;span style="color:#5317ac">map&lt;/span>[&lt;span style="color:#005a5f">string&lt;/span>]types.Property{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#505050">// 映射的定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>				&lt;span style="color:#2544bb">&amp;#34;name&amp;#34;&lt;/span>: keywordProperty,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#2544bb">&amp;#34;age&amp;#34;&lt;/span>: types.&lt;span style="color:#721045">NewIntegerNumberProperty&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#2544bb">&amp;#34;is_checked&amp;#34;&lt;/span>: types.&lt;span style="color:#721045">NewBooleanProperty&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#2544bb">&amp;#34;created_at&amp;#34;&lt;/span>: dateProperty,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}).&lt;span style="color:#721045">Do&lt;/span>(context.&lt;span style="color:#721045">TODO&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		log.&lt;span style="color:#721045">Fatalf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Error creating the client: %s&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// index削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	_, err = es.Indices.&lt;span style="color:#721045">Delete&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;sample_index&amp;#34;&lt;/span>).&lt;span style="color:#721045">Do&lt;/span>(context.&lt;span style="color:#721045">TODO&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		log.&lt;span style="color:#721045">Fatalf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;Error deleting the client: %s&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="三bulk-index">三、Bulk Index&lt;/h2>
&lt;p>批量索引代码基于go-elasticsearch 示例。&lt;/p></description></item><item><title>Golang 接口:nil接口为什么不等于nil?</title><link>https://blog.ch3nnn.cn/posts/2024/golang-%E6%8E%A5%E5%8F%A3nil%E6%8E%A5%E5%8F%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8Enil/</link><pubDate>Mon, 11 Mar 2024 10:48:24 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/golang-%E6%8E%A5%E5%8F%A3nil%E6%8E%A5%E5%8F%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8Enil/</guid><description>&lt;h2 id="一go-接口的地位">一、Go 接口的地位&lt;/h2>
&lt;p>Go 语言核心团队的技术负责人 &lt;code>Russ Cox&lt;/code> 也曾说过这样一句话：“如果要从 Go 语言中挑选出一个特性放入其他语言，我会选择接口”，这句话足以说明接口这一语法特性在这位
Go 语言大神心目中的地位。&lt;/p>
&lt;p>为什么接口在 Go 中有这么高的地位呢？这是因为接口是 Go 这门静态语言中唯一“动静兼备”的语法特性。而且，接口“动静兼备”的特性给 Go 带来了强大的表达能力，但同时也给
Go 语言初学者带来了不少困惑。要想真正解决这些困惑，我们必须深入到 Go 运行时层面，看看 Go 语言在运行时是如何表示接口类型的。&lt;/p>
&lt;p>接下来，我们先来看看接口的静态与动态特性，看看“动静皆备”的含义。&lt;/p>
&lt;h2 id="二接口的静态特性与动态特性">二、接口的静态特性与动态特性&lt;/h2>
&lt;p>2.1 接口的静态特性与动态特性介绍
接口的静态特性体现在接口类型变量具有静态类型。&lt;/p>
&lt;p>比如 var err error 中变量 err 的静态类型为 error。拥有静态类型，那就意味着编译器会在编译阶段对所有接口类型变量的赋值操作进行类型检查，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。如果不满足，就会报错：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> err &lt;span style="color:#005a5f">error&lt;/span> = &lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#505050">// cannot use 1 (type int) as type error in assignment: int does not implement error (missing Error method)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而接口的动态特性，就体现在接口类型变量在运行时还存储了右值的真实类型信息，这个右值的真实类型被称为接口类型变量的动态类型。例如，下面示例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> err &lt;span style="color:#005a5f">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>err = errors.&lt;span style="color:#721045">New&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;error1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;%T\n&amp;#34;&lt;/span>, err) &lt;span style="color:#505050">// *errors.errorString
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.2 “动静皆备”的特性的好处
首先，接口类型变量在程序运行时可以被赋值为不同的动态类型变量，每次赋值后，接口类型变量中存储的动态类型信息都会发生变化，这让 Go 语言可以像动态语言（比如
Python）那样拥有使用 Duck Typing（鸭子类型）的灵活性。所谓鸭子类型，就是指某类型所表现出的特性（比如是否可以作为某接口类型的右值），不是由其基因（比如
C++ 中的父类）决定的，而是由类型所表现出来的行为（比如类型拥有的方法）决定的。&lt;/p></description></item><item><title>Protobuf 文档生成器插件</title><link>https://blog.ch3nnn.cn/posts/2024/%E5%B7%A5%E5%85%B7-protobuf%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8%E6%8F%92%E4%BB%B6/</link><pubDate>Wed, 28 Feb 2024 16:20:31 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/%E5%B7%A5%E5%85%B7-protobuf%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8%E6%8F%92%E4%BB%B6/</guid><description>&lt;blockquote>
&lt;p>这是 Google Protocol Buffers 文档生成器插件 (protoc)。
该插件可以根据文件中的注释生成 HTML、JSON、DocBook 和 Markdown 文档。&lt;/p>
&lt;/blockquote>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>毫无疑问, 目前后台开发接口协议应用最广泛的除了 HTTP 之外就是 gRPC 了, HTTP 接口有成熟的&lt;code>swagger&lt;/code>工具可以生成界面美观和使用友好的文档，那么对于gRPC呢？&lt;/p>
&lt;p>所以通过 .proto 文件能否生成更易阅读的 HTML 接口文档？&lt;/p>
&lt;h2 id="二安装">二、安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go install github.com/pseudomuto/protoc-gen-doc/cmd/protoc-gen-doc@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="三使用">三、使用&lt;/h2>
&lt;h3 id="userproto-文件">user.proto 文件&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>以&lt;code>user.proto&lt;/code>为例, 如下内容:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>syntax &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;proto3&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">option&lt;/span> go_package &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;./pb&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> user;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Messages
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">//--------------------------------用户--------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SysUser {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#005a5f">int64&lt;/span> id &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> username &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 用户名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> password &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// 密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> create_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">4&lt;/span>; &lt;span style="color:#505050">// 创建时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> update_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; &lt;span style="color:#505050">// 修改时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> delete_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">6&lt;/span>; &lt;span style="color:#505050">// 删除时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SysUserFilter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> id &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> username &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 用户名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">string&lt;/span> password &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// 密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> create_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">4&lt;/span>; &lt;span style="color:#505050">// 创建时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> update_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; &lt;span style="color:#505050">// 修改时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> delete_at &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">6&lt;/span>; &lt;span style="color:#505050">// 删除时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SelectSysUserListReq {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#005a5f">int64&lt;/span> page &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// 页码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> page_size &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 每页数量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">optional&lt;/span> SysUserFilter filter &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// SysUserFilter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">message&lt;/span> SelectSysUserListResp {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#005a5f">int64&lt;/span> count &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">1&lt;/span>; &lt;span style="color:#505050">// 总数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#005a5f">int64&lt;/span> page_count &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">2&lt;/span>; &lt;span style="color:#505050">// 页码总数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">repeated&lt;/span> SysUser results &lt;span style="color:#00538b">=&lt;/span> &lt;span style="color:#0000c0">3&lt;/span>; &lt;span style="color:#505050">// sys_user
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// Rpc Func
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// ------------------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">service&lt;/span> User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//-----------------------用户-----------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// 用户 列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">rpc&lt;/span> SelectSysUserList(SelectSysUserListReq) &lt;span style="color:#5317ac">returns&lt;/span> (SelectSysUserListResp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="1-生成-markdown-文档">1. 生成 markdown 文档&lt;/h3>
&lt;ol>
&lt;li>命令:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>protoc --doc_out&lt;span style="color:#00538b">=&lt;/span>. --doc_opt&lt;span style="color:#00538b">=&lt;/span>markdown,index.md pb/*.proto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>效果:
&lt;img src="https://s2.loli.net/2024/02/28/TwXqVdFvJyNZnfp.png" alt="20240228172356.png">&lt;/li>
&lt;/ol>
&lt;h3 id="2-生成-html-文档">2. 生成 html 文档&lt;/h3>
&lt;ol>
&lt;li>命令:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>protoc --doc_out&lt;span style="color:#00538b">=&lt;/span>. --doc_opt&lt;span style="color:#00538b">=&lt;/span>html,index.html pb/*.proto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>效果:
&lt;img src="https://s2.loli.net/2024/02/28/Jv67NT9cpYdCjre.png" alt="">&lt;/li>
&lt;/ol>
&lt;h2 id="四自定义模板">四、自定义模板&lt;/h2>
&lt;p>如果想使用自己的模板, 只需使用模板文件的路径而不是类型。&lt;/p></description></item><item><title>Golang 更严格的代码格式化工具 gofumpt</title><link>https://blog.ch3nnn.cn/posts/2024/golang-%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7gofumpt/</link><pubDate>Mon, 19 Feb 2024 19:56:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/golang-%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7gofumpt/</guid><description>&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>gofmt 是 golang 自带的代码自动格式化工具，是保证 Go 代码风格一致的大杀器。我们这次要推荐的 gofumpt 在 gofmt 的基础上添加了一系列更加严格的格式化规则，并保证了对
gofmt 的兼容。&lt;/p>
&lt;h2 id="二gofumpt-简介">二、gofumpt 简介&lt;/h2>
&lt;p>gofumpt(&lt;a href="https://github.com/mvdan/gofumpt">https://github.com/mvdan/gofumpt&lt;/a>) fork 自 gofmt，支持与 gofmt 几乎相同的命令行参数，因此可以作为 gofmt 的直接替代品使用。gofumpt 是
gofmt 的&amp;quot;超集&amp;quot;，经过 gofumpt 格式化的代码也符合 gofmt 的要求，其本身所扩展的格式化规则也可能在后续被集成进 gofmt。&lt;/p>
&lt;p>gofumpt 有以下特点:&lt;/p>
&lt;ul>
&lt;li>更多的格式化规则(参见 &lt;a href="https://github.com/mvdan/gofumpt#Added-rules">https://github.com/mvdan/gofumpt#Added-rules&lt;/a>)&lt;/li>
&lt;li>默认跳过对 vendor 的格式化&lt;/li>
&lt;li>不对自动生成的代码应用扩展规则&lt;/li>
&lt;li>不支持 -r 参数&lt;/li>
&lt;/ul>
&lt;h2 id="三安装使用命令">三、安装、使用命令&lt;/h2>
&lt;p>安装命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go install mvdan.cc/gofumpt@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>gofumpt -l -w .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="四使用举例">四、使用举例&lt;/h2>
&lt;p>&lt;strong>赋值运算符后面没有空行&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo &lt;span style="color:#00538b">:=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#2544bb">&amp;#34;bar&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改为 gofumpt 格式化后：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#2544bb">&amp;#34;bar&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>函数体周围没有空行&lt;/strong>&lt;/p></description></item><item><title>在 Go 使用 embed 当中嵌入父目录中的文件</title><link>https://blog.ch3nnn.cn/posts/2023/%E5%9C%A8go%E4%BD%BF%E7%94%A8embed%E5%BD%93%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%88%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 07 Oct 2023 09:48:41 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E5%9C%A8go%E4%BD%BF%E7%94%A8embed%E5%BD%93%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%88%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>&lt;blockquote>
&lt;p>自 Go 1.16 版本开始，Go 提供了将二进制文件打包进入到 Binary 文件当中的机制:`//go:embed。不过，我看到的示例大多数都是嵌入当前文件夹下的子文件夹的示例。并没有嵌入父一级文件夹的示例。&lt;/p>
&lt;/blockquote>
&lt;h2 id="为什么会需要嵌入父目录中的文件">为什么会需要嵌入父目录中的文件？&lt;/h2>
&lt;p>这是因为不同的项目的构建规则不同。一些小型项目可能只有一个 main.go 或同级目录下几个其他的 go source 文件即可，但对于更大型的项目，合理的项目拆分是有助于帮助提升项目的可维护性的。&lt;/p>
&lt;p>以我为例，我的目录结构如下：biz 目录下是我的核心逻辑，也是我日常写代码的地方；conf 则放置了各种配置，比如各种 API Key，ral 则是网络访问层，比如我比较喜欢用 gin 来做底层的网络访问层；script 放置了开发所需要的各种脚本文件；static 则放置了前端所需要的 JS / CSS 文件。在开发一些偏内容向的页面时，我会习惯使用 Server Side Render，所以我在 biz 目录下还有一个 template 目录。而主要的逻辑则放在 handler。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── biz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── dal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── handler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── logic
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ ├── service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── template
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── ral
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── gin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── script
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── static
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └── public
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在日常开发时，一个非常常见的操作是在 handler 里处理基本的逻辑，并将 template 中的模板渲染出来，并返回给用户，这个时候就需要在 handler 里使用上一级目录的文件了。&lt;/p></description></item><item><title>浅谈我为什么从 HEXO 迁移到 HUGO</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%B5%85%E8%B0%88%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ehexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</link><pubDate>Wed, 30 Aug 2023 10:53:08 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%B5%85%E8%B0%88%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ehexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</guid><description>&lt;h2 id="一为什么选择hugo">一、为什么选择Hugo&lt;/h2>
&lt;p>我一直在使用 HEXO 作为我的网站建设工具。最主要的原因在于容易理解，相对比较容易上手，并且有很多齐全的插件供你选择。&lt;/p>
&lt;p>首先，第一点得提的就是 Hugo 打出的标语 &amp;ndash; &lt;code>The world’s fastest framework for building websites。&lt;/code> Hugo 依靠 Go 语言进行开发，号称世界上最快的构建网站工具。HUGO
具有快速建站的能力。与其他网站建设工具相比，HUGO 具有更快的启动时间和更快的页面加载速度。这对于需要快速响应的网站来说尤为重要。&lt;/p>
&lt;p>正是依赖于 Hugo 快速生成的特点，调试方便成了 Hugo 的第二大特点。基本上我在使用 Markdown 语言进行页面编写处修改的内容可以实时地显示在网页上，而不用再次敲命令生成再预览。&lt;/p>
&lt;p>第三点自己也是学习和使用 GO 语言，所以也会有所青睐。&lt;/p>
&lt;h2 id="二安装-hugo">二、安装 Hugo&lt;/h2>
&lt;p>在 macOS 上安装 Hugo 前置条件需要安装 &lt;code>brew&lt;/code>。&lt;/p>
&lt;p>&lt;a href="https://brew.sh/">Homebrew&lt;/a> 是一款适用于 macOS 和 Linux 的免费开源包管理器。&lt;/p>
&lt;ol>
&lt;li>安装 GO 和 Git
可以使用 &lt;code>brew&lt;/code> 包管理工具
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>// 升级 brew
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew update &lt;span style="color:#00538b">&amp;amp;&amp;amp;&lt;/span> brew upgrade
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 安装 Git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>// 安装 Go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>安装 Hugo brew 扩展版本：
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>brew install hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="三hugo-快速入门">三、Hugo 快速入门&lt;/h2>
&lt;p>执行以下命令&lt;/p></description></item><item><title>Golang-语言源码级调试器 Delve</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</link><pubDate>Fri, 11 Aug 2023 15:43:40 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Go 目前的调试器有如下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;code>GDB&lt;/code> 最早期的调试工具，现在用的很少。&lt;/li>
&lt;li>&lt;code>LLDB&lt;/code> macOS 系统推荐的标准调试工具，单 Go 的一些专有特性支持的比较少。&lt;/li>
&lt;li>&lt;code>Delve&lt;/code> 专门为 Go 语言打造的调试工具，使用最为广泛。&lt;/li>
&lt;/ul>
&lt;p>本篇简单说明如何使用 &lt;code>Delve&lt;/code> 工具来调试 Go 程序，使用的 &lt;code>delve&lt;/code> 版本为 1.20.1。&lt;/p>
&lt;p>delve 的汉语意思是：钻研、探索；用这个来命名一个debug工具还是非常的形象。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>已知以下说明适用于 Linux、macOS、Windows 和 FreeBSD。&lt;/p>
&lt;p>克隆 git 存储库并构建：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ git clone https://github.com/go-delve/delve
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#8f0075">cd&lt;/span> delve
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ go install github.com/go-delve/delve/cmd/dlv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者，在 Go 版本 1.16 或更高版本上：&lt;/p>
&lt;p>&lt;strong>Install the latest release:&lt;/strong>
&lt;code>$ go install github.com/go-delve/delve/cmd/dlv@latest&lt;/code>&lt;/p>
&lt;p>&lt;strong>Install at tree head:&lt;/strong>
&lt;code>$ go install github.com/go-delve/delve/cmd/dlv@master&lt;/code>&lt;/p>
&lt;p>&lt;strong>安装在一个特定的版本或:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ go install github.com/go-delve/delve/cmd/dlv@v1.7.4-0.20211208103735-2f13672765fe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="命令">命令&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dlv &lt;span style="color:#00538b">[&lt;/span>command&lt;span style="color:#00538b">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Available Commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attach 附加到正在运行的进程并开始调试.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect 使用终端客户端连接到无头调试服务器.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core 检查核心转储.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dap 启动一个通过调试适配器协议&lt;span style="color:#00538b">(&lt;/span>DAP&lt;span style="color:#00538b">)&lt;/span>通信的无头TCP服务器.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> debug 编译并开始调试当前目录中的主包或指定的包.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">exec&lt;/span> 执行预编译的二进制文件，并开始调试会话.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">help&lt;/span> Help about any &lt;span style="color:#8f0075">command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run 弃用的命令。使用&lt;span style="color:#2544bb">&amp;#39;debug&amp;#39;&lt;/span>代替.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">test&lt;/span> 编译测试二进制文件并开始调试程序.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trace 编译并开始跟踪程序.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version Prints version.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="操作-示例代码">[操作] 示例代码&lt;/h2>
&lt;p>下面是检查操作的代码&lt;/p></description></item><item><title>微服务 API 网关对比和选型</title><link>https://blog.ch3nnn.cn/posts/2023/%E5%BE%AE%E6%9C%8D%E5%8A%A1api%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</link><pubDate>Tue, 04 Apr 2023 16:45:00 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E5%BE%AE%E6%9C%8D%E5%8A%A1api%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</guid><description>&lt;h2 id="什么是微服务">什么是微服务&lt;/h2>
&lt;p>微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。
在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。微服务是互联网业务发展的结果，互联网业务的飞速发展导致系统的架构也在不断地发生变化，总体来说，系统的架构大致经历了：单体应用架构—&amp;gt;
SOA 架构—&amp;gt;微服务架构 的演变，具体发展历程和各自的优缺点如下表所示。
&lt;img src="https://cdn.ch3nnn.cn/img202304041708571.png" alt="">&lt;/p>
&lt;p>因此，微服务是互联网发展的必然结果，很多传统公司的系统架构也在逐步微服务化。但是，随着互联网业务的发展，API 的数量也在剧增，使用网关对API统一管理也将面临挑战，选择一个更强大的
API 网关，可以有效地增强系统的监控、容灾、鉴权和限流等能力。&lt;/p>
&lt;h2 id="什么是微服务网关">什么是微服务网关&lt;/h2>
&lt;p>&lt;strong>API网关是一个服务器，是系统的唯一入口。&lt;/strong> 从面向对象设计的角度看，它与外观模式类似。&lt;/p>
&lt;p>API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。&lt;/p>
&lt;p>&lt;strong>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。&lt;/strong> 通常，网关也是提供REST/HTTP的访问API。
&lt;img src="https://cdn.ch3nnn.cn/img202304162258745.png" alt="">&lt;/p>
&lt;p>微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：&lt;/p>
&lt;p>数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。
控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。&lt;/p>
&lt;p>&lt;strong>微服务遇到的挑战&lt;/strong>&lt;/p>
&lt;p>微服务网关应该首先要具备 API 路由能力，微服务数量变多，API 数量急剧增加，网关还可以根据具体的场景作为流量过滤器来使用，以提供某些额外可选功能，因此对微服务
API Gateway 提出了更高要求，比如：&lt;/p>
&lt;ul>
&lt;li>可观测性：在以往的单体应用中，排查问题往往通过查看日志定位错误信息和异常堆栈；但是在微服务架构中服务繁多，出现问题时的问题定位变得非常困难；因此，如何监控微服务的运行状况、当出现异常时能快速给出报警，这给开发人员带来很大挑战。&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>鉴权认证：而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其它服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在微服务架构下，要考虑外部应用接入的场景、用户 -&lt;/p>
&lt;ul>
&lt;li>服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。&lt;/li>
&lt;li>系统稳定性：若大量请求超过微服务的处理能力时，可能会将服务打垮，甚至产生雪崩效应、影响系统的整体稳定性。&lt;/li>
&lt;li>服务发现：微服务的分散管理，让微服务的负载均衡的实现也更具有挑战性。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>解决方案&lt;/strong>&lt;/p>
&lt;p>API 网关作为客户端和服务端的中间桥梁，为微服务系统提供统一的管理机制：
除了基础的请求分发、API 管理和条件路由等功能，还包括身份验证、监控报警、调用链追踪、负载均衡、限流隔离和熔断降级。身份认证：下图表示的是微服务联合
API 网关如何进行身份认证的，由图可见所有请求都通过网关，从而有效地隐藏了微服务。&lt;/p>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/img202304041714043.png" alt="">
监控报警/调用链追踪：
API 作为客户端和服务端的中间桥梁，是微服务监控的最好载体，API 网关监控功能的主要职责是及时发现网关以及后端服务器的连接异常，在 API
的监控平台上面用户可以随时查看日志信息，监控信息，调用链等等，并且主机发生的任何异常都会自动报警到控制台。有些网关甚至可以做到给客户端和服务端双向报警。&lt;/p>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/img202304041714673.png" alt="">&lt;/p>
&lt;p>限流隔离/熔断降级：
随着互联网业务规模的增加，系统的并发度增高，多个服务之间相互调用链路，一条核心链路往往可能调用十个服务。如果在链路中，某个服务的
rt（响应时间）急剧上升，上游服务不断请求，造成恶性循环，上游等待结果线程数越多，使得更上游服务阻塞最终整条链路无法使用，从而导致服务雪崩，所以对入口流量进行整治管理是很有必要的，下图表示微服务系统是如何结合
API 网关进行限流隔离和熔断降级的。&lt;/p>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/img202304041715894.png" alt="">&lt;/p>
&lt;h2 id="主流网关选择">主流网关选择&lt;/h2>
&lt;p>在微服务领域，有许多开源网关实现，有 NGINX、Kong、Apache APISIX 和 Envoy 等，Java 技术栈的有 Netfilx Zuul、Spring Cloud Gateway、Soul 等。或许你会问“有了
NGINX 和 Kong，为什么还需要 Apache APISIX？” ，下面做个简单对比。&lt;/p></description></item><item><title>Crx搜搜 - 一个牛X的扩展商店</title><link>https://blog.ch3nnn.cn/posts/2023/crx%E6%90%9C%E6%90%9C-%E4%B8%80%E4%B8%AA%E7%89%9Bx%E7%9A%84%E6%89%A9%E5%B1%95%E5%95%86%E5%BA%97/</link><pubDate>Thu, 30 Mar 2023 10:08:23 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/crx%E6%90%9C%E6%90%9C-%E4%B8%80%E4%B8%AA%E7%89%9Bx%E7%9A%84%E6%89%A9%E5%B1%95%E5%95%86%E5%BA%97/</guid><description>&lt;p>由于 Chrome 扩展商店&lt;/p>
&lt;p>无法访问，很多浏览器的官方扩展商店无人维护，国内各种下载站套路太多，导致很难下载到所需要的浏览器扩展/插件。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://www.crxsoso.com/">Crx搜搜(opens new window)&lt;/a>利用独家技术，实时解析各大扩展商店最新版扩展下载地址，直接下载&lt;code>.crx&lt;/code>或&lt;code>.xpi&lt;/code>安装包。&lt;/strong>
现已支持以下扩展商店：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>扩展/应用商店&lt;/th>
 &lt;th>支持功能&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;a href="https://www.crxsoso.com/webstore/category/extensions">Chrome 扩展商店(opens new window)&lt;/a>&lt;/td>
 &lt;td>✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;a href="https://www.crxsoso.com/addon/category/Edge-Extensions">Edge 扩展商店(opens new window)&lt;/a>&lt;/td>
 &lt;td>✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;a href="https://www.crxsoso.com/firefox/category/extensions">Firefox 扩展商店(opens new window)&lt;/a>&lt;/td>
 &lt;td>✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;a href="https://www.crxsoso.com/store/category/apps">Microsoft 应用商店(opens new window)&lt;/a>&lt;/td>
 &lt;td>✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Opera 扩展商店&lt;/td>
 &lt;td>✔️ 解析 ✔️ 下载 ❌ 在线安装 ✔️ 离线安装 ❌ 查看详情 ❌ 搜索&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="-功能简介">📖 功能简介&lt;/h2>
&lt;p>下载的扩展兼容以下浏览器：&lt;/p></description></item><item><title>推荐一款超级好用的工具:uTools</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E8%B6%85%E7%BA%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7utools/</link><pubDate>Thu, 23 Mar 2023 05:56:04 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E8%B6%85%E7%BA%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7utools/</guid><description>&lt;h2 id="utoolspnghttpsresu-toolscnwebsiteutoolspng">&lt;img src="https://res.u-tools.cn/website/utools.png" alt="utools.png">&lt;/h2>
&lt;h2 id="utools-是什么">uTools 是什么？&lt;/h2>
&lt;blockquote>
&lt;p>uTools = your tools（你的工具集）&lt;/p>
&lt;/blockquote>
&lt;p>uTools 是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。&lt;/p>
&lt;p>通过快捷键（默认&lt;code>alt + space&lt;/code>）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，能够处理此内容的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。&lt;/p>
&lt;h2 id="utools-能做什么">uTools 能做什么？&lt;/h2>
&lt;p>最简单的，uTools 可以作为一个程序快速启动器，支持英文、英文驼峰、中文拼音、拼音首字母来打开你的本地程序。除程序外， win10+ 和 MacOS 用户还可以快速搜索并打开「控制面板」内的细项。总之，你只要还记得一个大概的名字，直接输入基本都能找到。&lt;/p>
&lt;h2 id="一切皆插件">一切皆插件！&lt;/h2>
&lt;p>启动已安装的程序仅仅是最基础的功能，uTools 最大的特点就是拥有强大的插件系统。&lt;/p>
&lt;p>现在已有 700+ 的插件供你选择，每个插件解决一个具体场景的问题，简洁美观、即用即走。&lt;/p>
&lt;p>输入&lt;code>插件应用市场&lt;/code>进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最称手的工具集合，为各种日常操作提供便利，不断产生的新插件，将为你带来无限可能。&lt;/p>
&lt;p>&lt;img src="https://res.u-tools.cn/website/plugin1.png" alt="plugin">&lt;/p>
&lt;h2 id="超级面板">超级面板&lt;/h2>
&lt;p>可以通过鼠标右键/中键（可配置），快速打开 uTools 超级面板，uTools 会根据当前选择的内容（文本、截图、文件、文件夹）自动匹配已安装的插件供你选择。与平时使用右键类似的习惯，uTools 超级面板却能为你带来完全不一样的内容及体验。&lt;/p>
&lt;blockquote>
&lt;p>针对英文，还提供单词词典和整句翻译功能。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://res.u-tools.cn/website/translate.jpg" alt="superPanel">&lt;/p></description></item><item><title>Filebeat轻量型日志采集器-自定义processors处理器</title><link>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>Thu, 23 Feb 2023 18:14:25 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>&lt;h2 id="引入对beat的依赖">引入对beat的依赖&lt;/h2>
&lt;p>&lt;code>go get github.com/elastic/beats/v7&lt;/code>&lt;/p>
&lt;h2 id="定义在filebeat中的配置文件">定义在filebeat中的配置文件&lt;/h2>
&lt;p>filebeat通常以配置文件的方式加载插件。让定义一下自定义配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>filebeat.inputs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: &lt;span style="color:#0000c0">log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> paths:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#0000c0">example/example.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>processors:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050"># 自定义处理器插件 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - parse_text:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_has_suffix: &lt;span style="color:#0000c0">example.log&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>output.console:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pretty: &lt;span style="color:#0000c0">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go文件中的配置">go文件中的配置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> actions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">type&lt;/span> config &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	FileHasSuffix &lt;span style="color:#005a5f">string&lt;/span> &lt;span style="color:#2544bb">`config:&amp;#34;file_has_suffix&amp;#34; validate:&amp;#34;required&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="初始化加载插件">初始化加载插件&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	processors.&lt;span style="color:#721045">RegisterPlugin&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;parse_text&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		checks.&lt;span style="color:#721045">ConfigChecked&lt;/span>(NewParseText,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			checks.&lt;span style="color:#721045">RequireFields&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;file_has_suffix&amp;#34;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="run接口">Run接口&lt;/h2>
&lt;p>处理 &lt;strong>filebeat&lt;/strong> 读取到的每行日志数据&lt;code>message&lt;/code>, 这里我们就可以自定义一些处理解析逻辑, 下面逻辑是将日志数据按&lt;code>,&lt;/code>切分,重新组装到&lt;code>event.Fields&lt;/code>字段里.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> (p parseText) &lt;span style="color:#721045">Run&lt;/span>(event &lt;span style="color:#00538b">*&lt;/span>beat.Event) (&lt;span style="color:#00538b">*&lt;/span>beat.Event, &lt;span style="color:#005a5f">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> !p.&lt;span style="color:#721045">isParseFile&lt;/span>(event) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> event, &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	message, err &lt;span style="color:#00538b">:=&lt;/span> p.&lt;span style="color:#721045">getMessage&lt;/span>(event)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> event, &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#505050">// 按空格切分文本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	split &lt;span style="color:#00538b">:=&lt;/span> strings.&lt;span style="color:#721045">Split&lt;/span>(message, &lt;span style="color:#2544bb">&amp;#34;,&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	p.result[&lt;span style="color:#2544bb">&amp;#34;split&amp;#34;&lt;/span>] = split
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	_, err = event.Fields.&lt;span style="color:#721045">Put&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;parse_text&amp;#34;&lt;/span>, p.result)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">return&lt;/span> event, &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="main函数">main函数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;os&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	_ &lt;span style="color:#2544bb">&amp;#34;filebeat-plugin/pkg/processors/actions&amp;#34;&lt;/span> &lt;span style="color:#505050">// 这里需要将自定义插件注册
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	&lt;span style="color:#2544bb">&amp;#34;github.com/elastic/beats/v7/filebeat/cmd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	inputs &lt;span style="color:#2544bb">&amp;#34;github.com/elastic/beats/v7/filebeat/input/default-inputs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">if&lt;/span> err &lt;span style="color:#00538b">:=&lt;/span> cmd.&lt;span style="color:#721045">Filebeat&lt;/span>(inputs.Init, cmd.&lt;span style="color:#721045">FilebeatSettings&lt;/span>()).&lt;span style="color:#721045">Execute&lt;/span>(); err &lt;span style="color:#00538b">!=&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		os.&lt;span style="color:#721045">Exit&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="打包-build">打包 build&lt;/h2>
&lt;p>项目路径下执行 &lt;code>go build -o filebeat.exe ./cmd/filebeat/&lt;/code>&lt;/p></description></item><item><title>Facebook 开源 Golang 实体框架 Ent</title><link>https://blog.ch3nnn.cn/posts/2023/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 16 Jan 2023 17:29:45 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</guid><description>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs16738590832901.jpg" alt="">&lt;/p>
&lt;p>ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>图就是代码&lt;/strong> - 将任何数据库表建模为Go对象。&lt;/li>
&lt;li>&lt;strong>轻松地遍历任何图形&lt;/strong> - 可以轻松地运行查询、聚合和遍历任何图形结构。&lt;/li>
&lt;li>&lt;strong>静态类型和显式API&lt;/strong> - 使用代码生成静态类型和显式API，查询数据更加便捷。&lt;/li>
&lt;li>&lt;strong>多存储驱动程序&lt;/strong> - 支持MySQL, PostgreSQL, SQLite 和 Gremlin。&lt;/li>
&lt;li>&lt;strong>可扩展&lt;/strong> - 简单地扩展和使用Go模板自定义。&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-console" data-lang="console">&lt;span style="display:flex;">&lt;span>go install entgo.io/ent/cmd/ent@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快速开始">快速开始&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go mod init &amp;lt;project&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建你的第一个项目">创建你的第一个项目&lt;/h3>
&lt;p>进入你项目的根目录，然后运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go run -mod&lt;span style="color:#00538b">=&lt;/span>mod entgo.io/ent/cmd/ent init User
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上的命令会在&lt;code>&amp;lt;project&amp;gt;/ent/schema/&lt;/code>目录下产生&lt;code>User&lt;/code>的数据模式（数据模式是数据库系统设计中的专业术语，若对该部分有任何理解问题，请查阅数据库系统的相关书籍）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> &lt;span style="color:#2544bb">&amp;#34;entgo.io/ent&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User在User实体中组合了ent默认的数据库模式定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">type&lt;/span> User &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ent.Schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User的字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">func&lt;/span> (User) &lt;span style="color:#721045">Fields&lt;/span>() []ent.Field {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User的边
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">func&lt;/span> (User) &lt;span style="color:#721045">Edges&lt;/span>() []ent.Edge {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为&lt;code>User&lt;/code> 模式添加两个字段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> schema
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;entgo.io/ent&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">&amp;#34;entgo.io/ent/schema/field&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// User的字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">func&lt;/span> (User) &lt;span style="color:#721045">Fields&lt;/span>() []ent.Field {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">return&lt;/span> []ent.Field{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#721045">Int&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;age&amp;#34;&lt;/span>).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#721045">Positive&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#721045">String&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;name&amp;#34;&lt;/span>).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#721045">Default&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;unknown&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从项目的根目录下像如下命令那样，运行&lt;code>go generate&lt;/code>：&lt;/p></description></item><item><title>Filebeat轻量型日志采集器及output插件开发</title><link>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 09 Jan 2023 16:36:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid><description>&lt;blockquote>
&lt;p>无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。&lt;/p>
&lt;/blockquote>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>Filebeat 是使用 Golang 实现的轻量型日志采集器。本质上是一个 agent ，可以安装在各个节点上，根据配置读取对应位置的日志，并上报到相应的地方去。&lt;/p>
&lt;h3 id="概要">概要&lt;/h3>
&lt;p>Filebeat 并不依赖于 ElasticSearch，可以单独存在。我们可以单独使用Filebeat进行日志的上报和搜集。filebeat 内置了常用的 Output 组件, 例如 kafka、ElasticSearch、redis 等，出于调试考虑，也可以输出到 console 和 file 。我们可以利用现有的 Output 组件，将日志进行上报。&lt;/p>
&lt;h3 id="整体工作原理">整体工作原理&lt;/h3>
&lt;p>Filebeat 由两个主要组件组成：harvester 和 prospector。&lt;/p>
&lt;ul>
&lt;li>harvester (采集器) 的主要职责是读取单个文件的内容。读取每个文件，并将内容发送到 the output。 每个文件启动一个 harvester，harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态。如果文件在读取时被删除或重命名，Filebeat 将继续读取文件。&lt;/li>
&lt;li>prospector (查找器) 的主要职责是管理 harvester 并找到所有要读取的文件来源。如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个 harvester。每个 prospector 都在自己的 Go 协程中运行。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;em>注：Filebeat prospector只能读取本地文件， 没有功能可以连接到远程主机来读取存储的文件或日志。&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>由以上两个组件一起工作来读取文件（tail file）并将事件数据发送到指定的输出。
下图是 Filebeat 官方提供的架构图：
&lt;img src="https://cdn.jsdelivr.net/gh/ch3nnn/picgo/blog/imgs20230109163928.png" alt="">&lt;/p>
&lt;h4 id="filebeat背后的老大">Filebeat背后的“老大”&lt;/h4>
&lt;p>说到Filebeat，它其实只是&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Felastic%2Fbeats%2Ftree%2Fmaster%2Flibbeat">beats家族&lt;/a>众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>beat&lt;/th>
 &lt;th>功能&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>Filebeat&lt;/td>
 &lt;td>收集日志文件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Metricbeat&lt;/td>
 &lt;td>收集各种指标数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Packetbeat&lt;/td>
 &lt;td>收集网络数据包&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Auditbeat&lt;/td>
 &lt;td>收集审计数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Heartbeat&lt;/td>
 &lt;td>收集服务运行状态监测数据&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&amp;hellip;&lt;/td>
 &lt;td>&amp;hellip;&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>如果你愿意的话，你也可以按照beat的规范来写自己的beat。
能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么&lt;/p></description></item><item><title>这些最常用的 Go CLI 命令，新手 Gopher 应该掌握</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 02 Jan 2023 10:28:19 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</guid><description>&lt;p>本文将介绍一些最基本的 Go 命令行命令。如果你刚接触 Go 语言，那你有必要记住它们，因为这些命令是 Go 开发者日常工作中所必备的。&lt;/p>
&lt;p>&lt;strong>Go version&lt;/strong>&lt;/p>
&lt;p>开始 Go 项目前，我们应该确保开发机上已经安装好了 Go 编译器。这可以通过 &lt;a href="https://go.dev/doc/install">https://go.dev/doc/install&lt;/a> 进行下载安装。&lt;/p>
&lt;p>通过执行以下命令可以查看安装的 Go 版本信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">go&lt;/span> version go1&lt;span style="color:#0000c0">.18&lt;/span> darwin&lt;span style="color:#00538b">/&lt;/span>amd64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Go env&lt;/strong>&lt;/p>
&lt;p>如果我们可能想查看一些 Go 相关的环境变量，例如 GOROOT 或者 GOPATH。你可以执行这个命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> env
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你想对某个环境变量进行更改，例如修改 Go 代理，你可以这样做。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> env &lt;span style="color:#00538b">-&lt;/span>w GOPROXY=https:&lt;span style="color:#505050">//goproxy.io,direct
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>go mod&lt;/strong>&lt;/p>
&lt;p>在你开始建立第一个 Go 程序时，在项目根目录下，你应该运行这样的命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> mod init &amp;lt;your project name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#5317ac">go&lt;/span> mod init demo&lt;span style="color:#00538b">/&lt;/span>firstProject
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时，项目根目录将增加 go.mod 文件，它的内容如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>$ cat &lt;span style="color:#5317ac">go&lt;/span>.mod 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>module demo&lt;span style="color:#00538b">/&lt;/span>firstProject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#0000c0">1.18&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你有其他语言的经验，那么 go.mod 类似于 Python 中的 requirements.txt，Java 中的 pom.xml，它用于管理项目的依赖包。&lt;/p></description></item><item><title>「回顾2022，展望2023」 —— 年终总结</title><link>https://blog.ch3nnn.cn/posts/2022/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 01 Jan 2023 23:41:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid><description>&lt;blockquote>
&lt;p>致自己：折腾不息 · 乐此不疲!&lt;/p>
&lt;/blockquote>
&lt;h2 id="22-年收获">22 年收获&lt;/h2>
&lt;p>&lt;strong>技术上&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>编程语言方面
&lt;ul>
&lt;li>Golang: 从开始学习到现在的一年时间里, 前前后后也写了些代码, 其中包括业余时间的, 也有产品项目中的. 在摸滚打爬中对于Golang的使用算是勉强达到了较为熟练的状态.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>开源贡献方向
&lt;ul>
&lt;li>jaywcjlove/reference &lt;a href="https://github.com/jaywcjlove/reference">为开发人员分享快速参考备忘清单(速查表)&lt;/a>&lt;/li>
&lt;li>liangliangyy/DjangoBlog &lt;a href="https://github.com/liangliangyy/DjangoBlog">基于Django的博客系统&lt;/a>&lt;/li>
&lt;li>Lcry/a-sheep-assistant &lt;a href="https://github.com/Lcry/a-sheep-assistant">羊了个羊助手，羊了个羊一键闯关&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>生活上&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>疫情防控
保持绿码, 小🐑人中&amp;hellip; 还以为自己就是那位&amp;quot;天选之子&amp;quot;(又开始吹牛皮).&lt;/li>
&lt;li>生活情感
端午节前带女朋友回家, 父母都感觉很满意, 生活很幸福, 偶尔会吵吵嘴毕竟生活需要增加些乐趣嘛(哈哈哈).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>工作上&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>从互联网医疗到工控安全行业, 工作内容没有任何变化(就是撸码搬砖🧱)&lt;/li>
&lt;/ul>
&lt;h2 id="23年展望">23年展望&lt;/h2>
&lt;p>2023年是新的一年，新的一年就会有新的flag。新的一年我要以下几件事:&lt;/p>
&lt;ul>
&lt;li>保持持续学习的激情、态度&lt;/li>
&lt;li>持续开源贡献&lt;/li>
&lt;li>真的需要运动(感觉自己要废了)&lt;/li>
&lt;li>感情上还是需要更加谦让&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="写在最后">写在最后&lt;/h2>
&lt;ul>
&lt;li>最后, 最后, Happy New Year &amp;hellip; 或者至少, 平平安安度过新的一年&lt;/li>
&lt;li>各位, 继续加油吧! 冲冲冲!&lt;/li>
&lt;/ul></description></item><item><title>Golang 代码检查工具(golangci-lint)</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</link><pubDate>Thu, 22 Dec 2022 11:05:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</guid><description>&lt;h2 id="一介绍">一、介绍&lt;/h2>
&lt;p>&lt;code>golangci-lint&lt;/code> 是一个代码检查工具的集合，聚集了多种 Go 代码检查工具，如 &lt;code>golint&lt;/code>、&lt;code>go vet&lt;/code> 等。&lt;/p>
&lt;p>优点：&lt;/p>
&lt;ul>
&lt;li>运行速度快&lt;/li>
&lt;li>可以集成到 vscode、goland 等开发工具中&lt;/li>
&lt;li>包含了非常多种代码检查器&lt;/li>
&lt;li>可以集成到 CI 中&lt;/li>
&lt;li>这是包含的代码检查器列表：Linters&lt;/li>
&lt;/ul>
&lt;h2 id="二安装">二、安装&lt;/h2>
&lt;p>&lt;code>golangci-lint&lt;/code> 官方不建议使用 &lt;code>go get&lt;/code> 方式安装，推荐使用二进制安装。&lt;/p>
&lt;h3 id="macos">MacOS&lt;/h3>
&lt;p>直接使用 homebrew 安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>brew install golangci-lint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew upgrade golangci-lint
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="linux-和-windows">Linux 和 Windows&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050"># binary will be $(go env GOPATH)/bin/golangci-lint&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>curl -sSfL https://raw.githubusercontent.com/Goci/golangci-lint/master/install.sh | sh -s -- -b &lt;span style="color:#5317ac">$(&lt;/span>go env GOPATH&lt;span style="color:#5317ac">)&lt;/span>/bin v1.42.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>golangci-lint --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>golangci-lint&lt;/code> 将会被安装到 &lt;strong>GOPATH/bin&lt;/strong> 目录中，如果此目录不在环境变量路径中需要加上。&lt;/p>
&lt;h2 id="三使用方式">三、使用方式&lt;/h2>
&lt;h3 id="命令行">命令行&lt;/h3>
&lt;p>在项目根目录下执行以下命令检查整个项目的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>golangci-lint run
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其等价于:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>golangci-lint run ./...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者可以指定检查某个目录下的代码文件，指定目录时不会递归分析其子目录，要递归分析其子目录需要加上 /&amp;hellip;：&lt;/p></description></item><item><title>Golang-使用gvm进行版本控制</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</link><pubDate>Sun, 14 Aug 2022 18:00:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</guid><description>&lt;p>当你想为每个项目切换 go 版本时，gvm (Go Version Manager) 很方便。&lt;/p>
&lt;p>这里，我将介绍“如何在Mac上安装gvm”和“如何使用gvm”&lt;/p>
&lt;h2 id="使用准备">使用准备&lt;/h2>
&lt;h3 id="仅适用于-mac-的准备工作">仅适用于 Mac 的准备工作&lt;/h3>
&lt;p>按照MacOSX 要求中的说明执行以下命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>xcode-select --install
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install mercurial
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="gvm安装">gvm安装&lt;/h3>
&lt;p>我使用 zsh 作为我的 shell。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#8f0075">echo&lt;/span> &lt;span style="color:#00538b">$SHELL&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/zsh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于 zsh，您可以这样安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ zsh &amp;lt; &amp;lt;&lt;span style="color:#00538b">(&lt;/span>curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer&lt;span style="color:#00538b">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cloning from https://github.com/moovweb/gvm.git to /Users/user_name/.gvm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>No existing Go versions detected
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Installed GVM v1.0.22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please restart your terminal session or to get started right away run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#2544bb">`&lt;/span>&lt;span style="color:#8f0075">source&lt;/span> /Users/user_name/.gvm/scripts/gvm&lt;span style="color:#2544bb">`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>~/.zshrc&lt;/code> 以下行被添加到最后一行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">[[&lt;/span> -s &lt;span style="color:#2544bb">&amp;#34;/Users/user_name/.gvm/scripts/gvm&amp;#34;&lt;/span> &lt;span style="color:#00538b">]]&lt;/span> &lt;span style="color:#00538b">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#8f0075">source&lt;/span> &lt;span style="color:#2544bb">&amp;#34;/Users/user_name/.gvm/scripts/gvm&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新启动终端 gvm 即可使用&lt;/p></description></item><item><title>Golang-常见数据结构Slice</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</link><pubDate>Sat, 30 Apr 2022 00:56:46 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</guid><description>&lt;h1 id="golang-常见数据结构slice">Golang-常见数据结构Slice&lt;/h1>
&lt;h2 id="slice">Slice&lt;/h2>
&lt;p>slice 翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。&lt;/p>
&lt;p>了解 slice 的本质, 最简单的方法就是看它的源码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// runtime/slice.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">type&lt;/span> slice &lt;span style="color:#5317ac">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> array unsafe.Pointer &lt;span style="color:#505050">// 元素指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> len &lt;span style="color:#005a5f">int&lt;/span> &lt;span style="color:#505050">// 长度 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> cap &lt;span style="color:#005a5f">int&lt;/span> &lt;span style="color:#505050">// 容量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>slice 共有三个属性:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>指针&lt;/strong> 指向底层数组&lt;/li>
&lt;li>&lt;strong>长度&lt;/strong> 表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度&lt;/li>
&lt;li>&lt;strong>容量&lt;/strong> 底层数组的元素个数，容量 &amp;gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/blog/202304191511106.png" alt="">&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>: 底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。&lt;/p>
&lt;h2 id="slice-创建">slice 创建&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>方式&lt;/th>
 &lt;th>代码示例&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>直接声明&lt;/td>
 &lt;td>var slice []int&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>new&lt;/td>
 &lt;td>slice := *new([]int)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>字面量&lt;/td>
 &lt;td>slice := []int{1,2,3,4}&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>make&lt;/td>
 &lt;td>slice := make(int[], 5, 10)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>从切片或者数组&amp;quot;截取&amp;quot;&lt;/td>
 &lt;td>slice := array[1:5] 或 slice := sourceSlice[1:5]&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>直接声明&lt;/strong>&lt;/p></description></item><item><title>Golang-常见数据结构Map</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</link><pubDate>Mon, 11 Apr 2022 10:07:33 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</guid><description>&lt;h2 id="map">Map&lt;/h2>
&lt;p>map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。&lt;/p>
&lt;p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。&lt;/p>
&lt;h2 id="哈希表">哈希表&lt;/h2>
&lt;p>哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表， 有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。&lt;/p>
&lt;h2 id="设计原理">设计原理&lt;/h2>
&lt;p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 &lt;code>O(1)&lt;/code> 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。&lt;/p>
&lt;h3 id="哈希函数">哈希函数&lt;/h3>
&lt;p>实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。&lt;/p>
&lt;p>完美哈希函数如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111020765.png" alt="">&lt;/p>
&lt;p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。&lt;/p>
&lt;p>不均匀哈希函数如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111022378.png" alt="">&lt;/p>
&lt;p>在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。&lt;/p>
&lt;h3 id="冲突解决">冲突解决&lt;/h3>
&lt;p>哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。&lt;/p>
&lt;p>&lt;strong>开放寻址法&lt;/strong>
开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从索引开始遍历&lt;/p>
&lt;p>当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置
开放地址法写入数据如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111027414.png" alt="">
如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。&lt;/p>
&lt;p>开放地址法读取数据如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111029114.png" alt="">&lt;/p>
&lt;p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。&lt;/p>
&lt;p>开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。&lt;/p>
&lt;p>&lt;strong>拉链法&lt;/strong>&lt;/p>
&lt;p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。&lt;/p>
&lt;p>实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』：
拉链法写入数据如图:
&lt;img src="https://cdn.ch3nnn.cn/img202304111030711.png" alt="">&lt;/p></description></item><item><title>Golang-channel通道</title><link>https://blog.ch3nnn.cn/posts/2022/golang-channel%E9%80%9A%E9%81%93/</link><pubDate>Sat, 19 Mar 2022 17:41:05 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-channel%E9%80%9A%E9%81%93/</guid><description>&lt;blockquote>
&lt;p>goroutine 和 channel (通道)并成为 Go 并发的两大基石。channel 可以放心地在多个 goroutine 之间使用, 因为它是并发安全的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="channel-有哪些应用">channel 有哪些应用&lt;/h2>
&lt;p>&lt;strong>停止信号&lt;/strong>
channel 用于停止信号的场景很多，通常是通过关闭某个channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作，如停止某个循环等。&lt;/p>
&lt;p>&lt;strong>定时任务&lt;/strong>
与计时器结合，一般有两种做法：实现超时控制、实现定期执行某个任务。
有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定。这就是时控制：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span> time.&lt;span style="color:#721045">After&lt;/span>(&lt;span style="color:#0000c0">100&lt;/span>&lt;span style="color:#00538b">*&lt;/span>time.Millisecond):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span> s.stopc:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#0000c0">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。&lt;/p>
&lt;p>定时执行某个任务，也比较简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">worker&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ticker &lt;span style="color:#00538b">:=&lt;/span> time.&lt;span style="color:#721045">Tick&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span> ticker:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#505050">// 执行定时任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;执行 1s 定时任务&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每隔 1 秒种，执行一次定时任务。&lt;/p>
&lt;p>&lt;strong>解耦生产方和消费方&lt;/strong>
服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行：&lt;/p></description></item><item><title>Golang-垃圾回收</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Fri, 18 Mar 2022 23:21:06 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>&lt;p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。&lt;/p>
&lt;h3 id="垃圾回收算法">垃圾回收算法&lt;/h3>
&lt;p>目前比较常见的垃圾回收算法有三种：
&lt;strong>引用计数&lt;/strong>：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。&lt;/p>
&lt;ul>
&lt;li>代表语言：Python、PHP、Swift&lt;/li>
&lt;li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。&lt;/li>
&lt;li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>标记-清除&lt;/strong>：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。&lt;/p>
&lt;ul>
&lt;li>代表语言：Golang（三色标记法）&lt;/li>
&lt;li>优点：解决了引用计数的缺点。&lt;/li>
&lt;li>缺点：需要 STW，暂时停掉程序运行。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>分代收集&lt;/strong>：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。&lt;/p>
&lt;ul>
&lt;li>代表语言：Java&lt;/li>
&lt;li>优点：回收性能好&lt;/li>
&lt;li>缺点：算法复杂&lt;/li>
&lt;/ul>
&lt;h3 id="golang-垃圾回收">Golang 垃圾回收&lt;/h3>
&lt;h4 id="go13之前-标记清除法">Go1.3之前 标记清除法&lt;/h4>
&lt;ol>
&lt;li>进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的内存占用和可达的内存占用&lt;/li>
&lt;li>开始标记，程序找出可达内存占用并做标记&lt;/li>
&lt;li>标记结束清除未标记的内存占用&lt;/li>
&lt;li>结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://s2.loli.net/2023/03/18/eaq4SfrMFOHYxVI.png" alt="">&lt;/p>
&lt;p>一开始的做法是将垃圾清理结束时才停止 STW，后来优化了方案将清理垃圾放到了 STW 之后，与程序运行同时进行，这样做减小了 STW 的时长。
但是 STW 会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的 STW 对于性能较高的程序还是无法接受，但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。
因此 Go1.5 采用了三色标记法优化了 STW。&lt;/p>
&lt;h4 id="go15之后-三色并发标记法">Go1.5之后 三色并发标记法&lt;/h4>
&lt;p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：&lt;/p>
&lt;p>灰色：对象还在标记队列中等待
黑色：对象已被标记，gcmarkBits对应位为 1 – 该对象不会在本次 GC 中被回收
白色：对象未被标记，gcmarkBits对应位为 0 – 该对象将会在本次 GC 中被清理&lt;/p></description></item><item><title>Golang-Modules的演进史</title><link>https://blog.ch3nnn.cn/posts/2022/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</link><pubDate>Sun, 13 Mar 2022 11:53:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid><description>&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。&lt;/p>
&lt;p>使用&lt;code> Go Modules&lt;/code> 模式，一般分为以下几个流程：&lt;/p>
&lt;ul>
&lt;li>&lt;code>go mod init&lt;/code> 创建一个新模块，初始化 &lt;code>go.mod&lt;/code> 文件。&lt;/li>
&lt;li>&lt;code>go build&lt;/code>、&lt;code>go test&lt;/code>、&lt;code>go run&lt;/code>、&lt;code>go install&lt;/code> 等构建命令，向 &lt;code>go.mod&lt;/code>文件中添加模块所需的依赖项。&lt;/li>
&lt;li>&lt;code>go list -m -json all&lt;/code> 打印当前模块的依赖项。&lt;/li>
&lt;li>&lt;code>go get&lt;/code> 添加依赖项，或修改依赖项版本。&lt;/li>
&lt;li>&lt;code>go mod tidy&lt;/code> 删除未使用的依赖项。&lt;/li>
&lt;/ul>
&lt;h2 id="go-modules-演进史">Go Modules 演进史&lt;/h2>
&lt;p>&lt;strong>Go v1.11&lt;/strong>
从 Go v1.11 开始支持 Go Moduls。
为了兼容使用 Go v1.11 之前的任意版本的项目，当设置 &lt;code>GO111MODULE=auto&lt;/code> 或 &lt;code>GO111MODULE=off&lt;/code> 时，Go v1.11 在 &lt;code>$GOPATH/src&lt;/code> 中，继续使用 &lt;code>GOPATH&lt;/code> 模式。
当设置 &lt;code>GO111MODULE=auto&lt;/code> 时，其它任意位置，如果当前目录或父目录包含 go.mod 文件，则使用 Modules 模式。&lt;/p></description></item><item><title>Golang-逃逸分析</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link><pubDate>Mon, 07 Mar 2022 13:38:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid><description>&lt;h3 id="什么是堆栈">什么是堆/栈&lt;/h3>
&lt;ul>
&lt;li>堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多&lt;/li>
&lt;li>栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上&lt;/li>
&lt;/ul>
&lt;h3 id="什么是逃逸分析">什么是逃逸分析&lt;/h3>
&lt;p>我们如何知道一个对象是应该放在堆内存，还是栈内存之上呢？可以官网的FAQ（地址：&lt;a href="https://go.dev/doc/faq#stack_or_heap">https://go.dev/doc/faq#stack_or_heap&lt;/a>）中找到答案.
&lt;img src="https://s2.loli.net/2023/03/07/5xzbUkInvQrVpDu.png" alt="">&lt;/p>
&lt;p>大致意思是:&lt;/p>
&lt;blockquote>
&lt;p>从正确性的角度来看，你不需要知道。Go中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。
存储位置确实对编写高效的程序有影响。如果可能的话，Go编译器将为该函数的堆栈帧中的函数分配局部变量。但是，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在有垃圾回收的堆上分配该变量，以避免悬空指针错误。此外，如果局部变量非常大，那么将其存储在堆中可能比存储在栈中更有意义。
在当前编译器中，如果变量的地址被占用，那么该变量就是堆上分配内存的候选变量。然而，基本的逃逸分析可以识别出某些情况下，这些变量将不会存在于函数返回之后，而可以驻留在栈中。&lt;/p>
&lt;/blockquote>
&lt;h3 id="在什么阶段确立逃逸">在什么阶段确立逃逸&lt;/h3>
&lt;p>Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的。&lt;/p>
&lt;ul>
&lt;li>逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析&lt;/li>
&lt;li>如果变量在函数外部没有引用，则优先放到栈中&lt;/li>
&lt;li>如果变量在函数外部存在引用，则必定放在堆中&lt;/li>
&lt;/ul>
&lt;h3 id="逃逸规则">逃逸规则&lt;/h3>
&lt;p>我们其实都知道一个普遍的规则，就是如果变量需要使用堆空间，那么他就应该进行逃逸。但是实际上Golang并不仅仅把逃逸的规则如此泛泛。Golang会有很多场景具备出现逃逸的现象。&lt;/p>
&lt;p>一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。&lt;/p>
&lt;p>Go语言中的引用类型有&lt;code>func&lt;/code>（函数类型），&lt;code>interface&lt;/code>（接口类型），&lt;code>slice&lt;/code>（切片类型），&lt;code>map&lt;/code>（字典类型），&lt;code>channel&lt;/code>（管道类型），&lt;code>*&lt;/code>（指针类型）等。&lt;/p>
&lt;h3 id="怎么确定是否逃逸">怎么确定是否逃逸&lt;/h3>
&lt;p>可以使用编译器提供的指令&lt;code>-gcflags&lt;/code> 就可以看到详细的逃逸分析过程，命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>go build -gcflags &lt;span style="color:#2544bb">&amp;#39;-m -l&amp;#39;&lt;/span> main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其指令涉及的参数如下：&lt;/p>
&lt;ul>
&lt;li>-m：打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是这样子调试的信息量较大，一般用一个就足够了。&lt;/li>
&lt;li>-l ：禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。&lt;/li>
&lt;/ul>
&lt;h3 id="常见逃逸案例分析">常见逃逸案例分析&lt;/h3>
&lt;p>&lt;strong>new的变量在栈还是堆&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">foo&lt;/span>(argVal &lt;span style="color:#005a5f">int&lt;/span>) (&lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#005a5f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal1 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal2 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal3 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal4 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">var&lt;/span> fooVal5 = &lt;span style="color:#8f0075">new&lt;/span>(&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//此处循环是防止go编译器将foo优化成inline(内联函数)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#505050">//如果是内联函数，main调用foo将是原地展开，所以fooVal 1-5 相当于main作用域的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#505050">//即使fooVal3发生逃逸，地址与其他也是连续的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">5&lt;/span>; i&lt;span style="color:#00538b">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">println&lt;/span>(argVal, fooVal1, fooVal2, fooVal3, fooVal4, fooVal5)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">//fooVal3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span> &lt;span style="color:#5317ac">return&lt;/span> fooVal3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainVal &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#721045">foo&lt;/span>(&lt;span style="color:#0000c0">666&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f0075">println&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>mainVal, mainVal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将fooVal 1-5 全部用&lt;code>new&lt;/code>的方式来开辟, 编译运行看结果, 显然&lt;code>fooVal3&lt;/code>发生了逃逸&lt;/p></description></item><item><title>Golang-GMP模型</title><link>https://blog.ch3nnn.cn/posts/2022/golang-gmp%E6%A8%A1%E5%9E%8B/</link><pubDate>Wed, 02 Mar 2022 16:45:39 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-gmp%E6%A8%A1%E5%9E%8B/</guid><description>&lt;h3 id="写在前面">写在前面&lt;/h3>
&lt;p>Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下面通过一段简单的代码展示一下 Go 应用程序在运行时的 goroutine，方便大家更好的理解。&lt;/p>
&lt;blockquote>
&lt;p>The Go scheduler is part of the Go runtime, and the Go runtime is built into your application&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">4&lt;/span>; i&lt;span style="color:#00538b">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#5317ac">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time.&lt;span style="color:#721045">Sleep&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(runtime.&lt;span style="color:#721045">NumGoroutine&lt;/span>())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这段代码的输出为：&lt;code>5&lt;/code> 说明当前这个应用程序中存在 &lt;code>goroutine&lt;/code> 的数量是 &lt;code>5&lt;/code>，事实上也符合我们的预期。那么问题来了，这 5 个 goroutine 作为操作系统用户态的基本调度单元是无法直接占用操作系统的资源来执行的，必须经过内核级线程的分发，这是操作系统内部线程调度的基本模型，根据用户级线程和内核级线程的对应关系可以分为 1 对 1，N 对 1 以及 M 对 N 这三种模型，那么上述的 5 个 goroutine 在内核级线程上是怎么被分发的，这就是 Go语言的 goroutine 调度器决定的。&lt;/p></description></item><item><title>Golang-数组与切片常见错误及陷阱</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</link><pubDate>Tue, 15 Feb 2022 16:34:35 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</guid><description>&lt;h2 id="nil切片空切片零切片">nil切片、空切片、零切片&lt;/h2>
&lt;p>&lt;strong>零切片&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s = &lt;span style="color:#8f0075">make&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>, &lt;span style="color:#0000c0">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示底层数组的二进制内容都是零&lt;/p>
&lt;p>&lt;strong>「空切片」和 「nil 切片」&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s1 []&lt;span style="color:#005a5f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s2 = []&lt;span style="color:#005a5f">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s3 = &lt;span style="color:#8f0075">make&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>, &lt;span style="color:#0000c0">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">// new 函数返回是指针类型，所以需要使用 * 号来解引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>&lt;span style="color:#5317ac">var&lt;/span> s4 = &lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#8f0075">new&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#8f0075">len&lt;/span>(s1), &lt;span style="color:#8f0075">len&lt;/span>(s2), &lt;span style="color:#8f0075">len&lt;/span>(s3), &lt;span style="color:#8f0075">len&lt;/span>(s4))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#8f0075">cap&lt;/span>(s1), &lt;span style="color:#8f0075">cap&lt;/span>(s2), &lt;span style="color:#8f0075">cap&lt;/span>(s3), &lt;span style="color:#8f0075">cap&lt;/span>(s4))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(s1, s2, s3, s4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">----------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[] [] [] []
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这四种形式从输出结果上来看，似乎一摸一样，没区别。但是实际上是有区别的，我们要讲的两种特殊类型「空切片」和「 nil 切片」，就隐藏在上面的四种形式之中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s1 []&lt;span style="color:#005a5f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s2 = []&lt;span style="color:#005a5f">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s3 = &lt;span style="color:#8f0075">make&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>, &lt;span style="color:#0000c0">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> s4 = &lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#8f0075">new&lt;/span>([]&lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a1 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a2 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s2))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a3 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s3))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> a4 = &lt;span style="color:#00538b">*&lt;/span>(&lt;span style="color:#00538b">*&lt;/span>[&lt;span style="color:#0000c0">3&lt;/span>]&lt;span style="color:#005a5f">int&lt;/span>)(unsafe.&lt;span style="color:#721045">Pointer&lt;/span>(&lt;span style="color:#00538b">&amp;amp;&lt;/span>s4))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#721045">Println&lt;/span>(a4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00538b">---------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">824634199592&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">824634199592&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中输出为 [0 0 0] 的 s1 和 s4 变量就是「 nil 切片」，s2 和 s3 变量就是「空切片」。824634199592 这个值是一个特殊的内存地址，所有类型的「空切片」都共享这一个内存地址。&lt;/p></description></item><item><title>Golang-代码断行规则</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</link><pubDate>Wed, 02 Feb 2022 16:37:59 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</guid><description>&lt;p>如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。&lt;/p>
&lt;h2 id="分号插入规则">分号插入规则&lt;/h2>
&lt;p>我们在Go编程中常遵循的一个规则是：一个显式代码块的起始左大括号{不放在下一行。 比如，下面这个for循环代码块编译将失败。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; i &amp;gt; &lt;span style="color:#0000c0">0&lt;/span>; i&lt;span style="color:#00538b">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{ &lt;span style="color:#505050">// error: 未预料到的新行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了让上面这个for循环代码块编译成功，我们不能在起始左大括号{前断行，而应该像下面这样进行修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">5&lt;/span>; i &amp;gt; &lt;span style="color:#0000c0">0&lt;/span>; i&lt;span style="color:#00538b">--&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而，有时候起始左大括号{却可以放在一个新行上，比如下面这个for循环代编译时没有问题的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">for&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#505050">// do something ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么，Go代码中的根本性换行规则究竟是如何定义的呢？ 在回答这个问题之前，我们应该知道一个事实：正式的Go语法是使用（英文）分号;做为结尾标识符的。 但是，我们很少在Go代码中使用和看到分号。为什么呢？原因是大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。&lt;/p>
&lt;p>比如，下面这个程序中的十个分号都是可以被省略掉的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> &lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i &lt;span style="color:#005a5f">int&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		sum &lt;span style="color:#005a5f">int&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> i &amp;lt; &lt;span style="color:#0000c0">6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		sum &lt;span style="color:#00538b">+=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i&lt;span style="color:#00538b">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设上面这个程序存储在一个semicolons.go文件中，我们可以运行go fmt semicolons.go将此程序中的不必要的分号去除掉。 在编译时刻，编译器会自动此插入这些去除掉的分号（至此文件的内存中的版本）。&lt;/p>
&lt;p>自动插入分号的规则是什么呢？Go白皮书这样描述：&lt;/p></description></item><item><title>Golang:停止Goroutine有几种方法</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 12 Jan 2022 18:23:23 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>&lt;h3 id="goroutine介绍">goroutine介绍&lt;/h3>
&lt;p>goroutine 是 Go 语言实现并发编程的利器，是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理，简单的一个指令go function就能启动一个 goroutine；Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。&lt;/p>
&lt;p>但是，Go语言并没有提供终止goroutine的接口，也就是说，我们不能从外部去停止一个goroutine，只能由goroutine内部退出(main函数终止除外)；&lt;/p>
&lt;h3 id="goroutine-案例">goroutine 案例&lt;/h3>
&lt;p>日常开发开启一个 goroutine go代码, 只需一个 go 关键字即可:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> wg sync.WaitGroup &lt;span style="color:#505050">// 等待组，用来阻塞程序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Add&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span>) &lt;span style="color:#505050">// 等待组 +1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#5317ac">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;开启 goroutine&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="几种停止的办法">几种停止的办法&lt;/h3>
&lt;p>Go 目前用 channel 或 context 的方式来取消 (cancelation) 给 goroutine。&lt;/p>
&lt;h4 id="channel">Channel&lt;/h4>
&lt;ul>
&lt;li>第一种方法，就是借助 channel 的 close 机制来完成对 goroutine 的精确控制。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	msg &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#8f0075">make&lt;/span>(&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#5317ac">struct&lt;/span>{})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#5317ac">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;[go-routine] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span>msg:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;[go-routine] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#505050">// 必须 return, 否则 goroutine 不会结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;close channel&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#8f0075">close&lt;/span>(msg) &lt;span style="color:#505050">// 直接关闭通道 程序结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>第二种方法，通过定期轮训 channel 其结合了第一种方法和类似信号量的处理方式。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">var&lt;/span> wg sync.WaitGroup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">worker&lt;/span>(in, quit &lt;span style="color:#00538b">&amp;lt;-&lt;/span>&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#005a5f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">defer&lt;/span> wg.&lt;span style="color:#721045">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#5317ac">case&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span>quit:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;收到退出信号&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#5317ac">return&lt;/span> &lt;span style="color:#505050">//必须return，否则goroutine不会结束
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>		&lt;span style="color:#5317ac">case&lt;/span> v &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#00538b">&amp;lt;-&lt;/span>in:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#721045">Println&lt;/span>(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	quit &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#8f0075">make&lt;/span>(&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#005a5f">int&lt;/span>) &lt;span style="color:#505050">//退出通道
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	in &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#8f0075">make&lt;/span>(&lt;span style="color:#5317ac">chan&lt;/span> &lt;span style="color:#005a5f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	wg.&lt;span style="color:#721045">Add&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">go&lt;/span> &lt;span style="color:#721045">worker&lt;/span>(in, quit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#5317ac">for&lt;/span> i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">0&lt;/span>; i &amp;lt; &lt;span style="color:#0000c0">3&lt;/span>; i&lt;span style="color:#00538b">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		in &lt;span style="color:#00538b">&amp;lt;-&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		time.&lt;span style="color:#721045">Sleep&lt;/span>(&lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#00538b">*&lt;/span> time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	quit &lt;span style="color:#00538b">&amp;lt;-&lt;/span> &lt;span style="color:#0000c0">1&lt;/span> &lt;span style="color:#505050">//想通道写入退出信号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#505050">&lt;/span>	wg.&lt;span style="color:#721045">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="context">Context&lt;/h4>
&lt;p>Go 语言的上下文（context）来做 goroutine 的控制和关闭, 对于是一种 tree 结构的goroutine, 要停止 sub tree 使用 channel 的方式不太方便&lt;/p></description></item><item><title>Golang:值传递还是引用传递</title><link>https://blog.ch3nnn.cn/posts/2022/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link><pubDate>Sun, 09 Jan 2022 18:09:14 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid><description>&lt;h2 id="go-官方的定义">Go 官方的定义&lt;/h2>
&lt;p>本部分引用 Go 官方 FAQ 的 “When are function parameters passed by value?”，内容如下。&lt;/p>
&lt;p>如同 C 系列的所有语言一样，Go 语言中的所有东西都是以值传递的。也就是说，一个函数总是得到一个被传递的东西的副本，就像有一个赋值语句将值赋给参数一样。&lt;/p>
&lt;h2 id="传值和传引用">传值和传引用&lt;/h2>
&lt;h3 id="什么是传值值传递">什么是传值（值传递）&lt;/h3>
&lt;p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。&lt;strong>其指的是在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。&lt;/strong> 比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。&lt;/p>
&lt;p>对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。&lt;/p>
&lt;p>test_demo.go&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#2544bb">&amp;#34;testing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">modify&lt;/span>(ip &lt;span style="color:#00538b">*&lt;/span>&lt;span style="color:#005a5f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;函数里接收到的指针的内存地址是：%p\n&amp;#34;&lt;/span>, &lt;span style="color:#00538b">&amp;amp;&lt;/span>ip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#00538b">*&lt;/span>ip = &lt;span style="color:#0000c0">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#5317ac">func&lt;/span> &lt;span style="color:#721045">TestDemo&lt;/span>(t &lt;span style="color:#00538b">*&lt;/span>testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	i &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#0000c0">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ip &lt;span style="color:#00538b">:=&lt;/span> &lt;span style="color:#00538b">&amp;amp;&lt;/span>i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Printf&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;原始指针的内存地址是：%p\n&amp;#34;&lt;/span>, &lt;span style="color:#00538b">&amp;amp;&lt;/span>ip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#721045">modify&lt;/span>(ip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	fmt.&lt;span style="color:#721045">Println&lt;/span>(&lt;span style="color:#2544bb">&amp;#34;int值被修改了，新值为:&amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#000;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>原始指针的内存地址是：0xc00000e038
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>函数里接收到的指针的内存地址是：0xc00000e040
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int值被修改了，新值为: 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="什么是传引用引用传递">什么是传引用(引用传递)&lt;/h3>
&lt;p>传引用，也叫做引用传递， &lt;strong>指在调用函数时将实际参数的地址直接传递到函数中&lt;/strong>，那么在函数中对参数所进行的修改，将影响到实际参数。&lt;/p>
&lt;p>在 Go 语言中，官方已经明确了没有传引用，也就是没有引用传递这一情况。&lt;/p>
&lt;p>&lt;strong>争议最大的 map 和 slice&lt;/strong>
这时候又有小伙伴疑惑了，你看 Go 语言中的 map 和 slice 类型，能直接修改，难道不是同个内存地址，不是引用了？&lt;/p></description></item><item><title>桌面字幕——实时语音翻译</title><link>https://blog.ch3nnn.cn/posts/2022/%E6%A1%8C%E9%9D%A2%E5%AD%97%E5%B9%95%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E7%BF%BB%E8%AF%91/</link><pubDate>Sat, 08 Jan 2022 17:00:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/%E6%A1%8C%E9%9D%A2%E5%AD%97%E5%B9%95%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E7%BF%BB%E8%AF%91/</guid><description>&lt;p>介绍&lt;/p>
&lt;p>这是一个基于Java11 + idea 2021.2.2 有道智能云Ai-实时语音翻译转写实现的翻译桌面字幕。 代码实现非常简单，根据有道智能云开发文档里面的demo代码复制粘贴就完成了。&lt;/p>
&lt;p>实时语音识别的效果不错，可以用于在线小语种教学视频。&lt;/p>
&lt;p>github:&lt;a href="https://github.com/ct437383389/DesktopSubtitles">https://github.com/ct437383389/DesktopSubtitles&lt;/a>&lt;/p>
&lt;p>效果:&lt;/p>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/imgs1642039479710824.gif" alt="">&lt;/p>
&lt;p>技术栈&lt;/p>
&lt;ul>
&lt;li>使用 JavaFx 实现透明窗口 + Label&lt;/li>
&lt;li>Java11&lt;/li>
&lt;/ul>
&lt;p>使用方式&lt;/p>
&lt;p>填写 StreamSpeechTask run方法 智能云 appKey appSecret&lt;/p>
&lt;p>资料&lt;/p>
&lt;ul>
&lt;li>在此感谢大佬提供参考源码实时语音翻译&lt;a href="https://github.com/yi-ge/desktop-subtitle">https://github.com/yi-ge/desktop-subtitle&lt;/a>&lt;/li>
&lt;li>有道智能云实时语音翻译文档&lt;a href="https://ai.youdao.com/streamingAudio.s">https://ai.youdao.com/streamingAudio.s&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Python枚举类自定义状态</title><link>https://blog.ch3nnn.cn/posts/2021/python%E6%9E%9A%E4%B8%BE%E7%B1%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81/</link><pubDate>Thu, 23 Sep 2021 03:02:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2021/python%E6%9E%9A%E4%B8%BE%E7%B1%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81/</guid><description>&lt;ul>
&lt;li>枚举类不支持实例化；&lt;/li>
&lt;li>成员的值不能在类的外部做任何修改，每个成员都有`name`,`value`两个属性，其中`name`为该枚举值的名称，`value`为该枚举值的内容；&lt;/li>
&lt;li>定义枚举时，成员名称不允许重复，但在默认情况下，不同的成员值允许相同，两个相同值的成员，第二个成员的名称将会被视作第一个成员的别名，若要限制不能定义相同值的成员。可以使用装饰器`@unique`；&lt;/li>
&lt;li>枚举支持迭代器，可以遍历枚举成员；如果枚举有值重复的成员，循环遍历枚举时只获取值重复成员的第一个成员，若想把值重复的成员也遍历出来，要用枚举的一个特殊属性:`__members__`；&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>from enum import Enum
from typing import Optional

class BaseEnm(Enum):

 def getCode(self):
 &amp;#34;&amp;#34;&amp;#34;根据枚举名称取状态码code

 @return: 状态码code
 &amp;#34;&amp;#34;&amp;#34;
 return self.value[0]

 def getMessage(self):
 &amp;#34;&amp;#34;&amp;#34;根据枚举名称取状态说明message

 @return: 状态说明message
 &amp;#34;&amp;#34;&amp;#34;
 return self.value[1]

 @classmethod
 def messageByCode(cls, code) -&amp;gt; Optional[str]:
 &amp;#34;&amp;#34;&amp;#34;根据状态码获取状态码说明&amp;#34;&amp;#34;&amp;#34;
 for name, member in cls.__members__.items():
 if code in member.value:
 return cls[name].getMessage()
 return None

@unique
class CallStateResult(BaseEnm):
 &amp;#34;&amp;#34;&amp;#34;通话状态结果&amp;#34;&amp;#34;&amp;#34;

 USER_STATE_NULL = (0, &amp;#34;未知的初始状态&amp;#34;)
 USER_STATE_ANSWERED = (1, &amp;#34;接通&amp;#34;)
 USER_STATE_POWER_OFF = (2, &amp;#34;关机&amp;#34;)
 USER_STATE_NOT_EXIST = (3, &amp;#34;空号&amp;#34;)
 USER_STATE_INVALID_NUM = (4, &amp;#34;非法号码&amp;#34;)
 USER_STATE_OUTSERVICE = (5, &amp;#34;停机&amp;#34;)
 USER_STATE_NOT_IN_SERVICE = (6, &amp;#34;不在服务区&amp;#34;)
 USER_STATE_NOT_ANSWER = (7, &amp;#34;无人接听&amp;#34;)
 USER_STATE_BUSY = (8, &amp;#34;用户忙&amp;#34;)
 USER_STATE_NOT_REACHABLE = (9, &amp;#34;无法接通&amp;#34;)
 USER_STATE_NOT_LOCALNUM_NEED_ZERO = (10, &amp;#34;本地号码未加零&amp;#34;)
 USER_STATE_LOCALNUM_ADD_ZERO = (11, &amp;#34;本地号码多加零&amp;#34;)
 USER_STATE_BARRING_INCOMING = (12, &amp;#34;呼入限制&amp;#34;)
 USER_STATE_CALL_REMINDER = (13, &amp;#34;来电提醒&amp;#34;)
 USER_STATE_DEFAULTING = (14, &amp;#34;欠费&amp;#34;)
 USER_STATE_LINE_BUSY = (15, &amp;#34;网络忙&amp;#34;)
 USER_STATE_FORWARDED = (16, &amp;#34;呼叫转移失败&amp;#34;)
 USER_STATE_CANNOT_CONNECTED = (17, &amp;#34;无法接听&amp;#34;)
 USER_STATE_NUMBER_CHANGE = (18, &amp;#34;改号&amp;#34;)
 USER_STATE_LINE_FAULT = (19, &amp;#34;线路故障&amp;#34;)
 USER_STATE_CALL_REJECTED = (20, &amp;#34;拒接&amp;#34;)
 USER_STATE_NOT_RECOGNITION = (21, &amp;#34;未知状态&amp;#34;)
 USER_STATE_CALL_FAILED = (22, &amp;#34;呼叫失败&amp;#34;)
 USER_STATE_HANGUP = (100, &amp;#34;通话结束&amp;#34;)


if __name__ == &amp;#39;__main__&amp;#39;:
 print(CallStateResult.USER_STATE_NULL)
 print(CallStateResult.USER_STATE_NULL.getCode())
 print(CallStateResult.USER_STATE_NULL.getMessage())
 print(CallStateResult.messageByCode(0))
&lt;/code>&lt;/pre>&lt;p>输出&lt;/p></description></item><item><title>Github标星34K+Star，这款开源项目助你秒建Git服务！</title><link>https://blog.ch3nnn.cn/posts/2021/github%E6%A0%87%E6%98%9F34k+star%E8%BF%99%E6%AC%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E7%A7%92%E5%BB%BAgit%E6%9C%8D%E5%8A%A1/</link><pubDate>Tue, 06 Jul 2021 09:01:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2021/github%E6%A0%87%E6%98%9F34k+star%E8%BF%99%E6%AC%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E7%A7%92%E5%BB%BAgit%E6%9C%8D%E5%8A%A1/</guid><description>&lt;blockquote>
&lt;p>以前使用Gitlab搭建过Git服务，如果服务器配置低的话启动和访问都会特别慢。最近发现了Gogs这个开源项目，安装方便，特别轻量级，推荐给大家！&lt;/p>
&lt;/blockquote>
&lt;h2 id="推荐语httpwwwmacrozhengcomreferencegogs_startide68ea8e88d90e8afad">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e6%8e%a8%e8%8d%90%e8%af%ad">推荐语&lt;/a>&lt;/h2>
&lt;p>一款极易搭建的自助Git服务，特别轻量级，推荐给大家！&lt;/p>
&lt;h2 id="gogs简介httpwwwmacrozhengcomreferencegogs_startidgogse7ae80e4bb8b">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=gogs%e7%ae%80%e4%bb%8b">Gogs简介&lt;/a>&lt;/h2>
&lt;p>Gogs是一款极易搭建的自助Git服务，使用Go语言开发，只要Go语言支持的平台它都支持，包括Linux、Mac OS X、Windows以及ARM平台。Gogs对系统硬件要求极低，你甚至可以在树莓派上搭建它。&lt;/p>
&lt;p>项目地址：&lt;a href="https://github.com/gogs/gogs">https://github.com/gogs/gogs&lt;/a>&lt;/p>
&lt;h2 id="安装httpwwwmacrozhengcomreferencegogs_startide5ae89e8a385">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e5%ae%89%e8%a3%85">安装&lt;/a>&lt;/h2>
&lt;blockquote>
&lt;p>Gogs在Docker环境下的安装非常简单，只需要两个命令即可，推荐使用该方式来进行安装。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>首先我们需要先下载Gogs的Docker镜像；&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>下载完成后使用`docker run`命令即可运行服务；
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>docker run -p 10022:22 -p 10080:3000 --name=gogs \
-v /mydata/gogs:/data \
-d gogs/gogsCopy to clipboardErrorCopied
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>这里我们说下命令中值得注意的地方，&lt;code>10022&lt;/code>对应的是Gogs的SSH服务端口，&lt;code>10080&lt;/code>对应的使用Gogs的HTTP服务端口，我们还将容器的数据目录挂载到了宿主机的&lt;code>/mydata/gogs&lt;/code>目录下，这样就算我们重新创建容器数据也不会丢失。&lt;/li>
&lt;/ul>
&lt;h2 id="配置httpwwwmacrozhengcomreferencegogs_startide9858de7bdae">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e9%85%8d%e7%bd%ae">配置&lt;/a>&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>安装完成后，我们第一次访问Gogs服务会显示一个设置页面，访问地址：&lt;a href="http://192.168.5.19:10080/">http://192.168.5.19:10080/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库设置，这里我们直接使用内置的&lt;code>SQLite3&lt;/code>数据库即可，使用其他的需要自行搭建数据库；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/353398c25df244cfb5c273e05b4c8717.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;img src="http://www.macrozheng.com/images/gogs_start_01.png" alt="">&lt;img src="http://www.macrozheng.com/images/gogs_start_01.png" alt="">&lt;/p>
&lt;ul>
&lt;li>应用基本设置，主要修改域名、SSH端口号和应用URL即可。&lt;/li>
&lt;li>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/c1c4936ed1184085a60c7b1c567bb7b4.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_02.png" alt="">&lt;/p>
&lt;h2 id="使用httpwwwmacrozhengcomreferencegogs_startide4bdbfe794a8">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e4%bd%bf%e7%94%a8">使用&lt;/a>&lt;/h2>
&lt;h3 id="注册httpwwwmacrozhengcomreferencegogs_startide6b3a8e5868c">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e6%b3%a8%e5%86%8c">注册&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>配置好以后会直接跳转到登录界面，首先注册一个帐户；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/8c04efbec38f4ba0b160201de9fe2e6b.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;img src="http://www.macrozheng.com/images/gogs_start_03.png" alt="">&lt;/p>
&lt;ul>
&lt;li>注册完成后，登录即可进入控制面板页面。&lt;/li>
&lt;li>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/98c5b485a2244a6cb9b24fd433ff92e2.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_04.png" alt="">&lt;/p>
&lt;h3 id="创建仓库httpwwwmacrozhengcomreferencegogs_startide5889be5bbbae4bb93e5ba93">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e5%88%9b%e5%bb%ba%e4%bb%93%e5%ba%93">创建仓库&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>直接使用我的仓库右侧的加号即可创建仓库，简单设置下仓库名称和可见性来完成创建；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_05.png" alt="">&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/64ad3cc9a46649568192393fe36e6625.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/p>
&lt;ul>
&lt;li>创建成功后直接使用克隆地址即可克隆该仓库；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_06.png" alt="">&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/653c0aea561a4910b9e5821c8052d98d.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/p>
&lt;ul>
&lt;li>我们可以直接使用IDEA的Git检出功能；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/79b6c325222847abb4914354c4d09c06.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;img src="http://www.macrozheng.com/images/gogs_start_07.png" alt="">&lt;/p>
&lt;ul>
&lt;li>检出完成后，加入我们的代码直接提交、推送，在Gogs里面就可以看到我们提交的代码了。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_08.png" alt="">&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/2cb90e1a6d674b74b9be06db5970ec55.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/p>
&lt;h3 id="工单管理httpwwwmacrozhengcomreferencegogs_startide5b7a5e58d95e7aea1e79086">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e5%b7%a5%e5%8d%95%e7%ae%a1%e7%90%86">工单管理&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>这里的工单管理，有点类似Github上面的Issue的功能，我们可以通过&lt;code>创建工单&lt;/code>按钮来创建；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/94e6d362a1d74ec484c6c1bece80003e.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/p>
&lt;ul>
&lt;li>输入我们的标题、内容和标签以后即可创建；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_10.png" alt="">&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/f96232baa1c3418ababa67a405a4acb8.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;/p>
&lt;ul>
&lt;li>创建完成后显示效果如下。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.ch3nnn.cn/upload/2021/07/02/de43c3f2c8c044909b9359f31080f8e0.png?imageMogr2/auto-orient/thumbnail/1000x/interlace/1/blur/1x0/quality/95%7Cwatermark/2/text/Q2gzbm5ubm7nmoTljZrlrqIgfOaKmOiFvuS4jeaBryDCtyDkuZDmraTkuI3nlrI=/font/6buR5L2T/fontsize/260/fill/I0ZDRkNGQw==/dissolve/75/gravity/SouthEast/dx/10/dy/10" alt="">&lt;img src="http://www.macrozheng.com/images/gogs_start_11.png" alt="">&lt;/p>
&lt;h3 id="添加用户httpwwwmacrozhengcomreferencegogs_startide6b7bbe58aa0e794a8e688b7">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e6%b7%bb%e5%8a%a0%e7%94%a8%e6%88%b7">添加用户&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>有时候管理员需要新建一些帐户来协作开发，此时我们只要点击&lt;code>头像-&amp;gt;管理面板-&amp;gt;用户管理&lt;/code>即可打开用户管理界面；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_12.png" alt="">&lt;/p>
&lt;ul>
&lt;li>然后点击&lt;code>创建新的帐户&lt;/code>，输入相关信息即可完成创建。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_13.png" alt="">&lt;/p>
&lt;h3 id="管理协作者httpwwwmacrozhengcomreferencegogs_startide7aea1e79086e58d8fe4bd9ce88085">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e7%ae%a1%e7%90%86%e5%8d%8f%e4%bd%9c%e8%80%85">管理协作者&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>创建完成后，我们可以在仓库页面的&lt;code>仓库设置&lt;/code>中打开&lt;code>管理协作者&lt;/code>功能；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_14.png" alt="">&lt;/p>
&lt;ul>
&lt;li>之后通过输入协作者账户，点击&lt;code>增加新的协作者&lt;/code>并设置好权限即可，这样协作者就可以访问并向该仓库提交代码了。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_15.png" alt="">&lt;/p>
&lt;h3 id="迁移外部仓库httpwwwmacrozhengcomreferencegogs_startide8bf81e7a7bbe5a496e983a8e4bb93e5ba93">&lt;a href="http://www.macrozheng.com/#/reference/gogs_start?id=%e8%bf%81%e7%a7%bb%e5%a4%96%e9%83%a8%e4%bb%93%e5%ba%93">迁移外部仓库&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>Gogs还提供了从外部仓库迁移代码的功能，通过头像左侧的加号，然后选择&lt;code>迁移外部仓库&lt;/code>即可；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.macrozheng.com/images/gogs_start_16.png" alt="">&lt;/p></description></item><item><title>更换（Pypi）pip源到国内镜像</title><link>https://blog.ch3nnn.cn/posts/2021/%E6%9B%B4%E6%8D%A2pypipip%E6%BA%90%E5%88%B0%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 22 Feb 2021 03:09:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2021/%E6%9B%B4%E6%8D%A2pypipip%E6%BA%90%E5%88%B0%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</guid><description>&lt;h3 id="pip国内的一些镜像">pip国内的一些镜像&lt;/h3>
&lt;ul>
&lt;li>阿里云&lt;a href="http://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/&lt;/a>&lt;/li>
&lt;li>中国科技大学&lt;a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/&lt;/a>&lt;/li>
&lt;li>豆瓣(douban)&lt;a href="http://pypi.douban.com/simple/">https://pypi.douban.com/simple/&lt;/a>&lt;/li>
&lt;li>清华大学&lt;a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/&lt;/a>&lt;/li>
&lt;li>中国科学技术大学&lt;a href="http://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>提示：若担心安全问题请使用HTTPS加密源&lt;/strong>&lt;/p>
&lt;h3 id="修改源方法">修改源方法：&lt;/h3>
&lt;h4 id="临时使用">临时使用：&lt;/h4>
&lt;p>&lt;strong>Linux Mac Windows 通用命令&lt;/strong>&lt;/p>
&lt;p>可以在使用pip的时候在后面加上-i参数，指定pip源&lt;/p>
&lt;blockquote>
&lt;p>pip install scrapy -i&lt;a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h4 id="永久修改">永久修改：&lt;/h4>
&lt;p>&lt;strong>Linux:&lt;/strong>&lt;/p>
&lt;p>修改 pip.conf 文件 (没有就创建一个)&lt;/p>
&lt;blockquote>
&lt;p>$HOME/.config/pip/pip.conf&lt;/p>
&lt;/blockquote>
&lt;p>修改内容如下：&lt;/p>
&lt;blockquote>
&lt;p>[global]&lt;/p>
&lt;p>index-url =&lt;a href="https://pypi.tuna.tsinghua.edu.cn/simple12">https://pypi.tuna.tsinghua.edu.cn/simple12&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Mac:&lt;/strong>&lt;/p>
&lt;p>修改 pip.conf 文件&lt;/p>
&lt;blockquote>
&lt;p>$HOME/Library/Application Support/pip/pip.conf&lt;/p>
&lt;/blockquote>
&lt;p>如果没有上面的目录,在如下目录创建 pip.conf&lt;/p>
&lt;blockquote>
&lt;p>$HOME/.config/pip/pip.conf&lt;/p>
&lt;/blockquote>
&lt;p>修改内容如下：&lt;/p>
&lt;blockquote>
&lt;p>[global]&lt;/p>
&lt;p>index-url =&lt;a href="https://pypi.tuna.tsinghua.edu.cn/simple12">https://pypi.tuna.tsinghua.edu.cn/simple12&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Windows:&lt;/strong>&lt;/p>
&lt;p>修改 pip.conf 文件 (没有就创建一个)&lt;/p>
&lt;blockquote>
&lt;p>%APPDATA%\pip\pip.ini&lt;/p>
&lt;/blockquote>
&lt;p>修改内容如下：&lt;/p>
&lt;blockquote>
&lt;p>[global]&lt;/p>
&lt;p>index-url =&lt;a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="修改文件后执行命令发生错误">修改文件后，执行命令发生错误&lt;/h3>
&lt;p>使用非HTTPS加密源（如豆瓣源），在执行命令发生错误，在命令最后加上&lt;code>--trusted-host pypi.douban.com&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>pip install django -i&lt;a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple&lt;/a>&amp;ndash;trusted-host&lt;a href="http://pypi.douban.com/">pypi.douban.com&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Python 使用-gRPC详解</title><link>https://blog.ch3nnn.cn/posts/2020/grpc%E8%AF%A6%E8%A7%A3/</link><pubDate>Thu, 24 Dec 2020 09:05:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/grpc%E8%AF%A6%E8%A7%A3/</guid><description>&lt;h2 id="rpc-框架原理">RPC 框架原理&lt;/h2>
&lt;p>&lt;strong>RPC 框架的目标就是让远程服务调用更加简单、透明&lt;/strong>，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。&lt;strong>服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。&lt;/strong>&lt;/p>
&lt;p>RPC 框架的调用原理图如下所示：&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2023/03/10/E4o5iRd3KuaH2Fg.png" alt="">&lt;/p>
&lt;h2 id="grpc是什么">gRPC是什么？&lt;/h2>
&lt;p>&lt;a href="https://www.grpc.io/docs/languages/python/quickstart/">官方文档-Python&lt;/a>&lt;/p>
&lt;p>gRPC是什么可以用官网的一句话来概括&lt;/p>
&lt;blockquote>
&lt;p>A high-performance, open-source universal RPC framework&lt;/p>
&lt;/blockquote>
&lt;p>**所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。**如下图所示就是一个典型的RPC结构图。&lt;/p>
&lt;p>&lt;img src="https://www.grpc.io/img/landing-2.svg" alt="概念图">&lt;/p>
&lt;h2 id="grpc有什么好处以及在什么场景下需要用grpc">gRPC有什么好处以及在什么场景下需要用gRPC&lt;/h2>
&lt;p>既然是server/client模型，那么我们直接用restful api不是也可以满足吗，为什么还需要RPC呢？下面我们就来看看RPC到底有哪些优势&lt;/p>
&lt;h2 id="grpc-vs-restful-api">gRPC vs. Restful API&lt;/h2>
&lt;p>gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：&lt;/p>
&lt;ul>
&lt;li>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文&lt;a href="https://www.jianshu.com/p/b723053a86a6">Google Protobuf简明教程&lt;/a>&lt;/li>
&lt;li>另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。&lt;/li>
&lt;li>gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）&lt;/li>
&lt;/ul>
&lt;h2 id="grpc-helloworld实例详解">gRPC HelloWorld实例详解&lt;/h2>
&lt;p>gRPC的使用通常包括如下几个步骤：&lt;/p>
&lt;ol>
&lt;li>通过protobuf来定义接口和数据类型&lt;/li>
&lt;li>编写gRPC server端代码&lt;/li>
&lt;li>编写gRPC client端代码&lt;br>
下面来通过一个实例来详细讲解上述的三步。&lt;br>
下边的hello world实例完成之后，其目录结果如下：&lt;/li>
&lt;/ol>
&lt;h3 id="定义接口和数据类型">定义接口和数据类型&lt;/h3>
&lt;ul>
&lt;li>通过protobuf定义接口和数据类型&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>syntax = &amp;#34;proto3&amp;#34;;

package rpc_package;

// define a service
service HelloWorldService {
 // define the interface and data type
 rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// define the data type of request
message HelloRequest {
 string name = 1;
}

// define the data type of response
message HelloReply {
 string message = 1;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>使用gRPC protobuf生成工具生成对应语言的库函数&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>python -m grpc_tools.protoc -I=./protos --python_out=./rpc_package --grpc_python_out=./rpc_package ./protos/user_info.proto
&lt;/code>&lt;/pre>&lt;p>这个指令会自动生成rpc_package文件夹中的&lt;code>helloworld_pb2.py&lt;/code>和&lt;code>helloworld_pb2_grpc.py&lt;/code>，但是不会自动生成&lt;code>__init__.py&lt;/code>文件，需要我们手动添加&lt;/p></description></item><item><title>PostmanCn:Postman中文版</title><link>https://blog.ch3nnn.cn/posts/2020/postmancnpostman%E4%B8%AD%E6%96%87%E7%89%88/</link><pubDate>Mon, 21 Dec 2020 08:30:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/postmancnpostman%E4%B8%AD%E6%96%87%E7%89%88/</guid><description>&lt;p>最新版本：7.36.1&lt;/p>
&lt;p>更新时间：2020-12-18&lt;/p>
&lt;p>&lt;a href="https://gitee.com/hlmd/PostmanCn/releases">点击下载&lt;/a>&lt;/p>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2023/03/10/qshiEJkpWYAZBjO.png" alt="">&lt;/p>
&lt;p>Postman中文版 汉化 持续更新中&lt;/p>
&lt;h2 id="安装教程">安装教程&lt;/h2>
&lt;h3 id="windows">Windows&lt;/h3>
&lt;p>Postman-*-win64-中文版.zip 解压直接用&lt;/p>
&lt;p>app.zip 解压&amp;amp;&amp;amp;替换文件 应用程序目录/resources/app.asar&lt;/p>
&lt;h3 id="mac">Mac&lt;/h3>
&lt;p>&lt;a href="https://www.postman.com/downloads/">Postman官网&lt;/a>下载&amp;amp;安装Postman Mac版&lt;/p>
&lt;p>&lt;a href="https://gitee.com/hlmd/PostmanCn/releases">下载 Postman-*-Mac-汉化版&lt;/a>app.zip&lt;/p>
&lt;p>复制到 Postman安装目录 /&amp;hellip;/Postman.app/Contents/Resources/&lt;/p>
&lt;p>解压 替换 app目录即可&lt;/p>
&lt;h3 id="linux">Linux&lt;/h3>
&lt;p>解压 替换 app目录即可&lt;/p>
&lt;p>&lt;a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/&lt;/a>这个是Postman官网的下载页面&lt;/p>
&lt;p>&lt;a href="https://gitee.com/hlmd/PostmanCn/">https://gitee.com/hlmd/PostmanCn/&lt;/a>这个是这里的汉化的&lt;/p></description></item><item><title>MacOS开启外接显示器HiDP</title><link>https://blog.ch3nnn.cn/posts/2020/macos%E5%BC%80%E5%90%AF%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8hidp/</link><pubDate>Tue, 01 Dec 2020 03:05:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/macos%E5%BC%80%E5%90%AF%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8hidp/</guid><description>&lt;p>&lt;strong>对以下系统和显示器有效：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>macOS 10.12 Sierra&lt;/p>
&lt;/li>
&lt;li>
&lt;p>macOS 10.13 High Sierra&lt;/p>
&lt;/li>
&lt;li>
&lt;p>macOS 10.14 Mojave&lt;/p>
&lt;/li>
&lt;li>
&lt;p>macOS 10.15 Catalina&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dell P2416D, DisplayPort, 1920x1080 HiDPI&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dell P2418D, DisplayPort, 1920x1080 HiDPI&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Acer XB241YU, HDMI, 1920x1080 HiDPI&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="0x1-准备工作">0x1 准备工作：&lt;/h2>
&lt;h3 id="1-打开系统hidpi-在终端运行">1. 打开系统HiDPI (在终端运行）&lt;/h3>
&lt;pre tabindex="0">&lt;code>sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES
&lt;/code>&lt;/pre>&lt;p>如果使用 4K 或更高分辨率的显示器，macOS 很可能原生支持 HiDPI，建议直接从&lt;a href="https://wacky.one/blog/macos-hi-dpi/#rdm">5. 下载 RDM&lt;/a>尝试选择 HiDPI 分辨率。如无法启用或没有合适的分辨率，再使用配置文件。&lt;/p>
&lt;h2 id="0x2-获得显示器信息">0x2 获得显示器信息&lt;/h2>
&lt;p>获得显示器的 VendorID 和 ProductID （制造商ID 和 产品ID），在终端运行：&lt;/p>
&lt;pre tabindex="0">&lt;code>ioreg -lw0 | grep IODisplayPrefsKey | grep -o &amp;#39;/[^/]\+&amp;#34;$&amp;#39;
&lt;/code>&lt;/pre>&lt;p>输出大概是这样的：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; ioreg -lw0 | grep IODisplayPrefsKey | grep -o &amp;#39;/[^/]\+&amp;#34;$&amp;#39;
/AppleBacklightDisplay-610-a029&amp;#34;
/AppleDisplay-10ac-a0c4&amp;#34;
&lt;/code>&lt;/pre>&lt;p>这条指令的输出会有多个，注意识别你想要调整的显示器。第一条&lt;code>AppleBacklightDisplay-610-a029&lt;/code>是MBP的内置显示屏。第二个是外接显示器。（当然，也可以合上 MBP 屏幕，这样只会输出正在使用的外接显示器）&lt;/p></description></item><item><title>Navicat Premium 15.0.22 中文语言包</title><link>https://blog.ch3nnn.cn/posts/2020/navicatpremium15.0.22%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/</link><pubDate>Mon, 09 Nov 2020 10:57:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/navicatpremium15.0.22%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/</guid><description>&lt;p>Navicat Premium是一个可多重连接的数据库管理工具，Navicat 的功能足以符合专业开发人员的所有需求，但是对数据库服务器的新手来说又相当容易学习。它可让你以单一程序同時连接到目前世面上所有版本的主流数据库并进行管理和操作，支持的数据库有： MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL。让管理不同类型的数据库更加方便。&lt;/p>
&lt;h2 id="汉化包">汉化包&lt;/h2>
&lt;ul>
&lt;li>15.0.12 汉化&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>下载&lt;a href="https://t00y.com/file/13114864-433055695">链接: https://pan.baidu.com/s/1SITpWMdXfBhYlis-YL14Tg 密码: vljg&lt;/a>中文包&lt;/li>
&lt;li>解压复制&lt;code>汉化文件夹&lt;/code>放到&lt;code>/Applications/Navicat Premium.app/Contents/Resources&lt;/code>&lt;/li>
&lt;li>汉化完成&lt;br>
PS:这个&lt;code>zh-Hans.lproj&lt;/code>汉化文件是从&lt;code>Navicat Premium&lt;/code>官方中文版提取 无毒无害&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>12.0.12 汉化&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>下载&lt;a href="https://www.pipipan.com/fs/13114864-217250713">https://www.pipipan.com/fs/13114864-217250713&lt;/a>中文包&lt;/li>
&lt;li>复制&lt;code>汉化文件夹&lt;/code>放到&lt;code>/Applications/Navicat Premium.app/Contents/Resources&lt;/code>&lt;/li>
&lt;li>汉化完成&lt;br>
PS:这个&lt;code>zh-Hans.lproj&lt;/code>汉化文件是从&lt;code>Navicat Premium 12.0.12&lt;/code>官方中文版提取 无毒无害&lt;/li>
&lt;/ol></description></item><item><title>「超级右键」Mac上最强的右键菜单工具，让你效率飞起！</title><link>https://blog.ch3nnn.cn/posts/2020/%E8%B6%85%E7%BA%A7%E5%8F%B3%E9%94%AEmac%E4%B8%8A%E6%9C%80%E5%BC%BA%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E6%95%88%E7%8E%87%E9%A3%9E%E8%B5%B7/</link><pubDate>Mon, 26 Oct 2020 15:03:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/%E8%B6%85%E7%BA%A7%E5%8F%B3%E9%94%AEmac%E4%B8%8A%E6%9C%80%E5%BC%BA%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E6%95%88%E7%8E%87%E9%A3%9E%E8%B5%B7/</guid><description>&lt;h2 id="简介">简介&lt;/h2>
&lt;p>我对该产品的评价只有六个字：&lt;strong>实用、效率、快、得我心&lt;/strong>&lt;/p>
&lt;h4 id="超级右键主要实现了">超级右键主要实现了：&lt;/h4>
&lt;p>Mac电脑上右键的扩展，能够新建、发送/复制文件到某个位置、快速打开常用目录、自定义文件夹图标、拷贝路径、终端/iTerm/VSCode 里进入路径、显示隐藏文件、彻底删除文件、剪切粘贴文件、百度翻译、谷歌翻译、右键截图、标注、贴图等等。&lt;/p>
&lt;p>**「超级右键」**有一部分功能是借鉴Windows系统的，也有开发者自己新创的功能，总的来说功能完善，且使用快捷，是目前Mac上最强大的右键工具，绝对是Mac用户装机必备。&lt;/p>
&lt;h2 id="功能">功能&lt;/h2>
&lt;hr>
&lt;h3 id="1新建文件">1.新建文件&lt;/h3>
&lt;p>**默认支持新建：**TXT/RTF/XML/Word/Excel/PPT/WPS文字/WPS表格/WPS演示/Pages/Numbers/Keynote/Ai/PSD/Markdown格式的文件。&lt;/p>
&lt;p>&lt;strong>同时还支持&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>用户自定义添加其他类型文件进行新建。&lt;/li>
&lt;li>新建后自动打开文件&lt;/li>
&lt;li>新建的时候启用弹窗，命名文件名和文件位置&lt;/li>
&lt;li>将新建的文件类型添加到一级菜单目录&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/c4a86da3f4e1a3a6b582032497529ad2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>新建文件&lt;/p>
&lt;hr>
&lt;h3 id="2复制发动文件到指定路径">2.复制/发动文件到指定路径&lt;/h3>
&lt;p>这个功能可以说非常的实用，以前在Mac上要转移文件的位置，很多时候要先拷贝，然后一层层的打开路径，很费事，有了超级右键，一键发动到位，很方便。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/b6424ddf26f55836647bd01d207a756e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>复制文件到&lt;/p>
&lt;hr>
&lt;h3 id="3常用目录">3.常用目录&lt;/h3>
&lt;p>**「超级右键」**允许用户自定义常用目录，然后使用右键快速打开，非常方便。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/2d3a377f21a42d3e4f087eb5aeaccaeb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>常用目录&lt;/p>
&lt;hr>
&lt;h3 id="4自定义文件夹图标">4.自定义文件夹图标&lt;/h3>
&lt;p>很多时候，你可能已经厌倦了千篇一律的蓝色文件，想给文件夹带去一点色彩，变得个性化，从视觉上好分辨一些，**「超级右键」**就能帮你轻松办到。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/b49808c80aa6988d240ed8635e0c12a3.gif" alt="">&lt;/p>
&lt;p>自定义文件夹图标&lt;/p>
&lt;hr>
&lt;h3 id="5剪切粘贴">5.剪切、粘贴&lt;/h3>
&lt;p>Mac上本来是没有剪切功能的，从Windows转Mac的朋友们肯定觉得不习惯吧。**「超级右键」**为右键新增了剪切、粘贴功能，使用起来非常顺手。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/937b6aeeffbb757361eb4610a3a33ba9.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>剪切、粘贴&lt;/p>
&lt;hr>
&lt;h3 id="6截图">6.截图&lt;/h3>
&lt;p>Better 365将超级右键与其截图工具&lt;strong>iShot&lt;/strong>进行了联动，可以使用右键调用进行截图，前提是你必须安装了iShot。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/e6ca133487d8435e77fdc2a4a4d8477f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>右键截图&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/10e9728d46f3f131f74015a8b7c49b37.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>截图&lt;/p>
&lt;hr>
&lt;h3 id="7贴图标注">7.贴图、标注&lt;/h3>
&lt;p>你还可以直接选中本地已存在的图片，将其贴图，并标记&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/17cdc770ce8d115fd1a3180645757bbf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>贴图标注&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/92e81f3e1f53cf6595ba3000c24b9387.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>贴图标注&lt;/p>
&lt;h3 id="8拷贝当前路径">8.拷贝当前路径&lt;/h3>
&lt;p>**「超级右键」**可以让你非常方便的拷贝路径，省去手码路径的麻烦。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/aecadcae439b106828c1103bec249ffb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>拷贝当前路径&lt;/p>
&lt;hr>
&lt;h3 id="9终端itermvscodesublime-text里打开">9、终端、iTerm、VSCode、Sublime Text里打开&lt;/h3>
&lt;p>如果你需要在终端、等工具里打开文件、路径等，**「超级右键」**也将助你快人一步。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/479c1a31c4e5dc723ee409477c21f598.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;h3 id="终端itermvscode等打开">终端、iTerm、VScode等打开&lt;/h3>
&lt;hr>
&lt;h3 id="10显示隐藏文件">10.显示/隐藏文件&lt;/h3>
&lt;p>你可以快速地隐藏你电脑上的文件，保护隐私，只有你知道如何显示&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/24/d1b2e32aa76d6ca56eb4bb423c020571.gif" alt="">&lt;/p>
&lt;p>显示/隐藏文件&lt;/p>
&lt;hr>
&lt;h3 id="11彻底删除">11.彻底删除&lt;/h3>
&lt;p>彻底删除允许我们不经过废纸篓，直接删掉文件。&lt;/p>
&lt;hr>
&lt;h3 id="12百度翻译谷歌翻译转化为二维码">12.百度翻译、谷歌翻译、转化为二维码&lt;/h3>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/25/50e1177750f41680f5b2169297178e37.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>请输入图片标题&lt;/p>
&lt;p>听我说了这么多，不去下载安装体验一把，还在等什么呢？在App Store搜索“超级右键”就可以免费下载啦，快让你快人一步吧！&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2020/02/25/6ce9c92234c9e054e2083cfc29ae608e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="">&lt;/p>
&lt;p>请输入图片标题&lt;/p></description></item><item><title>Zeal——好用的离线API文档大全</title><link>https://blog.ch3nnn.cn/posts/2020/zeal%E5%A5%BD%E7%94%A8%E7%9A%84%E7%A6%BB%E7%BA%BFapi%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8/</link><pubDate>Mon, 14 Sep 2020 04:39:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/zeal%E5%A5%BD%E7%94%A8%E7%9A%84%E7%A6%BB%E7%BA%BFapi%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8/</guid><description>&lt;p>Zeal是一款离线文档浏览器，其灵感来自 OS X平台上的 Dash，目前支持 Window 和 Liunx。基于 QT5。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>支持呼出热键。只要按下组合箭 ALT+Space 即可在任何地方显示面板，不用时可以用热键隐藏的系统托盘。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可同时搜索多个文档&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不依赖网络&lt;/p>
&lt;/li>
&lt;li>
&lt;p>GPL 协议开放源码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dash 中的文档都可以在 Zeal 中使用。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>安装：&lt;/strong>&lt;/p>
&lt;p>WIndows 自带二进制安装包&lt;/p>
&lt;p>Linux 需要安装 QT( &amp;gt;= 5) 和 bsdtar。&lt;/p>
&lt;p>&lt;strong>软件截图：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="http://static.oschina.net/uploads/space/2014/0115/132355_IQHW_184649.png" alt="">&lt;/p>
&lt;p>&lt;img src="http://static.oschina.net/uploads/space/2014/0115/132411_qXTS_184649.png" alt="">&lt;/p></description></item><item><title>简洁的 Mac 图床客户端 uPic</title><link>https://blog.ch3nnn.cn/posts/2020/%E7%AE%80%E6%B4%81%E7%9A%84mac%E5%9B%BE%E5%BA%8A%E5%AE%A2%E6%88%B7%E7%AB%AFupic/</link><pubDate>Sun, 28 Jun 2020 14:01:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/%E7%AE%80%E6%B4%81%E7%9A%84mac%E5%9B%BE%E5%BA%8A%E5%AE%A2%E6%88%B7%E7%AB%AFupic/</guid><description>&lt;p>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic/logo.png">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic/logo.png" alt="uPic">&lt;/a>&lt;/p>
&lt;h1 id="-简洁的-mac-图床客户端-upic">☁️ 简洁的 Mac 图床客户端 uPic&lt;/h1>
&lt;h2 id="-简介">📑 简介&lt;/h2>
&lt;blockquote>
&lt;p>&lt;strong>uPic(upload Picture) 是一款 Mac 端的图床(文件)上传客户端&lt;/strong>&lt;br>
可将图片、各种文件上传到配置好的指定提供商的对象存储中。&lt;br>
然后快速获取可供互联网访问的文件 URL&lt;/p>
&lt;/blockquote>
&lt;p>**💡 特点：**无论是本地文件、或者屏幕截图都可自动上传，菜单栏显示实时上传进度。上传完成后文件链接自动复制到剪切板，让你无论是在写博客、灌水聊天都能快速插入图片。&lt;br>
连接格式可以是普通 URL、HTML 或者 Markdown，仍由你掌控。&lt;/p>
&lt;p>&lt;strong>🔋 支持图床：&lt;/strong>&lt;a href="https://sm.ms/">smms&lt;/a>、&lt;a href="https://www.upyun.com/products/file-storage">又拍云 USS&lt;/a>、&lt;a href="https://www.qiniu.com/products/kodo">七牛云 KODO&lt;/a>、&lt;a href="https://www.aliyun.com/product/oss/">阿里云 OSS&lt;/a>、&lt;a href="https://cloud.tencent.com/product/cos">腾讯云 COS&lt;/a>、&lt;a href="https://weibo.com/">微博&lt;/a>、&lt;a href="https://github.com/settings/tokens">Github&lt;/a>、&lt;a href="https://gitee.com/profile/personal_access_tokens">Gitee&lt;/a>、&lt;a href="https://aws.amazon.com/cn/s3/">Amazon S3&lt;/a>、&lt;a href="https://blog.svend.cc/upic/tutorials/custom">自定义上传接口&lt;/a>、…&lt;/p>
&lt;h2 id="-如何安装">🚀 如何安装&lt;/h2>
&lt;h3 id="下载安装">下载安装&lt;/h3>
&lt;h4 id="1homebrew">1.Homebrew:&lt;/h4>
&lt;pre tabindex="0">&lt;code>brew cask install upic
&lt;/code>&lt;/pre>&lt;h4 id="2手动">2.手动&lt;/h4>
&lt;p>从&lt;a href="https://github.com/gee1k/uPic/releases">Github release&lt;/a>下载。&lt;br>
&lt;strong>如果访问 Github 下载困难的，可以从&lt;a href="https://gitee.com/gee1k/uPic/releases">Gitee release&lt;/a>下载。&lt;/strong>&lt;/p>
&lt;h3 id="检查-finder-扩展权限">检查 Finder 扩展权限&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>1.打开 uPic&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2.打开&lt;code>系统偏好设置&lt;/code>-&lt;code>扩展&lt;/code>-&lt;code>访达扩展&lt;/code>确保&lt;code>uPicFinderExtension&lt;/code>是勾选状态&lt;/p>
&lt;p>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/finder-extension.png">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/finder-extension.png" alt="">&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="-使用方式">🕹 使用方式&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>功能&lt;/th>
 &lt;th>描述&lt;/th>
 &lt;th>预览&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>🖥 选择文件上传&lt;/strong>&lt;/td>
 &lt;td>从&lt;code>Finder&lt;/code>选择文件上传。&lt;code>可设置全局快捷键&lt;/code>&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/selectFile.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/selectFile.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>⌨️ 复制文件上传&lt;/strong>&lt;/td>
 &lt;td>上传已拷贝到剪切板的文件。&lt;code>可设置全局快捷键&lt;/code>&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/pasteboard.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/pasteboard.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>📸 截图上传&lt;/strong>&lt;/td>
 &lt;td>直接拉框截图上传。&lt;code>可设置全局快捷键&lt;/code>&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/screenshot.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/screenshot.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>🖱 拖拽本地文件上传&lt;/strong>&lt;/td>
 &lt;td>拖拽文件到状态栏上传&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/dragFile.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/dragFile.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>🖱 拖拽浏览器图片上传&lt;/strong>&lt;/td>
 &lt;td>从浏览器拖拽图片到状态栏上传&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/dragFromBrowser.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/dragFromBrowser.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>📂 Finder 中右键上传&lt;/strong>&lt;/td>
 &lt;td>右击文件上传&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/contextmenu.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/contextmenu.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>⌨️ 命令行上传&lt;/strong>&lt;/td>
 &lt;td>通过执行命令调用 uPic 上传文件&lt;/td>
 &lt;td>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/cli.gif">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/cli.gif" alt="">&lt;/a>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="-更多功能">🧰 更多功能&lt;/h2>
&lt;h3 id="1全局快捷键">1.全局快捷键&lt;/h3>
&lt;p>&lt;a href="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/shortcuts.png">&lt;img src="https://cdn.jsdelivr.net/gh/gee1k/oss@master/screenshot/uPic-cn/shortcuts.png" alt="">&lt;/a>&lt;/p></description></item><item><title>使用 Floccus + 坚果云无梯子跨平台同步 Chrome 浏览器书签</title><link>https://blog.ch3nnn.cn/posts/2020/%E4%BD%BF%E7%94%A8floccus+%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%97%A0%E6%A2%AF%E5%AD%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE/</link><pubDate>Fri, 17 Apr 2020 03:23:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/%E4%BD%BF%E7%94%A8floccus+%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%97%A0%E6%A2%AF%E5%AD%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE/</guid><description>&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417111855319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">​&lt;/p>
&lt;p>采用的方案是 Chrome / Cent Browser / Firefox / yandex 等 + Floccus + 坚果云（WebDav）实现书签的跨平台多终端同步的。理论上，只要支持Floccus扩展的浏览器，都能实现。&lt;/p>
&lt;p>首先给出 FloccusGitHub的地址：&lt;a href="https://github.com/marcelklehr/floccus">https://github.com/marcelklehr/floccus&lt;/a>&lt;/p>
&lt;p>Floccus 插件的地址：&lt;a href="https://chrome.google.com/webstore/detail/fnaicdffflnofjppbagibeoednhnbjhg">https://chrome.google.com/webstore/detail/fnaicdffflnofjppbagibeoednhnbjhg&lt;/a>&lt;/p>
&lt;p>安装好并配置完毕:&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417110449371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;h3 id="开始">开始&lt;/h3>
&lt;p>一、坚果云上的配置&lt;/p>
&lt;p>坚果云注册一个免费版个人账号（每日流量限制：上传1G，下载3G，够用了），注册成功登录后，点击右上角的用户名下拉菜单。&lt;/p>
&lt;p>注册:&lt;a href="https://www.jianguoyun.com/">https://www.jianguoyun.com/&lt;/a>&lt;/p>
&lt;p>需要先注册应用&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417110739961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>这里需要在我的书签添加自定义名称 在插件服务器地址中需要用到&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417111208573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>二、浏览器上的配置&lt;/p>
&lt;p>添加账户&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417110859623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417110925524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417111042580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>位置1中填入 坚果云服务器地址，即：&lt;a href="https://dav.jianguoyun.com/dav">https://dav.jianguoyun.com/dav/自定义书签名称&lt;/a>&lt;/p>
&lt;p>注意地址后面还有在坚果云添加的书签名称 例如&lt;a href="https://dav.jianguoyun.com/dav/bookmarks">https://dav.jianguoyun.com/dav/bookmarks&lt;/a>&lt;/p>
&lt;p>位置2中填入你在坚果云中的注册的用户名，&lt;/p>
&lt;p>位置3中填入在坚果云中为第三方应用生产的应用管理密码。&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417111416545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>将界面拖下来一点，看到有个“本地文件夹”配置，点击“选择文件夹”，出来的列表中，点击 “书签栏” 右边的“选取”按钮&lt;/p>
&lt;p>一般就选择根路径这样书签所有收藏网址都能同步&lt;/p>
&lt;p>修改自动同步时间间隔的，默认15分钟，这里我觉得没必要改，或者你觉得要同步间隔有必要调整，也可以修改一下。&lt;/p>
&lt;p>设置完毕后，拉倒最底部，点击“保存”。&lt;/p>
&lt;p>然后点击“同步”手动启动同步一次。 一般就能够成功把本地的“书签栏”目录中的浏览器同步保存到坚果云中的 我的文件 目录下的 bookmarks.xbel文件中了。&lt;/p>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/20200417111604772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDE4NQ==,size_16,color_FFFFFF,t_70" alt="">&lt;/p>
&lt;p>参考学习：&lt;/p>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.appinn.com%2Ffloccus">Floccus – 跨平台浏览器「书签同步」插件&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.jianguoyun.com%2Fs%2Fcontent%2F3991.html">WebDAV是什么？网盘的WebDAV有什么用？&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cccitu.com%2F982.html">yandex的Floccus插件安装教程&lt;/a>&lt;/p></description></item><item><title>RabbitMq系列之六：为什么需要主题交换机？</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA/</link><pubDate>Sat, 12 Oct 2019 05:56:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA/</guid><description>&lt;h1 id="为什么需要主题交换机">为什么需要主题交换机？&lt;/h1>
&lt;p>&lt;strong>（使用Python 客户端 —— pika 0.9.8）&lt;/strong>&lt;/p>
&lt;p>上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。&lt;/p>
&lt;p>尽管直连交换机能够改善我们的系统，但是它也有它的限制 —— 没办法基于多个标准执行路由操作。&lt;/p>
&lt;p>在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix 工具 &lt;a href="http://en.wikipedia.org/wiki/Syslog">syslog&lt;/a> 就是同时基于严重程度 -severity (info/warn/crit&amp;hellip;) 和 设备 -facility (auth/cron/kern&amp;hellip;) 来路由日志的。&lt;/p>
&lt;p>如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于 “cron” 的严重程度为 “critical errors” 的日志，也可以监听来源于 “kern” 的所有日志。&lt;/p>
&lt;p>为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。&lt;/p>
&lt;h2 id="主题交换机">主题交换机&lt;/h2>
&lt;p>发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由.分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：&amp;ldquo;stock.usd.nyse&amp;rdquo;, &amp;ldquo;nyse.vmw&amp;rdquo;, &amp;ldquo;quick.orange.rabbit&amp;rdquo;。词语的个数可以随意，但是不要超过 255 字节。&lt;/p>
&lt;p>绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>(星号) 用来表示一个单词.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h1 id="井号-用来表示任意数量零个或多个单词">(井号) 用来表示任意数量（零个或多个）单词。&lt;/h1>
&lt;/li>
&lt;/ul>
&lt;p>下边用图说明：&lt;/p>
&lt;p>&lt;img src="http://wiki.jikexueyuan.com/project/rabbitmq/images/15.png" alt="">&lt;/p>
&lt;p>这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个.分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： ..。&lt;/p>
&lt;p>我们创建了三个绑定：Q1 的绑定键为 &lt;em>.orange.&lt;/em>，Q2 的绑定键为 &lt;em>.&lt;/em>.rabbit 和 lazy.# 。&lt;/p>
&lt;p>这三个绑定键被可以总结为：&lt;/p>
&lt;ul>
&lt;li>Q1 对所有的桔黄色动物都感兴趣。&lt;/li>
&lt;li>Q2 则是对所有的兔子和所有懒惰的动物感兴趣。&lt;/li>
&lt;/ul>
&lt;p>一个携带有 quick.orange.rabbit 的消息将会被分别投递给这两个队列。携带着 lazy.orange.elephant 的消息同样也会给两个队列都投递过去。另一方面携带有 quick.orange.fox 的消息会投递给第一个队列，携带有 lazy.brown.fox 的消息会投递给第二个队列。携带有 lazy.pink.rabbit 的消息只会被投递给第二个队列一次，即使它同时匹配第二个队列的两个绑定。携带着 quick.brown.fox 的消息不会投递给任何一个队列。&lt;/p></description></item><item><title>RabbitMq系列之五：远程过程调用（RPC）</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc/</link><pubDate>Sat, 12 Oct 2019 05:55:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc/</guid><description>&lt;h1 id="远程过程调用rpc">远程过程调用（RPC）&lt;/h1>
&lt;p>&lt;strong>（Python客户端 —— 使用 pika 0.9.8）&lt;/strong>&lt;/p>
&lt;p>在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。&lt;/p>
&lt;p>可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者 RPC。&lt;/p>
&lt;p>这篇教程中，我们会使用 RabbitMQ 来构建一个 RPC 系统：包含一个客户端和一个 RPC 服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。&lt;/p>
&lt;h2 id="客户端接口">客户端接口&lt;/h2>
&lt;p>为了展示 RPC 服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为 “call” 的方法用来发送一个 RPC 请求，并且在收到回应前保持阻塞。&lt;/p>
&lt;pre tabindex="0">&lt;code>fibonacci_rpc = FibonacciRpcClient()
result = fibonacci_rpc.call(4)
print &amp;#34;fib(4) is %r&amp;#34; % (result,) 
&lt;/code>&lt;/pre>&lt;h3 id="关于-rpc-的注意事项">关于 RPC 的注意事项&lt;/h3>
&lt;p>尽管 RPC 在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的 RPC 调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用 RPC 会导致不可维护的&lt;a href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81">面条代码&lt;/a>.&lt;/p>
&lt;p>考虑到这一点，牢记以下建议：&lt;/p>
&lt;p>确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。给你的系统编写文档。保持各个组件间的依赖明确。处理错误案例。明了客户端改如何处理 RPC 服务器的宕机和长时间无响应情况。&lt;/p>
&lt;p>当对避免使用 RPC 有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC 类的阻塞。结果被异步地推送到下一个计算场景。&lt;/p>
&lt;h2 id="回调队列">回调队列&lt;/h2>
&lt;p>一般来说通过 RabbitMQ 来实现 RPC 是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们试试看：&lt;/p>
&lt;pre tabindex="0">&lt;code>result = channel.queue_declare(exclusive=True)
callback_queue = result.method.queue

channel.basic_publish(exchange=&amp;#39;&amp;#39;,
 routing_key=&amp;#39;rpc_queue&amp;#39;,
 properties=pika.BasicProperties(
 reply_to = callback_queue,
 ),
 body=request)

# ... and some code to read a response message from the callback_queue ... 
&lt;/code>&lt;/pre>&lt;h3 id="消息属性">消息属性&lt;/h3>
&lt;p>AMQP 协议给消息预定义了一系列的14个属性。大多数属性很少会用到，除了以下几个：&lt;/p></description></item><item><title>RabbitMq系列之四：路由Routing</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E8%B7%AF%E7%94%B1routing/</link><pubDate>Sat, 12 Oct 2019 05:54:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E8%B7%AF%E7%94%B1routing/</guid><description>&lt;h1 id="路由routing">路由(Routing)&lt;/h1>
&lt;p>&lt;strong>（使用pika 0.9.5 Python客户端）&lt;/strong>&lt;/p>
&lt;p>在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接收者。&lt;/p>
&lt;p>本篇教程中我们打算新增一个功能 —— 使得它能够只订阅消息的一个字集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中&lt;/p>
&lt;h2 id="绑定bindings">绑定（Bindings）&lt;/h2>
&lt;p>前面的例子，我们已经创建过绑定（bindings），代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>channel.queue_bind(exchange=exchange_name,
 queue=queue_name) 
&lt;/code>&lt;/pre>&lt;p>绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。&lt;/p>
&lt;p>绑定的时候可以带上一个额外的 routing_key 参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。&lt;/p>
&lt;pre tabindex="0">&lt;code>channel.queue_bind(exchange=exchange_name,
 queue=queue_name,
 routing_key=&amp;#39;black&amp;#39;) 
&lt;/code>&lt;/pre>&lt;p>绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。&lt;/p>
&lt;h2 id="直连交换机direct-exchange">直连交换机（Direct exchange）&lt;/h2>
&lt;p>我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。&lt;/p>
&lt;p>我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。&lt;/p>
&lt;p>我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。&lt;/p>
&lt;p>下图能够很好的描述这个场景：&lt;/p>
&lt;p>&lt;img src="http://wiki.jikexueyuan.com/project/rabbitmq/images/12.png" alt="">&lt;/p>
&lt;p>在这个场景中，我们可以看到直连交换机 X 和两个队列进行了绑定。第一个队列使用 orange 作为绑定键，第二个队列有两个绑定，一个使用 black 作为绑定键，另外一个使用 green。&lt;/p>
&lt;p>这样以来，当路由键为 orange 的消息发布到交换机，就会被路由到队列 Q1。路由键为 black 或者 green 的消息就会路由到 Q2。其他的所有消息都将会被丢弃。&lt;/p>
&lt;h2 id="多个绑定multiple-bindings">多个绑定（Multiple bindings）&lt;/h2>
&lt;p>&lt;img src="http://wiki.jikexueyuan.com/project/rabbitmq/images/13.png" alt="">&lt;/p>
&lt;p>多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个 X 和 Q1 之间的绑定，使用 black 绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有 black 路由键的消息会同时发送到 Q1 和 Q2。&lt;/p>
&lt;h2 id="发送日志">发送日志&lt;/h2>
&lt;p>我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。&lt;/p>
&lt;p>我们需要创建一个交换机（exchange）：&lt;/p></description></item><item><title>RabbitMq系列之三：发布订阅</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</link><pubDate>Sat, 12 Oct 2019 05:52:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</guid><description>&lt;h1 id="发布订阅">发布／订阅&lt;/h1>
&lt;p>&lt;strong>（使用pika 0.9.5 Python客户端）&lt;/strong>&lt;/p>
&lt;p>在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全不一样 —— 分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。&lt;/p>
&lt;p>为了描述这种模式，我们将会构建一个简单的日志系统。它包括两个程序——第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。&lt;/p>
&lt;p>在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。&lt;/p>
&lt;p>最终，日志消息被广播给所有的接受者（receivers）。&lt;/p>
&lt;h2 id="交换机exchanges">交换机（Exchanges）&lt;/h2>
&lt;p>前面的教程中，我们发送消息到队列并从中取出消息。现在是时候介绍 RabbitMQ 中完整的消息模型了。&lt;/p>
&lt;p>让我们简单的概括一下之前的教程：&lt;/p>
&lt;ul>
&lt;li>发布者（producer）是发布消息的应用程序。&lt;/li>
&lt;li>队列（queue）用于消息存储的缓冲。&lt;/li>
&lt;li>消费者（consumer）是接收消息的应用程序。&lt;/li>
&lt;/ul>
&lt;p>RabbitMQ 消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。&lt;/p>
&lt;p>发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。&lt;/p>
&lt;p>&lt;img src="http://wiki.jikexueyuan.com/project/rabbitmq/images/9.png" alt="">&lt;/p>
&lt;p>有几个可供选择的交换机类型：直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）。我们在这里主要说明最后一个 —— 扇型交换机（fanout）。先创建一个 fanout 类型的交换机，命名为 logs：&lt;/p>
&lt;pre tabindex="0">&lt;code>channel.exchange_declare(exchange=&amp;#39;logs&amp;#39;,
 type=&amp;#39;fanout&amp;#39;) 
&lt;/code>&lt;/pre>&lt;p>扇型交换机（fanout）很简单，你可能从名字上就能猜测出来，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。&lt;/p>
&lt;h2 id="交换器列表">交换器列表&lt;/h2>
&lt;p>rabbitmqctl 能够列出服务器上所有的交换器：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ sudo rabbitmqctl list_exchanges
Listing exchanges ...
logs fanout
amq.direct direct
amq.topic topic
amq.fanout fanout
amq.headers headers
...done. 
&lt;/code>&lt;/pre>&lt;p>这个列表中有一些叫做 amq.* 的交换器。这些都是默认创建的，不过这时候你还不需要使用他们。&lt;/p>
&lt;h2 id="匿名的交换器">匿名的交换器&lt;/h2>
&lt;p>前面的教程中我们对交换机一无所知，但仍然能够发送消息到队列中。因为我们使用了命名为空字符串 (&amp;quot;&amp;quot;) 默认的交换机。&lt;/p>
&lt;p>回想我们之前是如何发布一则消息：&lt;/p>
&lt;pre tabindex="0">&lt;code>channel.basic_publish(exchange=&amp;#39;&amp;#39;,
 routing_key=&amp;#39;hello&amp;#39;,
 body=message) 
&lt;/code>&lt;/pre>&lt;p>exchange 参数就是交换机的名称。空字符串代表默认或者匿名交换机：消息将会根据指定的 routing_key 分发到指定的队列。&lt;/p>
&lt;p>现在，我们就可以发送消息到一个具名交换机了：&lt;/p>
&lt;pre tabindex="0">&lt;code>channel.basic_publish(exchange=&amp;#39;logs&amp;#39;,
 routing_key=&amp;#39;&amp;#39;,
 body=message) 
&lt;/code>&lt;/pre>&lt;h2 id="临时队列">临时队列&lt;/h2>
&lt;p>你还记得之前我们使用的队列名吗（ hello 和 task_queue）？给一个队列命名是很重要的——我们需要把工作者（workers）指向正确的队列。如果你打算在发布者（producers）和消费者（consumers）之间共享同队列的话，给队列命名是十分重要的。&lt;/p></description></item><item><title>RabbitMq系列之二：工作队列</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/</link><pubDate>Sat, 12 Oct 2019 05:50:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/</guid><description>&lt;h1 id="工作队列">工作队列&lt;/h1>
&lt;p>&lt;strong>（使用pika 0.9.5 Python客户端）&lt;/strong>&lt;/p>
&lt;p>&lt;img src="http://wiki.jikexueyuan.com/project/rabbitmq/images/7.png" alt="">&lt;/p>
&lt;p>在第一篇教程中，我们已经写了一个从已知队列中发送和获取消息的程序。在这篇教程中，我们将创建一个工作队列（Work Queue），它会发送一些耗时的任务给多个工作者（Worker）。&lt;/p>
&lt;p>工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。&lt;/p>
&lt;p>这个概念在网络应用中是非常有用的，它可以在短暂的 HTTP 请求中处理一些复杂的任务。&lt;/p>
&lt;h2 id="准备">准备&lt;/h2>
&lt;p>之前的教程中，我们发送了一个包含 “Hello World!” 的字符串消息。现在，我们将发送一些字符串，把这些字符串当作复杂的任务。我们没有真实的例子，例如图片缩放、pdf 文件转换。所以使用 time.sleep() 函数来模拟这种情况。我们在字符串中加上点号（.）来表示任务的复杂程度，一个点（.）将会耗时1秒钟。比如 &amp;ldquo;Hello&amp;hellip;&amp;rdquo; 就会耗时3秒钟。&lt;/p>
&lt;p>我们对之前教程的 send.py 做些简单的调整，以便可以发送随意的消息。这个程序会按照计划发送任务到我们的工作队列中。我们把它命名为 new_task.py：&lt;/p>
&lt;pre tabindex="0">&lt;code>import sys

message = &amp;#39; &amp;#39;.join(sys.argv[1:]) or &amp;#34;Hello World!&amp;#34;
channel.basic_publish(exchange=&amp;#39;&amp;#39;,
 routing_key=&amp;#39;hello&amp;#39;,
 body=message)
print &amp;#34; [x] Sent %r&amp;#34; % (message,) 
&lt;/code>&lt;/pre>&lt;p>我们的旧脚本（receive.py）同样需要做一些改动：它需要为消息体中每一个点号（.）模拟1秒钟的操作。它会从队列中获取消息并执行，我们把它命名为 worker.py：&lt;/p>
&lt;pre tabindex="0">&lt;code>import time

def callback(ch, method, properties, body):
 print &amp;#34; [x] Received %r&amp;#34; % (body,)
 time.sleep( body.count(&amp;#39;.&amp;#39;) )
 print &amp;#34; [x] Done&amp;#34; 
&lt;/code>&lt;/pre>&lt;h2 id="循环调度">循环调度&lt;/h2>
&lt;p>使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。&lt;/p>
&lt;p>首先，我们先同时运行两个 worker.py 脚本，它们都会从队列中获取消息，到底是不是这样呢？我们看看。&lt;/p></description></item><item><title>RabbitMq系列之一：介绍</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 12 Oct 2019 05:49:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E4%BB%8B%E7%BB%8D/</guid><description>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>使用UnblockNeteaseMusic播放网易云音乐客户端无版权歌曲</title><link>https://blog.ch3nnn.cn/posts/2018/%E4%BD%BF%E7%94%A8unblockneteasemusic%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E7%89%88%E6%9D%83%E6%AD%8C%E6%9B%B2/</link><pubDate>Sun, 18 Feb 2018 03:56:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2018/%E4%BD%BF%E7%94%A8unblockneteasemusic%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E7%89%88%E6%9D%83%E6%AD%8C%E6%9B%B2/</guid><description>&lt;p>&lt;strong>说明：&lt;/strong>&lt;code>UnblockNeteaseMusic&lt;/code>是一款可以给你解除网易云音乐海外限制并解锁变灰(无版权)歌曲的工具，让你可以听取客户端任何的歌曲，而不受到限制，此前该类似工具挺多的，不过貌似都不维护或者失效了，这里提到的项目更新很频繁，支持&lt;code>Windows&lt;/code>、&lt;code>MacOS&lt;/code>、安卓、&lt;code>IOS&lt;/code>等设备，所以就分享一下使用方法。&lt;/p>
&lt;h2 id="截图">截图&lt;/h2>
&lt;p>&lt;img src="https://s2.loli.net/2023/03/10/qhxZAHFeOT7uLf9.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://s2.loli.net/2023/03/10/YXCdq6igRQnsrU7.png" alt="">&lt;/p>
&lt;h2 id="特性">特性&lt;/h2>
&lt;ul>
&lt;li>使用网易云旧链/&lt;code>QQ&lt;/code>/虾米/百度/酷狗/酷我/咕咪/&lt;code>JOOX&lt;/code>音源替换变灰歌曲链接(默认仅启用前四)。&lt;/li>
&lt;li>为请求增加&lt;code>X-Real-IP&lt;/code>参数解锁海外限制，支持指定网易云服务器&lt;code>IP&lt;/code>，支持设置上游&lt;code>HTTP&lt;/code>/&lt;code>HTTPS&lt;/code>代理。&lt;/li>
&lt;li>完整的流量代理功能(&lt;code>HTTP&lt;/code>/&lt;code>HTTPS&lt;/code>)，可直接作为系统代理(同时支持&lt;code>PAC&lt;/code>)。&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>&lt;strong>Github地址：&lt;/strong>&lt;a href="https://github.com/nondanee/UnblockNeteaseMusic">https://github.com/nondanee/UnblockNeteaseMusic&lt;/a>&lt;/p>
&lt;p>&lt;strong>1、安装Nodejs&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>#Debian/Ubuntu系统
curl -sL https://deb.nodesource.com/setup_10.x | bash -
apt install -y nodejs git 

#CentOS系统
curl -sL https://rpm.nodesource.com/setup_10.x | bash -
yum install nodejs git -y
&lt;/code>&lt;/pre>&lt;p>&lt;strong>2、运行UnblockNeteaseMusic&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/nondanee/UnblockNeteaseMusic.git
cd UnblockNeteaseMusic
node app.js
&lt;/code>&lt;/pre>&lt;p>运行端口默认为&lt;code>8080&lt;/code>，需要想修改可以编辑&lt;code>app.js&lt;/code>文件的&lt;code>config.port&lt;/code>对应的数值，或者使用命令：&lt;/p>
&lt;pre tabindex="0">&lt;code>#这里默认修改4567，自行调整
node app.js -p 4567
&lt;/code>&lt;/pre>&lt;p>这里还可以加一个&lt;code>-s&lt;/code>参数限制代理范围防止被滥用，也就是仅放行网易云音乐所属域名的请求，不过使用起来的话就受限了，仅支持&lt;code>PAC&lt;/code>或&lt;code>Hosts&lt;/code>。&lt;/p>
&lt;pre tabindex="0">&lt;code>node app.js -s
&lt;/code>&lt;/pre>&lt;p>&lt;strong>3、开机自启&lt;/strong>&lt;br>
这里使用&lt;code>Systemd&lt;/code>进程守护，只适用于&lt;code>CentOS 7&lt;/code>、&lt;code>Debian 8+&lt;/code>、&lt;code>Ubuntu 16+&lt;/code>等。&lt;/p>
&lt;pre tabindex="0">&lt;code>#修改下ExecStartPre源码路径即可，然后一起复制到SSH运行
cat &amp;gt; /etc/systemd/system/UnblockNeteaseMusic.service &amp;lt;&amp;lt;EOF
[Unit]
Description=UnblockNeteaseMusic
After=network.target
Wants=network.target

[Service]
Type=simple
PIDFile=/var/run/UnblockNeteaseMusic.pid
WorkingDirectory=/root/UnblockNeteaseMusic
ExecStart=$(command -v node) app.js -p 4567
RestartPreventExitStatus=23
Restart=always

[Install]
WantedBy=multi-user.target
EOF
&lt;/code>&lt;/pre>&lt;p>启动并开机自启：&lt;/p></description></item></channel></rss>