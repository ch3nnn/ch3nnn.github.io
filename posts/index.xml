<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Ch3nnn!Blog</title><link>https://blog.ch3nnn.cn/posts/</link><description>Recent content in Posts on Ch3nnn!Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 22 Dec 2023 11:05:22 +0800</lastBuildDate><atom:link href="https://blog.ch3nnn.cn/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 代码检查工具(golangci-lint)</title><link>https://blog.ch3nnn.cn/posts/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</link><pubDate>Fri, 22 Dec 2023 11:05:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</guid><description>一、介绍 golangci-lint 是一个代码检查工具的集合，聚集了多种 Go 代码检查工具，如 golint、go vet 等。
优点：
运行速度快 可以集成到 vscode、goland 等开发工具中 包含了非常多种代码检查器 可以集成到 CI 中 这是包含的代码检查器列表：Linters 二、安装 golangci-lint 官方不建议使用 go get 方式安装，推荐使用二进制安装。
MacOS 直接使用 homebrew 安装：
brew install golangci-lint brew upgrade golangci-lint Linux 和 Windows # binary will be $(go env GOPATH)/bin/golangci-lint curl -sSfL https://raw.githubusercontent.com/Goci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.42.1 golangci-lint --version golangci-lint 将会被安装到 GOPATH/bin 目录中，如果此目录不在环境变量路径中需要加上。
三、使用方式 命令行 在项目根目录下执行以下命令检查整个项目的代码：
golangci-lint run 其等价于:
golangci-lint run .</description></item><item><title>在 Go 使用 embed 当中嵌入父目录中的文件</title><link>https://blog.ch3nnn.cn/posts/%E5%9C%A8go%E4%BD%BF%E7%94%A8embed%E5%BD%93%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%88%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 07 Oct 2023 09:48:41 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/%E5%9C%A8go%E4%BD%BF%E7%94%A8embed%E5%BD%93%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%88%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>自 Go 1.16 版本开始，Go 提供了将二进制文件打包进入到 Binary 文件当中的机制:`//go:embed。不过，我看到的示例大多数都是嵌入当前文件夹下的子文件夹的示例。并没有嵌入父一级文件夹的示例。
为什么会需要嵌入父目录中的文件？ 这是因为不同的项目的构建规则不同。一些小型项目可能只有一个 main.go 或同级目录下几个其他的 go source 文件即可，但对于更大型的项目，合理的项目拆分是有助于帮助提升项目的可维护性的。
以我为例，我的目录结构如下：biz 目录下是我的核心逻辑，也是我日常写代码的地方；conf 则放置了各种配置，比如各种 API Key，ral 则是网络访问层，比如我比较喜欢用 gin 来做底层的网络访问层；script 放置了开发所需要的各种脚本文件；static 则放置了前端所需要的 JS / CSS 文件。在开发一些偏内容向的页面时，我会习惯使用 Server Side Render，所以我在 biz 目录下还有一个 template 目录。而主要的逻辑则放在 handler。
├── biz │ ├── dal │ ├── handler │ ├── logic │ ├── service │ └── template ├── conf ├── ral │ └── gin ├── script └── static └── public 在日常开发时，一个非常常见的操作是在 handler 里处理基本的逻辑，并将 template 中的模板渲染出来，并返回给用户，这个时候就需要在 handler 里使用上一级目录的文件了。</description></item><item><title>浅谈我为什么从 HEXO 迁移到 HUGO</title><link>https://blog.ch3nnn.cn/posts/%E6%B5%85%E8%B0%88%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ehexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</link><pubDate>Wed, 30 Aug 2023 10:53:08 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/%E6%B5%85%E8%B0%88%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ehexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</guid><description>一、为什么选择Hugo 我一直在使用 HEXO 作为我的网站建设工具。最主要的原因在于容易理解，相对比较容易上手，并且有很多齐全的插件供你选择。
首先，第一点得提的就是 Hugo 打出的标语 &amp;ndash; The world’s fastest framework for building websites。 Hugo 依靠 Go 语言进行开发，号称世界上最快的构建网站工具。HUGO 具有快速建站的能力。与其他网站建设工具相比，HUGO 具有更快的启动时间和更快的页面加载速度。这对于需要快速响应的网站来说尤为重要。
正是依赖于 Hugo 快速生成的特点，调试方便成了 Hugo 的第二大特点。基本上我在使用 Markdown 语言进行页面编写处修改的内容可以实时地显示在网页上，而不用再次敲命令生成再预览。
第三点自己也是学习和使用 GO 语言，所以也会有所青睐。
二、安装 Hugo 在 macOS 上安装 Hugo 前置条件需要安装 brew。
Homebrew 是一款适用于 macOS 和 Linux 的免费开源包管理器。
安装 GO 和 Git 可以使用 brew 包管理工具 // 升级 brew brew update &amp;amp;&amp;amp; brew upgrade // 安装 Git brew install git // 安装 Go brew install go 安装 Hugo brew 扩展版本： brew install hugo 三、Hugo 快速入门 执行以下命令</description></item><item><title>Golang-使用gvm进行版本控制</title><link>https://blog.ch3nnn.cn/posts/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 14 Aug 2023 18:00:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</guid><description>当你想为每个项目切换 go 版本时，gvm (Go Version Manager) 很方便。
这里，我将介绍“如何在Mac上安装gvm”和“如何使用gvm”
使用准备 仅适用于 Mac 的准备工作 按照MacOSX 要求中的说明执行以下命令。
xcode-select --install brew update brew install mercurial gvm安装 我使用 zsh 作为我的 shell。
$ echo $SHELL /bin/zsh 对于 zsh，您可以这样安装：
$ zsh &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) Cloning from https://github.com/moovweb/gvm.git to /Users/user_name/.gvm No existing Go versions detected Installed GVM v1.0.22 Please restart your terminal session or to get started right away run `source /Users/user_name/.gvm/scripts/gvm` ~/.zshrc 以下行被添加到最后一行
[[ -s &amp;#34;/Users/user_name/.</description></item><item><title>Golang-语言源码级调试器 Delve</title><link>https://blog.ch3nnn.cn/posts/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</link><pubDate>Fri, 11 Aug 2023 15:43:40 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</guid><description>前言 Go 目前的调试器有如下几种：
GDB 最早期的调试工具，现在用的很少。 LLDB macOS 系统推荐的标准调试工具，单 Go 的一些专有特性支持的比较少。 Delve 专门为 Go 语言打造的调试工具，使用最为广泛。 本篇简单说明如何使用 Delve 工具来调试 Go 程序，使用的 delve 版本为 1.20.1。
delve 的汉语意思是：钻研、探索；用这个来命名一个debug工具还是非常的形象。
安装 已知以下说明适用于 Linux、macOS、Windows 和 FreeBSD。
克隆 git 存储库并构建：
$ git clone https://github.com/go-delve/delve $ cd delve $ go install github.com/go-delve/delve/cmd/dlv 或者，在 Go 版本 1.16 或更高版本上：
Install the latest release: $ go install github.com/go-delve/delve/cmd/dlv@latest
Install at tree head: $ go install github.com/go-delve/delve/cmd/dlv@master
安装在一个特定的版本或:
$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3 $ go install github.</description></item><item><title>Golang-常见数据结构Slice</title><link>https://blog.ch3nnn.cn/posts/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</link><pubDate>Sun, 30 Apr 2023 00:56:46 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</guid><description>Golang-常见数据结构Slice Slice slice 翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。
了解 slice 的本质, 最简单的方法就是看它的源码:
// runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } slice 共有三个属性:
指针 指向底层数组 长度 表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度 容量 底层数组的元素个数，容量 &amp;gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。 注意: 底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。
slice 创建 方式 代码示例 直接声明 var slice []int new slice := *new([]int) 字面量 slice := []int{1,2,3,4} make slice := make(int[], 5, 10) 从切片或者数组&amp;quot;截取&amp;quot; slice := array[1:5] 或 slice := sourceSlice[1:5] 直接声明</description></item><item><title>Golang-常见数据结构Map</title><link>https://blog.ch3nnn.cn/posts/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</link><pubDate>Tue, 11 Apr 2023 10:07:33 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</guid><description>Map map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。
map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。
哈希表 哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表， 有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。
设计原理 哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。
哈希函数 实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。
完美哈希函数如图: 比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。
不均匀哈希函数如图: 在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。
冲突解决 哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。
开放寻址法 开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从索引开始遍历
当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置 开放地址法写入数据如图: 如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。
开放地址法读取数据如图: 当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。
开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。
拉链法
与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。
实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』： 拉链法写入数据如图: 如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模</description></item><item><title>微服务 API 网关对比和选型</title><link>https://blog.ch3nnn.cn/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1api%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</link><pubDate>Tue, 04 Apr 2023 16:45:00 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1api%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</guid><description>什么是微服务 微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。 在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。微服务是互联网业务发展的结果，互联网业务的飞速发展导致系统的架构也在不断地发生变化，总体来说，系统的架构大致经历了：单体应用架构—&amp;gt; SOA 架构—&amp;gt;微服务架构 的演变，具体发展历程和各自的优缺点如下表所示。 因此，微服务是互联网发展的必然结果，很多传统公司的系统架构也在逐步微服务化。但是，随着互联网业务的发展，API 的数量也在剧增，使用网关对API统一管理也将面临挑战，选择一个更强大的 API 网关，可以有效地增强系统的监控、容灾、鉴权和限流等能力。
什么是微服务网关 API网关是一个服务器，是系统的唯一入口。 从面向对象设计的角度看，它与外观模式类似。
API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。
API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。 通常，网关也是提供REST/HTTP的访问API。 微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：
数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。 控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。
微服务遇到的挑战
微服务网关应该首先要具备 API 路由能力，微服务数量变多，API 数量急剧增加，网关还可以根据具体的场景作为流量过滤器来使用，以提供某些额外可选功能，因此对微服务 API Gateway 提出了更高要求，比如：
可观测性：在以往的单体应用中，排查问题往往通过查看日志定位错误信息和异常堆栈；但是在微服务架构中服务繁多，出现问题时的问题定位变得非常困难；因此，如何监控微服务的运行状况、当出现异常时能快速给出报警，这给开发人员带来很大挑战。 鉴权认证：而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其它服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在微服务架构下，要考虑外部应用接入的场景、用户 -
服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。 系统稳定性：若大量请求超过微服务的处理能力时，可能会将服务打垮，甚至产生雪崩效应、影响系统的整体稳定性。 服务发现：微服务的分散管理，让微服务的负载均衡的实现也更具有挑战性。 解决方案
API 网关作为客户端和服务端的中间桥梁，为微服务系统提供统一的管理机制： 除了基础的请求分发、API 管理和条件路由等功能，还包括身份验证、监控报警、调用链追踪、负载均衡、限流隔离和熔断降级。身份认证：下图表示的是微服务联合 API 网关如何进行身份认证的，由图可见所有请求都通过网关，从而有效地隐藏了微服务。
监控报警/调用链追踪： API 作为客户端和服务端的中间桥梁，是微服务监控的最好载体，API 网关监控功能的主要职责是及时发现网关以及后端服务器的连接异常，在 API 的监控平台上面用户可以随时查看日志信息，监控信息，调用链等等，并且主机发生的任何异常都会自动报警到控制台。有些网关甚至可以做到给客户端和服务端双向报警。
限流隔离/熔断降级： 随着互联网业务规模的增加，系统的并发度增高，多个服务之间相互调用链路，一条核心链路往往可能调用十个服务。如果在链路中，某个服务的 rt（响应时间）急剧上升，上游服务不断请求，造成恶性循环，上游等待结果线程数越多，使得更上游服务阻塞最终整条链路无法使用，从而导致服务雪崩，所以对入口流量进行整治管理是很有必要的，下图表示微服务系统是如何结合 API 网关进行限流隔离和熔断降级的。
主流网关选择 在微服务领域，有许多开源网关实现，有 NGINX、Kong、Apache APISIX 和 Envoy 等，Java 技术栈的有 Netfilx Zuul、Spring Cloud Gateway、Soul 等。或许你会问“有了 NGINX 和 Kong，为什么还需要 Apache APISIX？” ，下面做个简单对比。</description></item><item><title>Golang-channel通道</title><link>https://blog.ch3nnn.cn/posts/golang-channel%E9%80%9A%E9%81%93/</link><pubDate>Sun, 19 Mar 2023 17:41:05 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-channel%E9%80%9A%E9%81%93/</guid><description>goroutine 和 channel (通道)并成为 Go 并发的两大基石。channel 可以放心地在多个 goroutine 之间使用, 因为它是并发安全的。
channel 有哪些应用 停止信号 channel 用于停止信号的场景很多，通常是通过关闭某个channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作，如停止某个循环等。
定时任务 与计时器结合，一般有两种做法：实现超时控制、实现定期执行某个任务。 有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定。这就是时控制：
select { case &amp;lt;- time.After(100*time.Millisecond): case &amp;lt;- s.stopc: return false } 等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。
定时执行某个任务，也比较简单：
func worker() { ticker := time.Tick(1 * time.Second) for { select { case &amp;lt;- ticker: // 执行定时任务 fmt.Println(&amp;#34;执行 1s 定时任务&amp;#34;) } } } 每隔 1 秒种，执行一次定时任务。
解耦生产方和消费方 服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行：</description></item><item><title>Golang-垃圾回收</title><link>https://blog.ch3nnn.cn/posts/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Sat, 18 Mar 2023 23:21:06 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
垃圾回收算法 目前比较常见的垃圾回收算法有三种： 引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。
代表语言：Python、PHP、Swift 优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。 缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。 标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。
代表语言：Golang（三色标记法） 优点：解决了引用计数的缺点。 缺点：需要 STW，暂时停掉程序运行。 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
代表语言：Java 优点：回收性能好 缺点：算法复杂 Golang 垃圾回收 Go1.3之前 标记清除法 进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的内存占用和可达的内存占用 开始标记，程序找出可达内存占用并做标记 标记结束清除未标记的内存占用 结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束 一开始的做法是将垃圾清理结束时才停止 STW，后来优化了方案将清理垃圾放到了 STW 之后，与程序运行同时进行，这样做减小了 STW 的时长。 但是 STW 会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的 STW 对于性能较高的程序还是无法接受，但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。 因此 Go1.5 采用了三色标记法优化了 STW。
Go1.5之后 三色并发标记法 三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：
灰色：对象还在标记队列中等待 黑色：对象已被标记，gcmarkBits对应位为 1 – 该对象不会在本次 GC 中被回收 白色：对象未被标记，gcmarkBits对应位为 0 – 该对象将会在本次 GC 中被清理</description></item><item><title>Golang-Modules的演进史</title><link>https://blog.ch3nnn.cn/posts/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</link><pubDate>Mon, 13 Mar 2023 11:53:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid><description>介绍 Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。
使用 Go Modules 模式，一般分为以下几个流程：
go mod init 创建一个新模块，初始化 go.mod 文件。 go build、go test、go run、go install 等构建命令，向 go.mod文件中添加模块所需的依赖项。 go list -m -json all 打印当前模块的依赖项。 go get 添加依赖项，或修改依赖项版本。 go mod tidy 删除未使用的依赖项。 Go Modules 演进史 Go v1.11 从 Go v1.11 开始支持 Go Moduls。 为了兼容使用 Go v1.11 之前的任意版本的项目，当设置 GO111MODULE=auto 或 GO111MODULE=off 时，Go v1.11 在 $GOPATH/src 中，继续使用 GOPATH 模式。 当设置 GO111MODULE=auto 时，其它任意位置，如果当前目录或父目录包含 go.mod 文件，则使用 Modules 模式。</description></item><item><title>Golang-逃逸分析</title><link>https://blog.ch3nnn.cn/posts/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link><pubDate>Tue, 07 Mar 2023 13:38:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid><description>什么是堆/栈 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多 栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上 什么是逃逸分析 我们如何知道一个对象是应该放在堆内存，还是栈内存之上呢？可以官网的FAQ（地址：https://go.dev/doc/faq#stack_or_heap）中找到答案. 大致意思是:
从正确性的角度来看，你不需要知道。Go中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。 存储位置确实对编写高效的程序有影响。如果可能的话，Go编译器将为该函数的堆栈帧中的函数分配局部变量。但是，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在有垃圾回收的堆上分配该变量，以避免悬空指针错误。此外，如果局部变量非常大，那么将其存储在堆中可能比存储在栈中更有意义。 在当前编译器中，如果变量的地址被占用，那么该变量就是堆上分配内存的候选变量。然而，基本的逃逸分析可以识别出某些情况下，这些变量将不会存在于函数返回之后，而可以驻留在栈中。
在什么阶段确立逃逸 Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的。
逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析 如果变量在函数外部没有引用，则优先放到栈中 如果变量在函数外部存在引用，则必定放在堆中 逃逸规则 我们其实都知道一个普遍的规则，就是如果变量需要使用堆空间，那么他就应该进行逃逸。但是实际上Golang并不仅仅把逃逸的规则如此泛泛。Golang会有很多场景具备出现逃逸的现象。
一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。
Go语言中的引用类型有func（函数类型），interface（接口类型），slice（切片类型），map（字典类型），channel（管道类型），*（指针类型）等。
怎么确定是否逃逸 可以使用编译器提供的指令-gcflags 就可以看到详细的逃逸分析过程，命令如下：
go build -gcflags &amp;#39;-m -l&amp;#39; main.go 其指令涉及的参数如下：
-m：打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是这样子调试的信息量较大，一般用一个就足够了。 -l ：禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。 常见逃逸案例分析 new的变量在栈还是堆
package main func foo(argVal int) (*int) { var fooVal1 = new(int) var fooVal2 = new(int) var fooVal3 = new(int) var fooVal4 = new(int) var fooVal5 = new(int) //此处循环是防止go编译器将foo优化成inline(内联函数) //如果是内联函数，main调用foo将是原地展开，所以fooVal 1-5 相当于main作用域的变量 //即使fooVal3发生逃逸，地址与其他也是连续的 for i := 0; i &amp;lt; 5; i++ { println(argVal, fooVal1, fooVal2, fooVal3, fooVal4, fooVal5) } //fooVal3 return fooVal3 } func main() { mainVal := foo(666) println(*mainVal, mainVal) } 我们将fooVal 1-5 全部用new的方式来开辟, 编译运行看结果, 显然fooVal3发生了逃逸</description></item><item><title>Golang-GMP模型</title><link>https://blog.ch3nnn.cn/posts/golang-gmp%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 02 Mar 2023 16:45:39 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-gmp%E6%A8%A1%E5%9E%8B/</guid><description>写在前面 Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下面通过一段简单的代码展示一下 Go 应用程序在运行时的 goroutine，方便大家更好的理解。
The Go scheduler is part of the Go runtime, and the Go runtime is built into your application
for i := 0; i &amp;lt; 4; i++ { go func() { time.Sleep(time.Second) }() } fmt.Println(runtime.NumGoroutine()) 上面这段代码的输出为：5 说明当前这个应用程序中存在 goroutine 的数量是 5，事实上也符合我们的预期。那么问题来了，这 5 个 goroutine 作为操作系统用户态的基本调度单元是无法直接占用操作系统的资源来执行的，必须经过内核级线程的分发，这是操作系统内部线程调度的基本模型，根据用户级线程和内核级线程的对应关系可以分为 1 对 1，N 对 1 以及 M 对 N 这三种模型，那么上述的 5 个 goroutine 在内核级线程上是怎么被分发的，这就是 Go语言的 goroutine 调度器决定的。</description></item><item><title>Filebeat轻量型日志采集器-自定义processors处理器</title><link>https://blog.ch3nnn.cn/posts/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>Thu, 23 Feb 2023 18:14:25 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>引入对beat的依赖 go get github.com/elastic/beats/v7
定义在filebeat中的配置文件 filebeat通常以配置文件的方式加载插件。让定义一下自定义配置。
filebeat.inputs: - type: log paths: - example/example.log processors: # 自定义处理器插件 - parse_text: file_has_suffix: example.log output.console: pretty: true go文件中的配置 package actions type config struct { FileHasSuffix string `config:&amp;#34;file_has_suffix&amp;#34; validate:&amp;#34;required&amp;#34;` } 初始化加载插件 func init() { processors.RegisterPlugin(&amp;#34;parse_text&amp;#34;, checks.ConfigChecked(NewParseText, checks.RequireFields(&amp;#34;file_has_suffix&amp;#34;)), ) } Run接口 处理 filebeat 读取到的每行日志数据message, 这里我们就可以自定义一些处理解析逻辑, 下面逻辑是将日志数据按,切分,重新组装到event.Fields字段里.
func (p parseText) Run(event *beat.Event) (*beat.Event, error) { if !p.isParseFile(event) { return event, nil } message, err := p.getMessage(event) if err !</description></item><item><title>Golang-数组与切片常见错误及陷阱</title><link>https://blog.ch3nnn.cn/posts/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</link><pubDate>Wed, 15 Feb 2023 16:34:35 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</guid><description>nil切片、空切片、零切片 零切片
var s = make([]int, 10) fmt.Println(s) ------------ [0 0 0 0 0 0 0 0 0 0] 表示底层数组的二进制内容都是零
「空切片」和 「nil 切片」
var s1 []int var s2 = []int{} var s3 = make([]int, 0) // new 函数返回是指针类型，所以需要使用 * 号来解引用 var s4 = *new([]int) fmt.Println(len(s1), len(s2), len(s3), len(s4)) fmt.Println(cap(s1), cap(s2), cap(s3), cap(s4)) fmt.Println(s1, s2, s3, s4) ---------------- 0 0 0 0 0 0 0 0 [] [] [] [] 上面这四种形式从输出结果上来看，似乎一摸一样，没区别。但是实际上是有区别的，我们要讲的两种特殊类型「空切片」和「 nil 切片」，就隐藏在上面的四种形式之中。</description></item><item><title>Golang-代码断行规则</title><link>https://blog.ch3nnn.cn/posts/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</link><pubDate>Thu, 02 Feb 2023 16:37:59 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</guid><description>如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。
分号插入规则 我们在Go编程中常遵循的一个规则是：一个显式代码块的起始左大括号{不放在下一行。 比如，下面这个for循环代码块编译将失败。
for i := 5; i &amp;gt; 0; i-- { // error: 未预料到的新行 } 为了让上面这个for循环代码块编译成功，我们不能在起始左大括号{前断行，而应该像下面这样进行修改：
for i := 5; i &amp;gt; 0; i-- { } 然而，有时候起始左大括号{却可以放在一个新行上，比如下面这个for循环代编译时没有问题的。
for { // do something ... } 那么，Go代码中的根本性换行规则究竟是如何定义的呢？ 在回答这个问题之前，我们应该知道一个事实：正式的Go语法是使用（英文）分号;做为结尾标识符的。 但是，我们很少在Go代码中使用和看到分号。为什么呢？原因是大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。
比如，下面这个程序中的十个分号都是可以被省略掉的。
package main; import &amp;#34;fmt&amp;#34;; func main() { var ( i int; sum int; ); for i &amp;lt; 6 { sum += i; i++; }; fmt.Println(sum); }; 假设上面这个程序存储在一个semicolons.go文件中，我们可以运行go fmt semicolons.</description></item><item><title>Facebook 开源 Golang 实体框架 Ent</title><link>https://blog.ch3nnn.cn/posts/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 16 Jan 2023 17:29:45 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</guid><description>ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。
图就是代码 - 将任何数据库表建模为Go对象。 轻松地遍历任何图形 - 可以轻松地运行查询、聚合和遍历任何图形结构。 静态类型和显式API - 使用代码生成静态类型和显式API，查询数据更加便捷。 多存储驱动程序 - 支持MySQL, PostgreSQL, SQLite 和 Gremlin。 可扩展 - 简单地扩展和使用Go模板自定义。 安装 go install entgo.io/ent/cmd/ent@latest 快速开始 go mod init &amp;lt;project&amp;gt; 创建你的第一个项目 进入你项目的根目录，然后运行：
go run -mod=mod entgo.io/ent/cmd/ent init User 以上的命令会在&amp;lt;project&amp;gt;/ent/schema/目录下产生User的数据模式（数据模式是数据库系统设计中的专业术语，若对该部分有任何理解问题，请查阅数据库系统的相关书籍）：
package schema import &amp;#34;entgo.io/ent&amp;#34; // User在User实体中组合了ent默认的数据库模式定义 type User struct { ent.Schema } // User的字段 func (User) Fields() []ent.Field { return nil } // User的边 func (User) Edges() []ent.Edge { return nil } 为User 模式添加两个字段：</description></item><item><title>Golang:停止Goroutine有几种方法</title><link>https://blog.ch3nnn.cn/posts/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 12 Jan 2023 18:23:23 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>goroutine介绍 goroutine 是 Go 语言实现并发编程的利器，是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理，简单的一个指令go function就能启动一个 goroutine；Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。
但是，Go语言并没有提供终止goroutine的接口，也就是说，我们不能从外部去停止一个goroutine，只能由goroutine内部退出(main函数终止除外)；
goroutine 案例 日常开发开启一个 goroutine go代码, 只需一个 go 关键字即可:
var wg sync.WaitGroup // 等待组，用来阻塞程序 func main() { wg.Add(1) // 等待组 +1 go func() { for { fmt.Println(&amp;#34;开启 goroutine&amp;#34;) } }() wg.Wait() } 几种停止的办法 Go 目前用 channel 或 context 的方式来取消 (cancelation) 给 goroutine。
Channel 第一种方法，就是借助 channel 的 close 机制来完成对 goroutine 的精确控制。 func main() { msg := make(chan struct{}) go func() { fmt.</description></item><item><title>Golang:值传递还是引用传递</title><link>https://blog.ch3nnn.cn/posts/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 09 Jan 2023 18:09:14 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid><description>Go 官方的定义 本部分引用 Go 官方 FAQ 的 “When are function parameters passed by value?”，内容如下。
如同 C 系列的所有语言一样，Go 语言中的所有东西都是以值传递的。也就是说，一个函数总是得到一个被传递的东西的副本，就像有一个赋值语句将值赋给参数一样。
传值和传引用 什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。其指的是在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。
对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。
test_demo.go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;testing&amp;#34; ) func modify(ip *int) { fmt.Printf(&amp;#34;函数里接收到的指针的内存地址是：%p\n&amp;#34;, &amp;amp;ip) *ip = 1 } func TestDemo(t *testing.T) { i := 10 ip := &amp;amp;i fmt.Printf(&amp;#34;原始指针的内存地址是：%p\n&amp;#34;, &amp;amp;ip) modify(ip) fmt.Println(&amp;#34;int值被修改了，新值为:&amp;#34;, i) } 输出结果:
原始指针的内存地址是：0xc00000e038 函数里接收到的指针的内存地址是：0xc00000e040 int值被修改了，新值为: 1 什么是传引用(引用传递) 传引用，也叫做引用传递， 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
在 Go 语言中，官方已经明确了没有传引用，也就是没有引用传递这一情况。
争议最大的 map 和 slice 这时候又有小伙伴疑惑了，你看 Go 语言中的 map 和 slice 类型，能直接修改，难道不是同个内存地址，不是引用了？</description></item><item><title>Filebeat轻量型日志采集器及output插件开发</title><link>https://blog.ch3nnn.cn/posts/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 09 Jan 2023 16:36:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid><description>无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。
介绍 Filebeat 是使用 Golang 实现的轻量型日志采集器。本质上是一个 agent ，可以安装在各个节点上，根据配置读取对应位置的日志，并上报到相应的地方去。
概要 Filebeat 并不依赖于 ElasticSearch，可以单独存在。我们可以单独使用Filebeat进行日志的上报和搜集。filebeat 内置了常用的 Output 组件, 例如 kafka、ElasticSearch、redis 等，出于调试考虑，也可以输出到 console 和 file 。我们可以利用现有的 Output 组件，将日志进行上报。
整体工作原理 Filebeat 由两个主要组件组成：harvester 和 prospector。
harvester (采集器) 的主要职责是读取单个文件的内容。读取每个文件，并将内容发送到 the output。 每个文件启动一个 harvester，harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态。如果文件在读取时被删除或重命名，Filebeat 将继续读取文件。 prospector (查找器) 的主要职责是管理 harvester 并找到所有要读取的文件来源。如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个 harvester。每个 prospector 都在自己的 Go 协程中运行。 注：Filebeat prospector只能读取本地文件， 没有功能可以连接到远程主机来读取存储的文件或日志。
由以上两个组件一起工作来读取文件（tail file）并将事件数据发送到指定的输出。 下图是 Filebeat 官方提供的架构图： Filebeat背后的“老大” 说到Filebeat，它其实只是beats家族众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：
beat 功能 Filebeat 收集日志文件 Metricbeat 收集各种指标数据 Packetbeat 收集网络数据包 Auditbeat 收集审计数据 Heartbeat 收集服务运行状态监测数据 &amp;hellip; &amp;hellip; 如果你愿意的话，你也可以按照beat的规范来写自己的beat。 能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么</description></item><item><title>这些最常用的 Go CLI 命令，新手 Gopher 应该掌握</title><link>https://blog.ch3nnn.cn/posts/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 02 Jan 2023 10:28:19 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</guid><description>本文将介绍一些最基本的 Go 命令行命令。如果你刚接触 Go 语言，那你有必要记住它们，因为这些命令是 Go 开发者日常工作中所必备的。
Go version
开始 Go 项目前，我们应该确保开发机上已经安装好了 Go 编译器。这可以通过 https://go.dev/doc/install 进行下载安装。
通过执行以下命令可以查看安装的 Go 版本信息。
$ go version go version go1.18 darwin/amd64 Go env
如果我们可能想查看一些 Go 相关的环境变量，例如 GOROOT 或者 GOPATH。你可以执行这个命令。
$ go env 当你想对某个环境变量进行更改，例如修改 Go 代理，你可以这样做。
$ go env -w GOPROXY=https://goproxy.io,direct go mod
在你开始建立第一个 Go 程序时，在项目根目录下，你应该运行这样的命令。
$ go mod init &amp;lt;your project name&amp;gt; 例如
$ go mod init demo/firstProject 此时，项目根目录将增加 go.mod 文件，它的内容如下
$ cat go.mod module demo/firstProject go 1.</description></item><item><title>「回顾2022，展望2023」 —— 年终总结</title><link>https://blog.ch3nnn.cn/posts/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 01 Jan 2023 23:41:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid><description> 致自己：折腾不息 · 乐此不疲!
22 年收获 技术上
编程语言方面 Golang: 从开始学习到现在的一年时间里, 前前后后也写了些代码, 其中包括业余时间的, 也有产品项目中的. 在摸滚打爬中对于Golang的使用算是勉强达到了较为熟练的状态. 开源贡献方向 jaywcjlove/reference 为开发人员分享快速参考备忘清单(速查表) liangliangyy/DjangoBlog 基于Django的博客系统 Lcry/a-sheep-assistant 羊了个羊助手，羊了个羊一键闯关 生活上
疫情防控 保持绿码, 小🐑人中&amp;hellip; 还以为自己就是那位&amp;quot;天选之子&amp;quot;(又开始吹牛皮). 生活情感 端午节前带女朋友回家, 父母都感觉很满意, 生活很幸福, 偶尔会吵吵嘴毕竟生活需要增加些乐趣嘛(哈哈哈). 工作上
从互联网医疗到工控安全行业, 工作内容没有任何变化(就是撸码搬砖🧱) 23年展望 2023年是新的一年，新的一年就会有新的flag。新的一年我要以下几件事:
保持持续学习的激情、态度 持续开源贡献 真的需要运动(感觉自己要废了) 感情上还是需要更加谦让 &amp;hellip; 写在最后 最后, 最后, Happy New Year &amp;hellip; 或者至少, 平平安安度过新的一年 各位, 继续加油吧! 冲冲冲!</description></item></channel></rss>