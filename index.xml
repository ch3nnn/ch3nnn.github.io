<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ch3nnn!Blog</title><link>https://blog.ch3nnn.cn/</link><description>Recent content on Ch3nnn!Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 Mar 2024 23:07:33 +0800</lastBuildDate><atom:link href="https://blog.ch3nnn.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 go-elasticsearch v8 请求示例</title><link>https://blog.ch3nnn.cn/posts/2024/%E4%BD%BF%E7%94%A8go-elasticsearch-v8%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/</link><pubDate>Tue, 19 Mar 2024 23:07:33 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/%E4%BD%BF%E7%94%A8go-elasticsearch-v8%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B/</guid><description>一、简介 你可以通过参考Go 官方文档找到简单的示例，所以我认为先看看这个是个好主意。
连接客户端有两种方式
至于两者的特点，TypedClient 有类型，更容易编写，但文档较少。另外，批量索引不支持TypedClient。由于普通客户端都是基于json的，所以我觉得从文档转换到代码还是比较容易的。
我的建议基本上是使用 TypedClient！ 虽然文档很稀疏，但它是基于规律性的类型化的，所以你越习惯它（特别是当涉及到有很多变化的东西时，比如查询），从 json 转换为类型化代码就越容易。
func main() { // client es, err := elasticsearch.NewClient(elasticsearch.Config{ Addresses: []string{&amp;#34;http://localhost:9200&amp;#34;}, }) if err != nil { log.Fatalf(&amp;#34;Error creating the client: %s&amp;#34;, err) } // typed client es, err := elasticsearch.NewTypedClient(elasticsearch.Config{ Addresses: []string{&amp;#34;http://localhost:9200&amp;#34;}, }) if err != nil { log.Fatalf(&amp;#34;Error creating the client: %s&amp;#34;, err) } } 二、Index Create/Delete 关于索引创建，Go官方文档中有一个示例，所以我简单介绍一下。
func main() { es, err := elasticsearch.NewTypedClient(elasticsearch.Config{ Addresses: []string{&amp;#34;http://localhost:9200&amp;#34;}, }) if err !</description></item><item><title>Golang 接口:nil接口为什么不等于nil?</title><link>https://blog.ch3nnn.cn/posts/2024/golang-%E6%8E%A5%E5%8F%A3nil%E6%8E%A5%E5%8F%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8Enil/</link><pubDate>Mon, 11 Mar 2024 10:48:24 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/golang-%E6%8E%A5%E5%8F%A3nil%E6%8E%A5%E5%8F%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8Enil/</guid><description>一、Go 接口的地位 Go 语言核心团队的技术负责人 Russ Cox 也曾说过这样一句话：“如果要从 Go 语言中挑选出一个特性放入其他语言，我会选择接口”，这句话足以说明接口这一语法特性在这位 Go 语言大神心目中的地位。
为什么接口在 Go 中有这么高的地位呢？这是因为接口是 Go 这门静态语言中唯一“动静兼备”的语法特性。而且，接口“动静兼备”的特性给 Go 带来了强大的表达能力，但同时也给 Go 语言初学者带来了不少困惑。要想真正解决这些困惑，我们必须深入到 Go 运行时层面，看看 Go 语言在运行时是如何表示接口类型的。
接下来，我们先来看看接口的静态与动态特性，看看“动静皆备”的含义。
二、接口的静态特性与动态特性 2.1 接口的静态特性与动态特性介绍 接口的静态特性体现在接口类型变量具有静态类型。
比如 var err error 中变量 err 的静态类型为 error。拥有静态类型，那就意味着编译器会在编译阶段对所有接口类型变量的赋值操作进行类型检查，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。如果不满足，就会报错：
var err error = 1 // cannot use 1 (type int) as type error in assignment: int does not implement error (missing Error method) 而接口的动态特性，就体现在接口类型变量在运行时还存储了右值的真实类型信息，这个右值的真实类型被称为接口类型变量的动态类型。例如，下面示例代码：
var err error err = errors.New(&amp;#34;error1&amp;#34;) fmt.Printf(&amp;#34;%T\n&amp;#34;, err) // *errors.</description></item><item><title>Protobuf 文档生成器插件</title><link>https://blog.ch3nnn.cn/posts/2024/%E5%B7%A5%E5%85%B7-protobuf%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8%E6%8F%92%E4%BB%B6/</link><pubDate>Wed, 28 Feb 2024 16:20:31 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/%E5%B7%A5%E5%85%B7-protobuf%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8%E6%8F%92%E4%BB%B6/</guid><description>这是 Google Protocol Buffers 文档生成器插件 (protoc)。 该插件可以根据文件中的注释生成 HTML、JSON、DocBook 和 Markdown 文档。
一、前言 毫无疑问, 目前后台开发接口协议应用最广泛的除了 HTTP 之外就是 gRPC 了, HTTP 接口有成熟的swagger工具可以生成界面美观和使用友好的文档，那么对于gRPC呢？
所以通过 .proto 文件能否生成更易阅读的 HTML 接口文档？
二、安装 go install github.com/pseudomuto/protoc-gen-doc/cmd/protoc-gen-doc@latest 三、使用 user.proto 文件 以user.proto为例, 如下内容:
syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;./pb&amp;#34;; package user; // ------------------------------------ // Messages // ------------------------------------ //--------------------------------用户-------------------------------- message SysUser { int64 id = 1; // ID string username = 2; // 用户名 string password = 3; // 密码 int64 create_at = 4; // 创建时间 int64 update_at = 5; // 修改时间 int64 delete_at = 6; // 删除时间 } message SysUserFilter { optional int64 id = 1; // ID optional string username = 2; // 用户名 optional string password = 3; // 密码 optional int64 create_at = 4; // 创建时间 optional int64 update_at = 5; // 修改时间 optional int64 delete_at = 6; // 删除时间 } message SelectSysUserListReq { int64 page = 1; // 页码 int64 page_size = 2; // 每页数量 optional SysUserFilter filter = 3; // SysUserFilter } message SelectSysUserListResp { int64 count = 1; // 总数 int64 page_count = 2; // 页码总数 repeated SysUser results = 3; // sys_user } // ------------------------------------ // Rpc Func // ------------------------------------ service User { //-----------------------用户----------------------- // 用户 列表 rpc SelectSysUserList(SelectSysUserListReq) returns (SelectSysUserListResp); } 1.</description></item><item><title>Golang 更严格的代码格式化工具 gofumpt</title><link>https://blog.ch3nnn.cn/posts/2024/golang-%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7gofumpt/</link><pubDate>Mon, 19 Feb 2024 19:56:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2024/golang-%E6%9B%B4%E4%B8%A5%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7gofumpt/</guid><description>一、前言 gofmt 是 golang 自带的代码自动格式化工具，是保证 Go 代码风格一致的大杀器。我们这次要推荐的 gofumpt 在 gofmt 的基础上添加了一系列更加严格的格式化规则，并保证了对 gofmt 的兼容。
二、gofumpt 简介 gofumpt(https://github.com/mvdan/gofumpt) fork 自 gofmt，支持与 gofmt 几乎相同的命令行参数，因此可以作为 gofmt 的直接替代品使用。gofumpt 是 gofmt 的&amp;quot;超集&amp;quot;，经过 gofumpt 格式化的代码也符合 gofmt 的要求，其本身所扩展的格式化规则也可能在后续被集成进 gofmt。
gofumpt 有以下特点:
更多的格式化规则(参见 https://github.com/mvdan/gofumpt#Added-rules) 默认跳过对 vendor 的格式化 不对自动生成的代码应用扩展规则 不支持 -r 参数 三、安装、使用命令 安装命令:
go install mvdan.cc/gofumpt@latest 执行命令:
gofumpt -l -w . 四、使用举例 赋值运算符后面没有空行
func foo() { foo := &amp;#34;bar&amp;#34; } 改为 gofumpt 格式化后：
func foo() { foo := &amp;#34;bar&amp;#34; } 函数体周围没有空行</description></item><item><title>Golang 代码检查工具(golangci-lint)</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</link><pubDate>Fri, 22 Dec 2023 11:05:22 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7golangci-lint/</guid><description>一、介绍 golangci-lint 是一个代码检查工具的集合，聚集了多种 Go 代码检查工具，如 golint、go vet 等。
优点：
运行速度快 可以集成到 vscode、goland 等开发工具中 包含了非常多种代码检查器 可以集成到 CI 中 这是包含的代码检查器列表：Linters 二、安装 golangci-lint 官方不建议使用 go get 方式安装，推荐使用二进制安装。
MacOS 直接使用 homebrew 安装：
brew install golangci-lint brew upgrade golangci-lint Linux 和 Windows # binary will be $(go env GOPATH)/bin/golangci-lint curl -sSfL https://raw.githubusercontent.com/Goci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.42.1 golangci-lint --version golangci-lint 将会被安装到 GOPATH/bin 目录中，如果此目录不在环境变量路径中需要加上。
三、使用方式 命令行 在项目根目录下执行以下命令检查整个项目的代码：
golangci-lint run 其等价于:
golangci-lint run .</description></item><item><title>在 Go 使用 embed 当中嵌入父目录中的文件</title><link>https://blog.ch3nnn.cn/posts/2023/%E5%9C%A8go%E4%BD%BF%E7%94%A8embed%E5%BD%93%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%88%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 07 Oct 2023 09:48:41 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E5%9C%A8go%E4%BD%BF%E7%94%A8embed%E5%BD%93%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%88%B6%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</guid><description>自 Go 1.16 版本开始，Go 提供了将二进制文件打包进入到 Binary 文件当中的机制:`//go:embed。不过，我看到的示例大多数都是嵌入当前文件夹下的子文件夹的示例。并没有嵌入父一级文件夹的示例。
为什么会需要嵌入父目录中的文件？ 这是因为不同的项目的构建规则不同。一些小型项目可能只有一个 main.go 或同级目录下几个其他的 go source 文件即可，但对于更大型的项目，合理的项目拆分是有助于帮助提升项目的可维护性的。
以我为例，我的目录结构如下：biz 目录下是我的核心逻辑，也是我日常写代码的地方；conf 则放置了各种配置，比如各种 API Key，ral 则是网络访问层，比如我比较喜欢用 gin 来做底层的网络访问层；script 放置了开发所需要的各种脚本文件；static 则放置了前端所需要的 JS / CSS 文件。在开发一些偏内容向的页面时，我会习惯使用 Server Side Render，所以我在 biz 目录下还有一个 template 目录。而主要的逻辑则放在 handler。
├── biz │ ├── dal │ ├── handler │ ├── logic │ ├── service │ └── template ├── conf ├── ral │ └── gin ├── script └── static └── public 在日常开发时，一个非常常见的操作是在 handler 里处理基本的逻辑，并将 template 中的模板渲染出来，并返回给用户，这个时候就需要在 handler 里使用上一级目录的文件了。</description></item><item><title>浅谈我为什么从 HEXO 迁移到 HUGO</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%B5%85%E8%B0%88%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ehexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</link><pubDate>Wed, 30 Aug 2023 10:53:08 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%B5%85%E8%B0%88%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ehexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo/</guid><description>一、为什么选择Hugo 我一直在使用 HEXO 作为我的网站建设工具。最主要的原因在于容易理解，相对比较容易上手，并且有很多齐全的插件供你选择。
首先，第一点得提的就是 Hugo 打出的标语 &amp;ndash; The world’s fastest framework for building websites。 Hugo 依靠 Go 语言进行开发，号称世界上最快的构建网站工具。HUGO 具有快速建站的能力。与其他网站建设工具相比，HUGO 具有更快的启动时间和更快的页面加载速度。这对于需要快速响应的网站来说尤为重要。
正是依赖于 Hugo 快速生成的特点，调试方便成了 Hugo 的第二大特点。基本上我在使用 Markdown 语言进行页面编写处修改的内容可以实时地显示在网页上，而不用再次敲命令生成再预览。
第三点自己也是学习和使用 GO 语言，所以也会有所青睐。
二、安装 Hugo 在 macOS 上安装 Hugo 前置条件需要安装 brew。
Homebrew 是一款适用于 macOS 和 Linux 的免费开源包管理器。
安装 GO 和 Git 可以使用 brew 包管理工具 // 升级 brew brew update &amp;amp;&amp;amp; brew upgrade // 安装 Git brew install git // 安装 Go brew install go 安装 Hugo brew 扩展版本： brew install hugo 三、Hugo 快速入门 执行以下命令</description></item><item><title>Golang-使用gvm进行版本控制</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 14 Aug 2023 18:00:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E4%BD%BF%E7%94%A8gvm%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</guid><description>当你想为每个项目切换 go 版本时，gvm (Go Version Manager) 很方便。
这里，我将介绍“如何在Mac上安装gvm”和“如何使用gvm”
使用准备 仅适用于 Mac 的准备工作 按照MacOSX 要求中的说明执行以下命令。
xcode-select --install brew update brew install mercurial gvm安装 我使用 zsh 作为我的 shell。
$ echo $SHELL /bin/zsh 对于 zsh，您可以这样安装：
$ zsh &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) Cloning from https://github.com/moovweb/gvm.git to /Users/user_name/.gvm No existing Go versions detected Installed GVM v1.0.22 Please restart your terminal session or to get started right away run `source /Users/user_name/.gvm/scripts/gvm` ~/.zshrc 以下行被添加到最后一行
[[ -s &amp;#34;/Users/user_name/.</description></item><item><title>Golang-语言源码级调试器 Delve</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</link><pubDate>Fri, 11 Aug 2023 15:43:40 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E7%BA%A7%E8%B0%83%E8%AF%95%E5%99%A8-delve/</guid><description>前言 Go 目前的调试器有如下几种：
GDB 最早期的调试工具，现在用的很少。 LLDB macOS 系统推荐的标准调试工具，单 Go 的一些专有特性支持的比较少。 Delve 专门为 Go 语言打造的调试工具，使用最为广泛。 本篇简单说明如何使用 Delve 工具来调试 Go 程序，使用的 delve 版本为 1.20.1。
delve 的汉语意思是：钻研、探索；用这个来命名一个debug工具还是非常的形象。
安装 已知以下说明适用于 Linux、macOS、Windows 和 FreeBSD。
克隆 git 存储库并构建：
$ git clone https://github.com/go-delve/delve $ cd delve $ go install github.com/go-delve/delve/cmd/dlv 或者，在 Go 版本 1.16 或更高版本上：
Install the latest release: $ go install github.com/go-delve/delve/cmd/dlv@latest
Install at tree head: $ go install github.com/go-delve/delve/cmd/dlv@master
安装在一个特定的版本或:
$ go install github.com/go-delve/delve/cmd/dlv@v1.7.3 $ go install github.</description></item><item><title>Golang-常见数据结构Slice</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</link><pubDate>Sun, 30 Apr 2023 00:56:46 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84slice/</guid><description>Golang-常见数据结构Slice Slice slice 翻译成中文就是切片，它和数组（array）很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。
了解 slice 的本质, 最简单的方法就是看它的源码:
// runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } slice 共有三个属性:
指针 指向底层数组 长度 表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度 容量 底层数组的元素个数，容量 &amp;gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。 注意: 底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。
slice 创建 方式 代码示例 直接声明 var slice []int new slice := *new([]int) 字面量 slice := []int{1,2,3,4} make slice := make(int[], 5, 10) 从切片或者数组&amp;quot;截取&amp;quot; slice := array[1:5] 或 slice := sourceSlice[1:5] 直接声明</description></item><item><title>Golang-常见数据结构Map</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</link><pubDate>Tue, 11 Apr 2023 10:07:33 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84map/</guid><description>Map map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。
map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。
哈希表 哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表， 有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。
设计原理 哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。
哈希函数 实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键能够地映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。
完美哈希函数如图: 比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。
不均匀哈希函数如图: 在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。
冲突解决 哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。
开放寻址法 开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从索引开始遍历
当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置 开放地址法写入数据如图: 如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲内存中；当我们再去读取 Key3 对应的值时就会先对键进行哈希并取模，这会帮助我们找到 Key1，因为 Key1 与我们期望的键 Key3 不匹配，所以会继续查找后面的元素，直到内存为空或者找到目标元素。
开放地址法读取数据如图: 当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。
开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找任意元素都需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。
拉链法
与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。
实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』： 拉链法写入数据如图: 如上图所示，当我们需要将一个键值对 (Key6, Value6) 写入哈希表时，键值对中的键 Key6 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模</description></item><item><title>微服务 API 网关对比和选型</title><link>https://blog.ch3nnn.cn/posts/2023/%E5%BE%AE%E6%9C%8D%E5%8A%A1api%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</link><pubDate>Tue, 04 Apr 2023 16:45:00 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E5%BE%AE%E6%9C%8D%E5%8A%A1api%E7%BD%91%E5%85%B3%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%89%E5%9E%8B/</guid><description>什么是微服务 微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。 在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。微服务是互联网业务发展的结果，互联网业务的飞速发展导致系统的架构也在不断地发生变化，总体来说，系统的架构大致经历了：单体应用架构—&amp;gt; SOA 架构—&amp;gt;微服务架构 的演变，具体发展历程和各自的优缺点如下表所示。 因此，微服务是互联网发展的必然结果，很多传统公司的系统架构也在逐步微服务化。但是，随着互联网业务的发展，API 的数量也在剧增，使用网关对API统一管理也将面临挑战，选择一个更强大的 API 网关，可以有效地增强系统的监控、容灾、鉴权和限流等能力。
什么是微服务网关 API网关是一个服务器，是系统的唯一入口。 从面向对象设计的角度看，它与外观模式类似。
API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。
API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。 通常，网关也是提供REST/HTTP的访问API。 微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：
数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。 控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。
微服务遇到的挑战
微服务网关应该首先要具备 API 路由能力，微服务数量变多，API 数量急剧增加，网关还可以根据具体的场景作为流量过滤器来使用，以提供某些额外可选功能，因此对微服务 API Gateway 提出了更高要求，比如：
可观测性：在以往的单体应用中，排查问题往往通过查看日志定位错误信息和异常堆栈；但是在微服务架构中服务繁多，出现问题时的问题定位变得非常困难；因此，如何监控微服务的运行状况、当出现异常时能快速给出报警，这给开发人员带来很大挑战。 鉴权认证：而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其它服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在微服务架构下，要考虑外部应用接入的场景、用户 -
服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。 系统稳定性：若大量请求超过微服务的处理能力时，可能会将服务打垮，甚至产生雪崩效应、影响系统的整体稳定性。 服务发现：微服务的分散管理，让微服务的负载均衡的实现也更具有挑战性。 解决方案
API 网关作为客户端和服务端的中间桥梁，为微服务系统提供统一的管理机制： 除了基础的请求分发、API 管理和条件路由等功能，还包括身份验证、监控报警、调用链追踪、负载均衡、限流隔离和熔断降级。身份认证：下图表示的是微服务联合 API 网关如何进行身份认证的，由图可见所有请求都通过网关，从而有效地隐藏了微服务。
监控报警/调用链追踪： API 作为客户端和服务端的中间桥梁，是微服务监控的最好载体，API 网关监控功能的主要职责是及时发现网关以及后端服务器的连接异常，在 API 的监控平台上面用户可以随时查看日志信息，监控信息，调用链等等，并且主机发生的任何异常都会自动报警到控制台。有些网关甚至可以做到给客户端和服务端双向报警。
限流隔离/熔断降级： 随着互联网业务规模的增加，系统的并发度增高，多个服务之间相互调用链路，一条核心链路往往可能调用十个服务。如果在链路中，某个服务的 rt（响应时间）急剧上升，上游服务不断请求，造成恶性循环，上游等待结果线程数越多，使得更上游服务阻塞最终整条链路无法使用，从而导致服务雪崩，所以对入口流量进行整治管理是很有必要的，下图表示微服务系统是如何结合 API 网关进行限流隔离和熔断降级的。
主流网关选择 在微服务领域，有许多开源网关实现，有 NGINX、Kong、Apache APISIX 和 Envoy 等，Java 技术栈的有 Netfilx Zuul、Spring Cloud Gateway、Soul 等。或许你会问“有了 NGINX 和 Kong，为什么还需要 Apache APISIX？” ，下面做个简单对比。</description></item><item><title>Crx搜搜 - 一个牛X的扩展商店</title><link>https://blog.ch3nnn.cn/posts/2023/crx%E6%90%9C%E6%90%9C-%E4%B8%80%E4%B8%AA%E7%89%9Bx%E7%9A%84%E6%89%A9%E5%B1%95%E5%95%86%E5%BA%97/</link><pubDate>Thu, 30 Mar 2023 10:08:23 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/crx%E6%90%9C%E6%90%9C-%E4%B8%80%E4%B8%AA%E7%89%9Bx%E7%9A%84%E6%89%A9%E5%B1%95%E5%95%86%E5%BA%97/</guid><description>由于 Chrome 扩展商店
无法访问，很多浏览器的官方扩展商店无人维护，国内各种下载站套路太多，导致很难下载到所需要的浏览器扩展/插件。
Crx搜搜(opens new window)利用独家技术，实时解析各大扩展商店最新版扩展下载地址，直接下载.crx或.xpi安装包。 现已支持以下扩展商店：
扩展/应用商店 支持功能 Chrome 扩展商店(opens new window) ✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索 Edge 扩展商店(opens new window) ✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索 Firefox 扩展商店(opens new window) ✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索 Microsoft 应用商店(opens new window) ✔️ 解析 ✔️ 下载 ✔️ 在线安装 ✔️ 离线安装 ✔️ 查看详情 ✔️ 搜索 Opera 扩展商店 ✔️ 解析 ✔️ 下载 ❌ 在线安装 ✔️ 离线安装 ❌ 查看详情 ❌ 搜索 📖 功能简介 下载的扩展兼容以下浏览器：</description></item><item><title>推荐一款超级好用的工具:uTools</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E8%B6%85%E7%BA%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7utools/</link><pubDate>Thu, 23 Mar 2023 05:56:04 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E8%B6%85%E7%BA%A7%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7utools/</guid><description>uTools 是什么？ uTools = your tools（你的工具集）
uTools 是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。
通过快捷键（默认alt + space）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，能够处理此内容的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。
uTools 能做什么？ 最简单的，uTools 可以作为一个程序快速启动器，支持英文、英文驼峰、中文拼音、拼音首字母来打开你的本地程序。除程序外， win10+ 和 MacOS 用户还可以快速搜索并打开「控制面板」内的细项。总之，你只要还记得一个大概的名字，直接输入基本都能找到。
一切皆插件！ 启动已安装的程序仅仅是最基础的功能，uTools 最大的特点就是拥有强大的插件系统。
现在已有 700+ 的插件供你选择，每个插件解决一个具体场景的问题，简洁美观、即用即走。
输入插件应用市场进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最称手的工具集合，为各种日常操作提供便利，不断产生的新插件，将为你带来无限可能。
超级面板 可以通过鼠标右键/中键（可配置），快速打开 uTools 超级面板，uTools 会根据当前选择的内容（文本、截图、文件、文件夹）自动匹配已安装的插件供你选择。与平时使用右键类似的习惯，uTools 超级面板却能为你带来完全不一样的内容及体验。
针对英文，还提供单词词典和整句翻译功能。</description></item><item><title>Golang-channel通道</title><link>https://blog.ch3nnn.cn/posts/2023/golang-channel%E9%80%9A%E9%81%93/</link><pubDate>Sun, 19 Mar 2023 17:41:05 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-channel%E9%80%9A%E9%81%93/</guid><description>goroutine 和 channel (通道)并成为 Go 并发的两大基石。channel 可以放心地在多个 goroutine 之间使用, 因为它是并发安全的。
channel 有哪些应用 停止信号 channel 用于停止信号的场景很多，通常是通过关闭某个channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作，如停止某个循环等。
定时任务 与计时器结合，一般有两种做法：实现超时控制、实现定期执行某个任务。 有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定。这就是时控制：
select { case &amp;lt;- time.After(100*time.Millisecond): case &amp;lt;- s.stopc: return false } 等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。
定时执行某个任务，也比较简单：
func worker() { ticker := time.Tick(1 * time.Second) for { select { case &amp;lt;- ticker: // 执行定时任务 fmt.Println(&amp;#34;执行 1s 定时任务&amp;#34;) } } } 每隔 1 秒种，执行一次定时任务。
解耦生产方和消费方 服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行：</description></item><item><title>Golang-垃圾回收</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Sat, 18 Mar 2023 23:21:06 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。 GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。
垃圾回收算法 目前比较常见的垃圾回收算法有三种： 引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。
代表语言：Python、PHP、Swift 优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。 缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。 标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。
代表语言：Golang（三色标记法） 优点：解决了引用计数的缺点。 缺点：需要 STW，暂时停掉程序运行。 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
代表语言：Java 优点：回收性能好 缺点：算法复杂 Golang 垃圾回收 Go1.3之前 标记清除法 进行 STW（stop the world 即暂停程序业务逻辑），然后从 main 函数开始找到不可达的内存占用和可达的内存占用 开始标记，程序找出可达内存占用并做标记 标记结束清除未标记的内存占用 结束 STW 停止暂停，让程序继续运行，循环该过程直到 main 生命周期结束 一开始的做法是将垃圾清理结束时才停止 STW，后来优化了方案将清理垃圾放到了 STW 之后，与程序运行同时进行，这样做减小了 STW 的时长。 但是 STW 会暂停用户逻辑对程序的性能影响是非常大的，这种粒度的 STW 对于性能较高的程序还是无法接受，但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。 因此 Go1.5 采用了三色标记法优化了 STW。
Go1.5之后 三色并发标记法 三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：
灰色：对象还在标记队列中等待 黑色：对象已被标记，gcmarkBits对应位为 1 – 该对象不会在本次 GC 中被回收 白色：对象未被标记，gcmarkBits对应位为 0 – 该对象将会在本次 GC 中被清理</description></item><item><title>Golang-Modules的演进史</title><link>https://blog.ch3nnn.cn/posts/2023/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</link><pubDate>Mon, 13 Mar 2023 11:53:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-modules%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2/</guid><description>介绍 Go 语言在 v1.11 开始支持 Modules，本文我们介绍一下 Go 语言各个版本支持 Go Modules 的演进史。
使用 Go Modules 模式，一般分为以下几个流程：
go mod init 创建一个新模块，初始化 go.mod 文件。 go build、go test、go run、go install 等构建命令，向 go.mod文件中添加模块所需的依赖项。 go list -m -json all 打印当前模块的依赖项。 go get 添加依赖项，或修改依赖项版本。 go mod tidy 删除未使用的依赖项。 Go Modules 演进史 Go v1.11 从 Go v1.11 开始支持 Go Moduls。 为了兼容使用 Go v1.11 之前的任意版本的项目，当设置 GO111MODULE=auto 或 GO111MODULE=off 时，Go v1.11 在 $GOPATH/src 中，继续使用 GOPATH 模式。 当设置 GO111MODULE=auto 时，其它任意位置，如果当前目录或父目录包含 go.mod 文件，则使用 Modules 模式。</description></item><item><title>Golang-逃逸分析</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link><pubDate>Tue, 07 Mar 2023 13:38:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid><description>什么是堆/栈 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多 栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上 什么是逃逸分析 我们如何知道一个对象是应该放在堆内存，还是栈内存之上呢？可以官网的FAQ（地址：https://go.dev/doc/faq#stack_or_heap）中找到答案. 大致意思是:
从正确性的角度来看，你不需要知道。Go中的每个变量都存在，只要有对它的引用。实现选择的存储位置与语言的语义无关。 存储位置确实对编写高效的程序有影响。如果可能的话，Go编译器将为该函数的堆栈帧中的函数分配局部变量。但是，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在有垃圾回收的堆上分配该变量，以避免悬空指针错误。此外，如果局部变量非常大，那么将其存储在堆中可能比存储在栈中更有意义。 在当前编译器中，如果变量的地址被占用，那么该变量就是堆上分配内存的候选变量。然而，基本的逃逸分析可以识别出某些情况下，这些变量将不会存在于函数返回之后，而可以驻留在栈中。
在什么阶段确立逃逸 Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的。
逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析 如果变量在函数外部没有引用，则优先放到栈中 如果变量在函数外部存在引用，则必定放在堆中 逃逸规则 我们其实都知道一个普遍的规则，就是如果变量需要使用堆空间，那么他就应该进行逃逸。但是实际上Golang并不仅仅把逃逸的规则如此泛泛。Golang会有很多场景具备出现逃逸的现象。
一般我们给一个引用类对象中的引用类成员进行赋值，可能出现逃逸现象。可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问了，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。
Go语言中的引用类型有func（函数类型），interface（接口类型），slice（切片类型），map（字典类型），channel（管道类型），*（指针类型）等。
怎么确定是否逃逸 可以使用编译器提供的指令-gcflags 就可以看到详细的逃逸分析过程，命令如下：
go build -gcflags &amp;#39;-m -l&amp;#39; main.go 其指令涉及的参数如下：
-m：打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是这样子调试的信息量较大，一般用一个就足够了。 -l ：禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。 常见逃逸案例分析 new的变量在栈还是堆
package main func foo(argVal int) (*int) { var fooVal1 = new(int) var fooVal2 = new(int) var fooVal3 = new(int) var fooVal4 = new(int) var fooVal5 = new(int) //此处循环是防止go编译器将foo优化成inline(内联函数) //如果是内联函数，main调用foo将是原地展开，所以fooVal 1-5 相当于main作用域的变量 //即使fooVal3发生逃逸，地址与其他也是连续的 for i := 0; i &amp;lt; 5; i++ { println(argVal, fooVal1, fooVal2, fooVal3, fooVal4, fooVal5) } //fooVal3 return fooVal3 } func main() { mainVal := foo(666) println(*mainVal, mainVal) } 我们将fooVal 1-5 全部用new的方式来开辟, 编译运行看结果, 显然fooVal3发生了逃逸</description></item><item><title>Golang-GMP模型</title><link>https://blog.ch3nnn.cn/posts/2023/golang-gmp%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 02 Mar 2023 16:45:39 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-gmp%E6%A8%A1%E5%9E%8B/</guid><description>写在前面 Go 为了自身 goroutine 执行和调度的效率，自身在 runtime 中实现了一套 goroutine 的调度器，下面通过一段简单的代码展示一下 Go 应用程序在运行时的 goroutine，方便大家更好的理解。
The Go scheduler is part of the Go runtime, and the Go runtime is built into your application
for i := 0; i &amp;lt; 4; i++ { go func() { time.Sleep(time.Second) }() } fmt.Println(runtime.NumGoroutine()) 上面这段代码的输出为：5 说明当前这个应用程序中存在 goroutine 的数量是 5，事实上也符合我们的预期。那么问题来了，这 5 个 goroutine 作为操作系统用户态的基本调度单元是无法直接占用操作系统的资源来执行的，必须经过内核级线程的分发，这是操作系统内部线程调度的基本模型，根据用户级线程和内核级线程的对应关系可以分为 1 对 1，N 对 1 以及 M 对 N 这三种模型，那么上述的 5 个 goroutine 在内核级线程上是怎么被分发的，这就是 Go语言的 goroutine 调度器决定的。</description></item><item><title>Filebeat轻量型日志采集器-自定义processors处理器</title><link>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</link><pubDate>Thu, 23 Feb 2023 18:14:25 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8-%E8%87%AA%E5%AE%9A%E4%B9%89processors%E5%A4%84%E7%90%86%E5%99%A8/</guid><description>引入对beat的依赖 go get github.com/elastic/beats/v7
定义在filebeat中的配置文件 filebeat通常以配置文件的方式加载插件。让定义一下自定义配置。
filebeat.inputs: - type: log paths: - example/example.log processors: # 自定义处理器插件 - parse_text: file_has_suffix: example.log output.console: pretty: true go文件中的配置 package actions type config struct { FileHasSuffix string `config:&amp;#34;file_has_suffix&amp;#34; validate:&amp;#34;required&amp;#34;` } 初始化加载插件 func init() { processors.RegisterPlugin(&amp;#34;parse_text&amp;#34;, checks.ConfigChecked(NewParseText, checks.RequireFields(&amp;#34;file_has_suffix&amp;#34;)), ) } Run接口 处理 filebeat 读取到的每行日志数据message, 这里我们就可以自定义一些处理解析逻辑, 下面逻辑是将日志数据按,切分,重新组装到event.Fields字段里.
func (p parseText) Run(event *beat.Event) (*beat.Event, error) { if !p.isParseFile(event) { return event, nil } message, err := p.getMessage(event) if err !</description></item><item><title>Golang-数组与切片常见错误及陷阱</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</link><pubDate>Wed, 15 Feb 2023 16:34:35 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E9%99%B7%E9%98%B1/</guid><description>nil切片、空切片、零切片 零切片
var s = make([]int, 10) fmt.Println(s) ------------ [0 0 0 0 0 0 0 0 0 0] 表示底层数组的二进制内容都是零
「空切片」和 「nil 切片」
var s1 []int var s2 = []int{} var s3 = make([]int, 0) // new 函数返回是指针类型，所以需要使用 * 号来解引用 var s4 = *new([]int) fmt.Println(len(s1), len(s2), len(s3), len(s4)) fmt.Println(cap(s1), cap(s2), cap(s3), cap(s4)) fmt.Println(s1, s2, s3, s4) ---------------- 0 0 0 0 0 0 0 0 [] [] [] [] 上面这四种形式从输出结果上来看，似乎一摸一样，没区别。但是实际上是有区别的，我们要讲的两种特殊类型「空切片」和「 nil 切片」，就隐藏在上面的四种形式之中。</description></item><item><title>Golang-代码断行规则</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</link><pubDate>Thu, 02 Feb 2023 16:37:59 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E4%BB%A3%E7%A0%81%E6%96%AD%E8%A1%8C%E8%A7%84%E5%88%99/</guid><description>如果你已经写了一些Go代码，你应该知道，Go代码风格不能太随意。 具体说来，我们不能随意在某个空格或者符号字符处断行。 本文余下的部分将列出Go代码中的详细断行规则。
分号插入规则 我们在Go编程中常遵循的一个规则是：一个显式代码块的起始左大括号{不放在下一行。 比如，下面这个for循环代码块编译将失败。
for i := 5; i &amp;gt; 0; i-- { // error: 未预料到的新行 } 为了让上面这个for循环代码块编译成功，我们不能在起始左大括号{前断行，而应该像下面这样进行修改：
for i := 5; i &amp;gt; 0; i-- { } 然而，有时候起始左大括号{却可以放在一个新行上，比如下面这个for循环代编译时没有问题的。
for { // do something ... } 那么，Go代码中的根本性换行规则究竟是如何定义的呢？ 在回答这个问题之前，我们应该知道一个事实：正式的Go语法是使用（英文）分号;做为结尾标识符的。 但是，我们很少在Go代码中使用和看到分号。为什么呢？原因是大多数分号都是可选的，因此它们常常被省略。 在编译时刻，Go编译器会自动插入这些省略的分号。
比如，下面这个程序中的十个分号都是可以被省略掉的。
package main; import &amp;#34;fmt&amp;#34;; func main() { var ( i int; sum int; ); for i &amp;lt; 6 { sum += i; i++; }; fmt.Println(sum); }; 假设上面这个程序存储在一个semicolons.go文件中，我们可以运行go fmt semicolons.</description></item><item><title>Facebook 开源 Golang 实体框架 Ent</title><link>https://blog.ch3nnn.cn/posts/2023/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 16 Jan 2023 17:29:45 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/facebook-ent%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BD%93%E6%A1%86%E6%9E%B6/</guid><description>ent是一个简单而又功能强大的Go语言实体框架，ent易于构建和维护应用程序与大数据模型。
图就是代码 - 将任何数据库表建模为Go对象。 轻松地遍历任何图形 - 可以轻松地运行查询、聚合和遍历任何图形结构。 静态类型和显式API - 使用代码生成静态类型和显式API，查询数据更加便捷。 多存储驱动程序 - 支持MySQL, PostgreSQL, SQLite 和 Gremlin。 可扩展 - 简单地扩展和使用Go模板自定义。 安装 go install entgo.io/ent/cmd/ent@latest 快速开始 go mod init &amp;lt;project&amp;gt; 创建你的第一个项目 进入你项目的根目录，然后运行：
go run -mod=mod entgo.io/ent/cmd/ent init User 以上的命令会在&amp;lt;project&amp;gt;/ent/schema/目录下产生User的数据模式（数据模式是数据库系统设计中的专业术语，若对该部分有任何理解问题，请查阅数据库系统的相关书籍）：
package schema import &amp;#34;entgo.io/ent&amp;#34; // User在User实体中组合了ent默认的数据库模式定义 type User struct { ent.Schema } // User的字段 func (User) Fields() []ent.Field { return nil } // User的边 func (User) Edges() []ent.Edge { return nil } 为User 模式添加两个字段：</description></item><item><title>Golang:停止Goroutine有几种方法</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 12 Jan 2023 18:23:23 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E5%81%9C%E6%AD%A2goroutine%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>goroutine介绍 goroutine 是 Go 语言实现并发编程的利器，是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理，简单的一个指令go function就能启动一个 goroutine；Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。
但是，Go语言并没有提供终止goroutine的接口，也就是说，我们不能从外部去停止一个goroutine，只能由goroutine内部退出(main函数终止除外)；
goroutine 案例 日常开发开启一个 goroutine go代码, 只需一个 go 关键字即可:
var wg sync.WaitGroup // 等待组，用来阻塞程序 func main() { wg.Add(1) // 等待组 +1 go func() { for { fmt.Println(&amp;#34;开启 goroutine&amp;#34;) } }() wg.Wait() } 几种停止的办法 Go 目前用 channel 或 context 的方式来取消 (cancelation) 给 goroutine。
Channel 第一种方法，就是借助 channel 的 close 机制来完成对 goroutine 的精确控制。 func main() { msg := make(chan struct{}) go func() { fmt.</description></item><item><title>Golang:值传递还是引用传递</title><link>https://blog.ch3nnn.cn/posts/2023/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 09 Jan 2023 18:09:14 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/golang-%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid><description>Go 官方的定义 本部分引用 Go 官方 FAQ 的 “When are function parameters passed by value?”，内容如下。
如同 C 系列的所有语言一样，Go 语言中的所有东西都是以值传递的。也就是说，一个函数总是得到一个被传递的东西的副本，就像有一个赋值语句将值赋给参数一样。
传值和传引用 什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。其指的是在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。
对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。
test_demo.go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;testing&amp;#34; ) func modify(ip *int) { fmt.Printf(&amp;#34;函数里接收到的指针的内存地址是：%p\n&amp;#34;, &amp;amp;ip) *ip = 1 } func TestDemo(t *testing.T) { i := 10 ip := &amp;amp;i fmt.Printf(&amp;#34;原始指针的内存地址是：%p\n&amp;#34;, &amp;amp;ip) modify(ip) fmt.Println(&amp;#34;int值被修改了，新值为:&amp;#34;, i) } 输出结果:
原始指针的内存地址是：0xc00000e038 函数里接收到的指针的内存地址是：0xc00000e040 int值被修改了，新值为: 1 什么是传引用(引用传递) 传引用，也叫做引用传递， 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
在 Go 语言中，官方已经明确了没有传引用，也就是没有引用传递这一情况。
争议最大的 map 和 slice 这时候又有小伙伴疑惑了，你看 Go 语言中的 map 和 slice 类型，能直接修改，难道不是同个内存地址，不是引用了？</description></item><item><title>Filebeat轻量型日志采集器及output插件开发</title><link>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</link><pubDate>Mon, 09 Jan 2023 16:36:01 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/filebeat%E8%BD%BB%E9%87%8F%E5%9E%8B%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E5%8F%8Aoutput%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</guid><description>无论您是从安全设备、云、容器、主机还是 OT 进行数据收集，Filebeat 都将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。
介绍 Filebeat 是使用 Golang 实现的轻量型日志采集器。本质上是一个 agent ，可以安装在各个节点上，根据配置读取对应位置的日志，并上报到相应的地方去。
概要 Filebeat 并不依赖于 ElasticSearch，可以单独存在。我们可以单独使用Filebeat进行日志的上报和搜集。filebeat 内置了常用的 Output 组件, 例如 kafka、ElasticSearch、redis 等，出于调试考虑，也可以输出到 console 和 file 。我们可以利用现有的 Output 组件，将日志进行上报。
整体工作原理 Filebeat 由两个主要组件组成：harvester 和 prospector。
harvester (采集器) 的主要职责是读取单个文件的内容。读取每个文件，并将内容发送到 the output。 每个文件启动一个 harvester，harvester 负责打开和关闭文件，这意味着在运行时文件描述符保持打开状态。如果文件在读取时被删除或重命名，Filebeat 将继续读取文件。 prospector (查找器) 的主要职责是管理 harvester 并找到所有要读取的文件来源。如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个 harvester。每个 prospector 都在自己的 Go 协程中运行。 注：Filebeat prospector只能读取本地文件， 没有功能可以连接到远程主机来读取存储的文件或日志。
由以上两个组件一起工作来读取文件（tail file）并将事件数据发送到指定的输出。 下图是 Filebeat 官方提供的架构图： Filebeat背后的“老大” 说到Filebeat，它其实只是beats家族众多成员中的一个。除了Filebeat, 还有很多其他的beat小伙伴：
beat 功能 Filebeat 收集日志文件 Metricbeat 收集各种指标数据 Packetbeat 收集网络数据包 Auditbeat 收集审计数据 Heartbeat 收集服务运行状态监测数据 &amp;hellip; &amp;hellip; 如果你愿意的话，你也可以按照beat的规范来写自己的beat。 能实现以上这些beat，都离不开beats家族真正的“老大”—— libbeat， 它是beat体系的核心库。我们接下来看一下libbeat到底都作了些什么</description></item><item><title>这些最常用的 Go CLI 命令，新手 Gopher 应该掌握</title><link>https://blog.ch3nnn.cn/posts/2023/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 02 Jan 2023 10:28:19 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2023/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84gocli%E5%91%BD%E4%BB%A4/</guid><description>本文将介绍一些最基本的 Go 命令行命令。如果你刚接触 Go 语言，那你有必要记住它们，因为这些命令是 Go 开发者日常工作中所必备的。
Go version
开始 Go 项目前，我们应该确保开发机上已经安装好了 Go 编译器。这可以通过 https://go.dev/doc/install 进行下载安装。
通过执行以下命令可以查看安装的 Go 版本信息。
$ go version go version go1.18 darwin/amd64 Go env
如果我们可能想查看一些 Go 相关的环境变量，例如 GOROOT 或者 GOPATH。你可以执行这个命令。
$ go env 当你想对某个环境变量进行更改，例如修改 Go 代理，你可以这样做。
$ go env -w GOPROXY=https://goproxy.io,direct go mod
在你开始建立第一个 Go 程序时，在项目根目录下，你应该运行这样的命令。
$ go mod init &amp;lt;your project name&amp;gt; 例如
$ go mod init demo/firstProject 此时，项目根目录将增加 go.mod 文件，它的内容如下
$ cat go.mod module demo/firstProject go 1.</description></item><item><title>「回顾2022，展望2023」 —— 年终总结</title><link>https://blog.ch3nnn.cn/posts/2022/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 01 Jan 2023 23:41:48 +0000</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/%E6%88%91%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid><description> 致自己：折腾不息 · 乐此不疲!
22 年收获 技术上
编程语言方面 Golang: 从开始学习到现在的一年时间里, 前前后后也写了些代码, 其中包括业余时间的, 也有产品项目中的. 在摸滚打爬中对于Golang的使用算是勉强达到了较为熟练的状态. 开源贡献方向 jaywcjlove/reference 为开发人员分享快速参考备忘清单(速查表) liangliangyy/DjangoBlog 基于Django的博客系统 Lcry/a-sheep-assistant 羊了个羊助手，羊了个羊一键闯关 生活上
疫情防控 保持绿码, 小🐑人中&amp;hellip; 还以为自己就是那位&amp;quot;天选之子&amp;quot;(又开始吹牛皮). 生活情感 端午节前带女朋友回家, 父母都感觉很满意, 生活很幸福, 偶尔会吵吵嘴毕竟生活需要增加些乐趣嘛(哈哈哈). 工作上
从互联网医疗到工控安全行业, 工作内容没有任何变化(就是撸码搬砖🧱) 23年展望 2023年是新的一年，新的一年就会有新的flag。新的一年我要以下几件事:
保持持续学习的激情、态度 持续开源贡献 真的需要运动(感觉自己要废了) 感情上还是需要更加谦让 &amp;hellip; 写在最后 最后, 最后, Happy New Year &amp;hellip; 或者至少, 平平安安度过新的一年 各位, 继续加油吧! 冲冲冲!</description></item><item><title>About</title><link>https://blog.ch3nnn.cn/about/</link><pubDate>Mon, 29 Aug 2022 14:04:30 +0800</pubDate><guid>https://blog.ch3nnn.cn/about/</guid><description>关于作者 我叫陈通, 来自南方的某个小城市. 现坐标：杭州.
对自己的技术栈认为: 擅长增删改查、代码搬运、面向搜索引擎编程.
👀 正在学习 Golang ⭐️ Github https://github.com/ch3nnn 📗 Blog 平时想起来就写点 [Ch3nnnnn个人博客] 📖 CSDN [CSDN博客] 💬 微信公众号: 暹罗猫十七 联系方式 终端执行以下命令:
echo &amp;#39;H4sIAHY712MC/+VWy0oDMRTd5ysuzL4ggouudOEHqAuXUsZAC85Uii5c6lrwF/QHuhIFC/ozU4p/ISLM3HMfSRQ3YqBlMpOcnJx7cm8CZdp+M5md0fvNsls9jUNqZD2N7 ehq1i5iu7u1sz2q500IOfjjWE8nF7R+XXZvD+u753F2Bp0cXZ7HRbPX5oeGgqUPDqmen0bqXm43q8fN/XWaQqh+uf0ZQCXF56uvH/ur+k+kpyhAtgqx6TCcD4MZlQnIyPU95F8B zeHD9wD5a7a3HwAyOopmEaDUkMNhSADC0zAfZfaQjbLTOKBWsciHXFEO0CsKW/Q1NL1hGpsxliEytoyK8A6LhtaFvw5CMRlV2wM6zo4PtT+8LTv8NMMKcIfxWi5c3jW20NpyPGrs A9oMCIhgpLgnjC0zeVB0XEn7wAMEnSRZkolSLmCcFJmn0DZWljBlDo5HdY62kgFJ66Y1tPp2K6p6MlkgrmadzYfWyTFrihllp+qh0fkCnuaJmqKPnhkfecDTVW8gI9OXPHPFVQ9d KKNjZKqQzgE6K4MkyaC4VU/fQNSNxDnL/+V++AGgTu5uRQwAAA==&amp;#39; | base64 --decode | gzip -d</description></item><item><title>桌面字幕——实时语音翻译</title><link>https://blog.ch3nnn.cn/posts/2022/%E6%A1%8C%E9%9D%A2%E5%AD%97%E5%B9%95%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E7%BF%BB%E8%AF%91/</link><pubDate>Sat, 08 Jan 2022 17:00:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2022/%E6%A1%8C%E9%9D%A2%E5%AD%97%E5%B9%95%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E7%BF%BB%E8%AF%91/</guid><description>介绍
这是一个基于Java11 + idea 2021.2.2 有道智能云Ai-实时语音翻译转写实现的翻译桌面字幕。 代码实现非常简单，根据有道智能云开发文档里面的demo代码复制粘贴就完成了。
实时语音识别的效果不错，可以用于在线小语种教学视频。
github:https://github.com/ct437383389/DesktopSubtitles
效果:
技术栈
使用 JavaFx 实现透明窗口 + Label Java11 使用方式
填写 StreamSpeechTask run方法 智能云 appKey appSecret
资料
在此感谢大佬提供参考源码实时语音翻译https://github.com/yi-ge/desktop-subtitle 有道智能云实时语音翻译文档https://ai.youdao.com/streamingAudio.s</description></item><item><title>Python枚举类自定义状态</title><link>https://blog.ch3nnn.cn/posts/2021/python%E6%9E%9A%E4%B8%BE%E7%B1%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81/</link><pubDate>Thu, 23 Sep 2021 03:02:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2021/python%E6%9E%9A%E4%B8%BE%E7%B1%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81/</guid><description>枚举类不支持实例化； 成员的值不能在类的外部做任何修改，每个成员都有`name`,`value`两个属性，其中`name`为该枚举值的名称，`value`为该枚举值的内容； 定义枚举时，成员名称不允许重复，但在默认情况下，不同的成员值允许相同，两个相同值的成员，第二个成员的名称将会被视作第一个成员的别名，若要限制不能定义相同值的成员。可以使用装饰器`@unique`； 枚举支持迭代器，可以遍历枚举成员；如果枚举有值重复的成员，循环遍历枚举时只获取值重复成员的第一个成员，若想把值重复的成员也遍历出来，要用枚举的一个特殊属性:`__members__`； from enum import Enum from typing import Optional class BaseEnm(Enum): def getCode(self): &amp;#34;&amp;#34;&amp;#34;根据枚举名称取状态码code @return: 状态码code &amp;#34;&amp;#34;&amp;#34; return self.value[0] def getMessage(self): &amp;#34;&amp;#34;&amp;#34;根据枚举名称取状态说明message @return: 状态说明message &amp;#34;&amp;#34;&amp;#34; return self.value[1] @classmethod def messageByCode(cls, code) -&amp;gt; Optional[str]: &amp;#34;&amp;#34;&amp;#34;根据状态码获取状态码说明&amp;#34;&amp;#34;&amp;#34; for name, member in cls.__members__.items(): if code in member.value: return cls[name].getMessage() return None @unique class CallStateResult(BaseEnm): &amp;#34;&amp;#34;&amp;#34;通话状态结果&amp;#34;&amp;#34;&amp;#34; USER_STATE_NULL = (0, &amp;#34;未知的初始状态&amp;#34;) USER_STATE_ANSWERED = (1, &amp;#34;接通&amp;#34;) USER_STATE_POWER_OFF = (2, &amp;#34;关机&amp;#34;) USER_STATE_NOT_EXIST = (3, &amp;#34;空号&amp;#34;) USER_STATE_INVALID_NUM = (4, &amp;#34;非法号码&amp;#34;) USER_STATE_OUTSERVICE = (5, &amp;#34;停机&amp;#34;) USER_STATE_NOT_IN_SERVICE = (6, &amp;#34;不在服务区&amp;#34;) USER_STATE_NOT_ANSWER = (7, &amp;#34;无人接听&amp;#34;) USER_STATE_BUSY = (8, &amp;#34;用户忙&amp;#34;) USER_STATE_NOT_REACHABLE = (9, &amp;#34;无法接通&amp;#34;) USER_STATE_NOT_LOCALNUM_NEED_ZERO = (10, &amp;#34;本地号码未加零&amp;#34;) USER_STATE_LOCALNUM_ADD_ZERO = (11, &amp;#34;本地号码多加零&amp;#34;) USER_STATE_BARRING_INCOMING = (12, &amp;#34;呼入限制&amp;#34;) USER_STATE_CALL_REMINDER = (13, &amp;#34;来电提醒&amp;#34;) USER_STATE_DEFAULTING = (14, &amp;#34;欠费&amp;#34;) USER_STATE_LINE_BUSY = (15, &amp;#34;网络忙&amp;#34;) USER_STATE_FORWARDED = (16, &amp;#34;呼叫转移失败&amp;#34;) USER_STATE_CANNOT_CONNECTED = (17, &amp;#34;无法接听&amp;#34;) USER_STATE_NUMBER_CHANGE = (18, &amp;#34;改号&amp;#34;) USER_STATE_LINE_FAULT = (19, &amp;#34;线路故障&amp;#34;) USER_STATE_CALL_REJECTED = (20, &amp;#34;拒接&amp;#34;) USER_STATE_NOT_RECOGNITION = (21, &amp;#34;未知状态&amp;#34;) USER_STATE_CALL_FAILED = (22, &amp;#34;呼叫失败&amp;#34;) USER_STATE_HANGUP = (100, &amp;#34;通话结束&amp;#34;) if __name__ == &amp;#39;__main__&amp;#39;: print(CallStateResult.</description></item><item><title>Github标星34K+Star，这款开源项目助你秒建Git服务！</title><link>https://blog.ch3nnn.cn/posts/2021/github%E6%A0%87%E6%98%9F34k+star%E8%BF%99%E6%AC%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E7%A7%92%E5%BB%BAgit%E6%9C%8D%E5%8A%A1/</link><pubDate>Tue, 06 Jul 2021 09:01:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2021/github%E6%A0%87%E6%98%9F34k+star%E8%BF%99%E6%AC%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%8A%A9%E4%BD%A0%E7%A7%92%E5%BB%BAgit%E6%9C%8D%E5%8A%A1/</guid><description>以前使用Gitlab搭建过Git服务，如果服务器配置低的话启动和访问都会特别慢。最近发现了Gogs这个开源项目，安装方便，特别轻量级，推荐给大家！
推荐语 一款极易搭建的自助Git服务，特别轻量级，推荐给大家！
Gogs简介 Gogs是一款极易搭建的自助Git服务，使用Go语言开发，只要Go语言支持的平台它都支持，包括Linux、Mac OS X、Windows以及ARM平台。Gogs对系统硬件要求极低，你甚至可以在树莓派上搭建它。
项目地址：https://github.com/gogs/gogs
安装 Gogs在Docker环境下的安装非常简单，只需要两个命令即可，推荐使用该方式来进行安装。
首先我们需要先下载Gogs的Docker镜像； 下载完成后使用`docker run`命令即可运行服务； docker run -p 10022:22 -p 10080:3000 --name=gogs \ -v /mydata/gogs:/data \ -d gogs/gogsCopy to clipboardErrorCopied 这里我们说下命令中值得注意的地方，10022对应的是Gogs的SSH服务端口，10080对应的使用Gogs的HTTP服务端口，我们还将容器的数据目录挂载到了宿主机的/mydata/gogs目录下，这样就算我们重新创建容器数据也不会丢失。 配置 安装完成后，我们第一次访问Gogs服务会显示一个设置页面，访问地址：http://192.168.5.19:10080/
数据库设置，这里我们直接使用内置的SQLite3数据库即可，使用其他的需要自行搭建数据库；
应用基本设置，主要修改域名、SSH端口号和应用URL即可。 使用 注册 配置好以后会直接跳转到登录界面，首先注册一个帐户； 注册完成后，登录即可进入控制面板页面。 创建仓库 直接使用我的仓库右侧的加号即可创建仓库，简单设置下仓库名称和可见性来完成创建； 创建成功后直接使用克隆地址即可克隆该仓库； 我们可以直接使用IDEA的Git检出功能； 检出完成后，加入我们的代码直接提交、推送，在Gogs里面就可以看到我们提交的代码了。 工单管理 这里的工单管理，有点类似Github上面的Issue的功能，我们可以通过创建工单按钮来创建； 输入我们的标题、内容和标签以后即可创建； 创建完成后显示效果如下。 添加用户 有时候管理员需要新建一些帐户来协作开发，此时我们只要点击头像-&amp;gt;管理面板-&amp;gt;用户管理即可打开用户管理界面； 然后点击创建新的帐户，输入相关信息即可完成创建。 管理协作者 创建完成后，我们可以在仓库页面的仓库设置中打开管理协作者功能； 之后通过输入协作者账户，点击增加新的协作者并设置好权限即可，这样协作者就可以访问并向该仓库提交代码了。 迁移外部仓库 Gogs还提供了从外部仓库迁移代码的功能，通过头像左侧的加号，然后选择迁移外部仓库即可； 这里以迁移Gitee上的mall项目为例，项目地址：http://gitee.com/macrozheng/mall 迁移成功后就可以在Gogs里面看到mall项目了！ Gogs VS Gitlab 之前有写过一篇《10分钟搭建自己的Git仓库》，使用的是Gitlab，下面对比下Gogs和Gitlab在安装使用过程中的优缺点，仅代表个人观点。
比较方面 Gogs Gitlab Docker镜像大小 44MB 836MB 启动速度 很快，几秒 很慢，机器配置不好要10分钟 配置要求 很低，树莓派都可以 很高，吃内存，吃CPU 访问速度 够快 机器配置好也还可以 功能 功能较少 功能很丰富 转载: http://www.</description></item><item><title>更换（Pypi）pip源到国内镜像</title><link>https://blog.ch3nnn.cn/posts/2021/%E6%9B%B4%E6%8D%A2pypipip%E6%BA%90%E5%88%B0%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</link><pubDate>Mon, 22 Feb 2021 03:09:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2021/%E6%9B%B4%E6%8D%A2pypipip%E6%BA%90%E5%88%B0%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</guid><description>pip国内的一些镜像 阿里云https://mirrors.aliyun.com/pypi/simple/ 中国科技大学https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban)https://pypi.douban.com/simple/ 清华大学https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学https://pypi.mirrors.ustc.edu.cn/simple/ 提示：若担心安全问题请使用HTTPS加密源
修改源方法： 临时使用： Linux Mac Windows 通用命令
可以在使用pip的时候在后面加上-i参数，指定pip源
pip install scrapy -ihttps://pypi.tuna.tsinghua.edu.cn/simple
永久修改： Linux:
修改 pip.conf 文件 (没有就创建一个)
$HOME/.config/pip/pip.conf
修改内容如下：
[global]
index-url =https://pypi.tuna.tsinghua.edu.cn/simple12
Mac:
修改 pip.conf 文件
$HOME/Library/Application Support/pip/pip.conf
如果没有上面的目录,在如下目录创建 pip.conf
$HOME/.config/pip/pip.conf
修改内容如下：
[global]
index-url =https://pypi.tuna.tsinghua.edu.cn/simple12
Windows:
修改 pip.conf 文件 (没有就创建一个)
%APPDATA%\pip\pip.ini
修改内容如下：
[global]
index-url =https://pypi.tuna.tsinghua.edu.cn/simple
修改文件后，执行命令发生错误 使用非HTTPS加密源（如豆瓣源），在执行命令发生错误，在命令最后加上--trusted-host pypi.douban.com
pip install django -ihttp://pypi.douban.com/simple&amp;ndash;trusted-hostpypi.douban.com</description></item><item><title>Python 使用-gRPC详解</title><link>https://blog.ch3nnn.cn/posts/2020/grpc%E8%AF%A6%E8%A7%A3/</link><pubDate>Thu, 24 Dec 2020 09:05:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/grpc%E8%AF%A6%E8%A7%A3/</guid><description>RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。
RPC 框架的调用原理图如下所示：
gRPC是什么？ 官方文档-Python
gRPC是什么可以用官网的一句话来概括
A high-performance, open-source universal RPC framework
**所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。**如下图所示就是一个典型的RPC结构图。
gRPC有什么好处以及在什么场景下需要用gRPC 既然是server/client模型，那么我们直接用restful api不是也可以满足吗，为什么还需要RPC呢？下面我们就来看看RPC到底有哪些优势
gRPC vs. Restful API gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：
gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文Google Protobuf简明教程 另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。 gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。） gRPC HelloWorld实例详解 gRPC的使用通常包括如下几个步骤：
通过protobuf来定义接口和数据类型 编写gRPC server端代码 编写gRPC client端代码
下面来通过一个实例来详细讲解上述的三步。
下边的hello world实例完成之后，其目录结果如下： 定义接口和数据类型 通过protobuf定义接口和数据类型 syntax = &amp;#34;proto3&amp;#34;; package rpc_package; // define a service service HelloWorldService { // define the interface and data type rpc SayHello (HelloRequest) returns (HelloReply) {} } // define the data type of request message HelloRequest { string name = 1; } // define the data type of response message HelloReply { string message = 1; } 使用gRPC protobuf生成工具生成对应语言的库函数 python -m grpc_tools.</description></item><item><title>PostmanCn:Postman中文版</title><link>https://blog.ch3nnn.cn/posts/2020/postmancnpostman%E4%B8%AD%E6%96%87%E7%89%88/</link><pubDate>Mon, 21 Dec 2020 08:30:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/postmancnpostman%E4%B8%AD%E6%96%87%E7%89%88/</guid><description>最新版本：7.36.1
更新时间：2020-12-18
点击下载
介绍 Postman中文版 汉化 持续更新中
安装教程 Windows Postman-*-win64-中文版.zip 解压直接用
app.zip 解压&amp;amp;&amp;amp;替换文件 应用程序目录/resources/app.asar
Mac Postman官网下载&amp;amp;安装Postman Mac版
下载 Postman-*-Mac-汉化版app.zip
复制到 Postman安装目录 /&amp;hellip;/Postman.app/Contents/Resources/
解压 替换 app目录即可
Linux 解压 替换 app目录即可
https://www.postman.com/downloads/这个是Postman官网的下载页面
https://gitee.com/hlmd/PostmanCn/这个是这里的汉化的</description></item><item><title>MacOS开启外接显示器HiDP</title><link>https://blog.ch3nnn.cn/posts/2020/macos%E5%BC%80%E5%90%AF%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8hidp/</link><pubDate>Tue, 01 Dec 2020 03:05:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/macos%E5%BC%80%E5%90%AF%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8hidp/</guid><description>对以下系统和显示器有效：
macOS 10.12 Sierra
macOS 10.13 High Sierra
macOS 10.14 Mojave
macOS 10.15 Catalina
Dell P2416D, DisplayPort, 1920x1080 HiDPI
Dell P2418D, DisplayPort, 1920x1080 HiDPI
Acer XB241YU, HDMI, 1920x1080 HiDPI
0x1 准备工作： 1. 打开系统HiDPI (在终端运行） sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES 如果使用 4K 或更高分辨率的显示器，macOS 很可能原生支持 HiDPI，建议直接从5. 下载 RDM尝试选择 HiDPI 分辨率。如无法启用或没有合适的分辨率，再使用配置文件。
0x2 获得显示器信息 获得显示器的 VendorID 和 ProductID （制造商ID 和 产品ID），在终端运行：
ioreg -lw0 | grep IODisplayPrefsKey | grep -o &amp;#39;/[^/]\+&amp;#34;$&amp;#39; 输出大概是这样的：
&amp;gt; ioreg -lw0 | grep IODisplayPrefsKey | grep -o &amp;#39;/[^/]\+&amp;#34;$&amp;#39; /AppleBacklightDisplay-610-a029&amp;#34; /AppleDisplay-10ac-a0c4&amp;#34; 这条指令的输出会有多个，注意识别你想要调整的显示器。第一条AppleBacklightDisplay-610-a029是MBP的内置显示屏。第二个是外接显示器。（当然，也可以合上 MBP 屏幕，这样只会输出正在使用的外接显示器）</description></item><item><title>Navicat Premium 15.0.22 中文语言包</title><link>https://blog.ch3nnn.cn/posts/2020/navicatpremium15.0.22%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/</link><pubDate>Mon, 09 Nov 2020 10:57:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/navicatpremium15.0.22%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/</guid><description>Navicat Premium是一个可多重连接的数据库管理工具，Navicat 的功能足以符合专业开发人员的所有需求，但是对数据库服务器的新手来说又相当容易学习。它可让你以单一程序同時连接到目前世面上所有版本的主流数据库并进行管理和操作，支持的数据库有： MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL。让管理不同类型的数据库更加方便。
汉化包 15.0.12 汉化 下载链接: https://pan.baidu.com/s/1SITpWMdXfBhYlis-YL14Tg 密码: vljg中文包 解压复制汉化文件夹放到/Applications/Navicat Premium.app/Contents/Resources 汉化完成
PS:这个zh-Hans.lproj汉化文件是从Navicat Premium官方中文版提取 无毒无害 12.0.12 汉化 下载https://www.pipipan.com/fs/13114864-217250713中文包 复制汉化文件夹放到/Applications/Navicat Premium.app/Contents/Resources 汉化完成
PS:这个zh-Hans.lproj汉化文件是从Navicat Premium 12.0.12官方中文版提取 无毒无害</description></item><item><title>「超级右键」Mac上最强的右键菜单工具，让你效率飞起！</title><link>https://blog.ch3nnn.cn/posts/2020/%E8%B6%85%E7%BA%A7%E5%8F%B3%E9%94%AEmac%E4%B8%8A%E6%9C%80%E5%BC%BA%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E6%95%88%E7%8E%87%E9%A3%9E%E8%B5%B7/</link><pubDate>Mon, 26 Oct 2020 15:03:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/%E8%B6%85%E7%BA%A7%E5%8F%B3%E9%94%AEmac%E4%B8%8A%E6%9C%80%E5%BC%BA%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E6%95%88%E7%8E%87%E9%A3%9E%E8%B5%B7/</guid><description>简介 我对该产品的评价只有六个字：实用、效率、快、得我心
超级右键主要实现了： Mac电脑上右键的扩展，能够新建、发送/复制文件到某个位置、快速打开常用目录、自定义文件夹图标、拷贝路径、终端/iTerm/VSCode 里进入路径、显示隐藏文件、彻底删除文件、剪切粘贴文件、百度翻译、谷歌翻译、右键截图、标注、贴图等等。
**「超级右键」**有一部分功能是借鉴Windows系统的，也有开发者自己新创的功能，总的来说功能完善，且使用快捷，是目前Mac上最强大的右键工具，绝对是Mac用户装机必备。
功能 1.新建文件 **默认支持新建：**TXT/RTF/XML/Word/Excel/PPT/WPS文字/WPS表格/WPS演示/Pages/Numbers/Keynote/Ai/PSD/Markdown格式的文件。
同时还支持
用户自定义添加其他类型文件进行新建。 新建后自动打开文件 新建的时候启用弹窗，命名文件名和文件位置 将新建的文件类型添加到一级菜单目录 新建文件
2.复制/发动文件到指定路径 这个功能可以说非常的实用，以前在Mac上要转移文件的位置，很多时候要先拷贝，然后一层层的打开路径，很费事，有了超级右键，一键发动到位，很方便。
复制文件到
3.常用目录 **「超级右键」**允许用户自定义常用目录，然后使用右键快速打开，非常方便。
常用目录
4.自定义文件夹图标 很多时候，你可能已经厌倦了千篇一律的蓝色文件，想给文件夹带去一点色彩，变得个性化，从视觉上好分辨一些，**「超级右键」**就能帮你轻松办到。
自定义文件夹图标
5.剪切、粘贴 Mac上本来是没有剪切功能的，从Windows转Mac的朋友们肯定觉得不习惯吧。**「超级右键」**为右键新增了剪切、粘贴功能，使用起来非常顺手。
剪切、粘贴
6.截图 Better 365将超级右键与其截图工具iShot进行了联动，可以使用右键调用进行截图，前提是你必须安装了iShot。
右键截图
截图
7.贴图、标注 你还可以直接选中本地已存在的图片，将其贴图，并标记
贴图标注
贴图标注
8.拷贝当前路径 **「超级右键」**可以让你非常方便的拷贝路径，省去手码路径的麻烦。
拷贝当前路径
9、终端、iTerm、VSCode、Sublime Text里打开 如果你需要在终端、等工具里打开文件、路径等，**「超级右键」**也将助你快人一步。
终端、iTerm、VScode等打开 10.显示/隐藏文件 你可以快速地隐藏你电脑上的文件，保护隐私，只有你知道如何显示
显示/隐藏文件
11.彻底删除 彻底删除允许我们不经过废纸篓，直接删掉文件。
12.百度翻译、谷歌翻译、转化为二维码 请输入图片标题
听我说了这么多，不去下载安装体验一把，还在等什么呢？在App Store搜索“超级右键”就可以免费下载啦，快让你快人一步吧！
请输入图片标题</description></item><item><title>Zeal——好用的离线API文档大全</title><link>https://blog.ch3nnn.cn/posts/2020/zeal%E5%A5%BD%E7%94%A8%E7%9A%84%E7%A6%BB%E7%BA%BFapi%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8/</link><pubDate>Mon, 14 Sep 2020 04:39:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/zeal%E5%A5%BD%E7%94%A8%E7%9A%84%E7%A6%BB%E7%BA%BFapi%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8/</guid><description>Zeal是一款离线文档浏览器，其灵感来自 OS X平台上的 Dash，目前支持 Window 和 Liunx。基于 QT5。
支持呼出热键。只要按下组合箭 ALT+Space 即可在任何地方显示面板，不用时可以用热键隐藏的系统托盘。
可同时搜索多个文档
不依赖网络
GPL 协议开放源码
Dash 中的文档都可以在 Zeal 中使用。
安装：
WIndows 自带二进制安装包
Linux 需要安装 QT( &amp;gt;= 5) 和 bsdtar。
软件截图：</description></item><item><title>简洁的 Mac 图床客户端 uPic</title><link>https://blog.ch3nnn.cn/posts/2020/%E7%AE%80%E6%B4%81%E7%9A%84mac%E5%9B%BE%E5%BA%8A%E5%AE%A2%E6%88%B7%E7%AB%AFupic/</link><pubDate>Sun, 28 Jun 2020 14:01:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/%E7%AE%80%E6%B4%81%E7%9A%84mac%E5%9B%BE%E5%BA%8A%E5%AE%A2%E6%88%B7%E7%AB%AFupic/</guid><description>☁️ 简洁的 Mac 图床客户端 uPic 📑 简介 uPic(upload Picture) 是一款 Mac 端的图床(文件)上传客户端
可将图片、各种文件上传到配置好的指定提供商的对象存储中。
然后快速获取可供互联网访问的文件 URL
**💡 特点：**无论是本地文件、或者屏幕截图都可自动上传，菜单栏显示实时上传进度。上传完成后文件链接自动复制到剪切板，让你无论是在写博客、灌水聊天都能快速插入图片。
连接格式可以是普通 URL、HTML 或者 Markdown，仍由你掌控。
🔋 支持图床：smms、又拍云 USS、七牛云 KODO、阿里云 OSS、腾讯云 COS、微博、Github、Gitee、Amazon S3、自定义上传接口、…
🚀 如何安装 下载安装 1.Homebrew: brew cask install upic 2.手动 从Github release下载。
如果访问 Github 下载困难的，可以从Gitee release下载。
检查 Finder 扩展权限 1.打开 uPic
2.打开系统偏好设置-扩展-访达扩展确保uPicFinderExtension是勾选状态
🕹 使用方式 功能 描述 预览 🖥 选择文件上传 从Finder选择文件上传。可设置全局快捷键 ⌨️ 复制文件上传 上传已拷贝到剪切板的文件。可设置全局快捷键 📸 截图上传 直接拉框截图上传。可设置全局快捷键 🖱 拖拽本地文件上传 拖拽文件到状态栏上传 🖱 拖拽浏览器图片上传 从浏览器拖拽图片到状态栏上传 📂 Finder 中右键上传 右击文件上传 ⌨️ 命令行上传 通过执行命令调用 uPic 上传文件 🧰 更多功能 1.</description></item><item><title>使用 Floccus + 坚果云无梯子跨平台同步 Chrome 浏览器书签</title><link>https://blog.ch3nnn.cn/posts/2020/%E4%BD%BF%E7%94%A8floccus+%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%97%A0%E6%A2%AF%E5%AD%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE/</link><pubDate>Fri, 17 Apr 2020 03:23:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2020/%E4%BD%BF%E7%94%A8floccus+%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%97%A0%E6%A2%AF%E5%AD%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE/</guid><description>​
采用的方案是 Chrome / Cent Browser / Firefox / yandex 等 + Floccus + 坚果云（WebDav）实现书签的跨平台多终端同步的。理论上，只要支持Floccus扩展的浏览器，都能实现。
首先给出 FloccusGitHub的地址：https://github.com/marcelklehr/floccus
Floccus 插件的地址：https://chrome.google.com/webstore/detail/fnaicdffflnofjppbagibeoednhnbjhg
安装好并配置完毕:
开始 一、坚果云上的配置
坚果云注册一个免费版个人账号（每日流量限制：上传1G，下载3G，够用了），注册成功登录后，点击右上角的用户名下拉菜单。
注册:https://www.jianguoyun.com/
需要先注册应用
这里需要在我的书签添加自定义名称 在插件服务器地址中需要用到
二、浏览器上的配置
添加账户
位置1中填入 坚果云服务器地址，即：https://dav.jianguoyun.com/dav/自定义书签名称
注意地址后面还有在坚果云添加的书签名称 例如https://dav.jianguoyun.com/dav/bookmarks
位置2中填入你在坚果云中的注册的用户名，
位置3中填入在坚果云中为第三方应用生产的应用管理密码。
将界面拖下来一点，看到有个“本地文件夹”配置，点击“选择文件夹”，出来的列表中，点击 “书签栏” 右边的“选取”按钮
一般就选择根路径这样书签所有收藏网址都能同步
修改自动同步时间间隔的，默认15分钟，这里我觉得没必要改，或者你觉得要同步间隔有必要调整，也可以修改一下。
设置完毕后，拉倒最底部，点击“保存”。
然后点击“同步”手动启动同步一次。 一般就能够成功把本地的“书签栏”目录中的浏览器同步保存到坚果云中的 我的文件 目录下的 bookmarks.xbel文件中了。
参考学习：
Floccus – 跨平台浏览器「书签同步」插件
WebDAV是什么？网盘的WebDAV有什么用？
yandex的Floccus插件安装教程</description></item><item><title>RabbitMq系列之六：为什么需要主题交换机？</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA/</link><pubDate>Sat, 12 Oct 2019 05:56:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA/</guid><description>为什么需要主题交换机？ （使用Python 客户端 —— pika 0.9.8）
上一篇教程里，我们改进了我们的日志系统。我们使用直连交换机替代了扇型交换机，从只能盲目的广播消息改进为有可能选择性的接收日志。
尽管直连交换机能够改善我们的系统，但是它也有它的限制 —— 没办法基于多个标准执行路由操作。
在我们的日志系统中，我们不只希望订阅基于严重程度的日志，同时还希望订阅基于发送来源的日志。Unix 工具 syslog 就是同时基于严重程度 -severity (info/warn/crit&amp;hellip;) 和 设备 -facility (auth/cron/kern&amp;hellip;) 来路由日志的。
如果这样的话，将会给予我们非常大的灵活性，我们既可以监听来源于 “cron” 的严重程度为 “critical errors” 的日志，也可以监听来源于 “kern” 的所有日志。
为了实现这个目的，接下来我们学习如何使用另一种更复杂的交换机 —— 主题交换机。
主题交换机 发送到主题交换机（topic exchange）的消息不可以携带随意什么样子的路由键（routing_key），它的路由键必须是一个由.分隔开的词语列表。这些单词随便是什么都可以，但是最好是跟携带它们的消息有关系的词汇。以下是几个推荐的例子：&amp;ldquo;stock.usd.nyse&amp;rdquo;, &amp;ldquo;nyse.vmw&amp;rdquo;, &amp;ldquo;quick.orange.rabbit&amp;rdquo;。词语的个数可以随意，但是不要超过 255 字节。
绑定键也必须拥有同样的格式。主题交换机背后的逻辑跟直连交换机很相似 —— 一个携带着特定路由键的消息会被主题交换机投递给绑定键与之想匹配的队列。但是它的绑定键和路由键有两个特殊应用方式：
(星号) 用来表示一个单词. (井号) 用来表示任意数量（零个或多个）单词。 下边用图说明：
这个例子里，我们发送的所有消息都是用来描述小动物的。发送的消息所携带的路由键是由三个单词所组成的，这三个单词被两个.分割开。路由键里的第一个单词描述的是动物的手脚的利索程度，第二个单词是动物的颜色，第三个是动物的种类。所以它看起来是这样的： ..。
我们创建了三个绑定：Q1 的绑定键为 .orange.，Q2 的绑定键为 ..rabbit 和 lazy.# 。
这三个绑定键被可以总结为：
Q1 对所有的桔黄色动物都感兴趣。 Q2 则是对所有的兔子和所有懒惰的动物感兴趣。 一个携带有 quick.orange.rabbit 的消息将会被分别投递给这两个队列。携带着 lazy.orange.elephant 的消息同样也会给两个队列都投递过去。另一方面携带有 quick.orange.fox 的消息会投递给第一个队列，携带有 lazy.brown.fox 的消息会投递给第二个队列。携带有 lazy.</description></item><item><title>RabbitMq系列之五：远程过程调用（RPC）</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc/</link><pubDate>Sat, 12 Oct 2019 05:55:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8rpc/</guid><description>远程过程调用（RPC） （Python客户端 —— 使用 pika 0.9.8）
在第二篇教程中我们介绍了如何使用工作队列（work queue）在多个工作者（woker）中间分发耗时的任务。
可是如果我们需要将一个函数运行在远程计算机上并且等待从那儿获取结果时，该怎么办呢？这就是另外的故事了。这种模式通常被称为远程过程调用（Remote Procedure Call）或者 RPC。
这篇教程中，我们会使用 RabbitMQ 来构建一个 RPC 系统：包含一个客户端和一个 RPC 服务器。现在的情况是，我们没有一个值得被分发的足够耗时的任务，所以接下来，我们会创建一个模拟RPC服务来返回斐波那契数列。
客户端接口 为了展示 RPC 服务如何使用，我们创建了一个简单的客户端类。它会暴露出一个名为 “call” 的方法用来发送一个 RPC 请求，并且在收到回应前保持阻塞。
fibonacci_rpc = FibonacciRpcClient() result = fibonacci_rpc.call(4) print &amp;#34;fib(4) is %r&amp;#34; % (result,) 关于 RPC 的注意事项 尽管 RPC 在计算领域是一个常用模式，但它也经常被诟病。当一个问题被抛出的时候，程序员往往意识不到这到底是由本地调用还是由较慢的 RPC 调用引起的。同样的困惑还来自于系统的不可预测性和给调试工作带来的不必要的复杂性。跟软件精简不同的是，滥用 RPC 会导致不可维护的面条代码.
考虑到这一点，牢记以下建议：
确保能够明确的搞清楚哪个函数是本地调用的，哪个函数是远程调用的。给你的系统编写文档。保持各个组件间的依赖明确。处理错误案例。明了客户端改如何处理 RPC 服务器的宕机和长时间无响应情况。
当对避免使用 RPC 有疑问的时候。如果可以的话，你应该尽量使用异步管道来代替RPC 类的阻塞。结果被异步地推送到下一个计算场景。
回调队列 一般来说通过 RabbitMQ 来实现 RPC 是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址。我们试试看：
result = channel.queue_declare(exclusive=True) callback_queue = result.method.queue channel.</description></item><item><title>RabbitMq系列之四：路由Routing</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E8%B7%AF%E7%94%B1routing/</link><pubDate>Sat, 12 Oct 2019 05:54:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E8%B7%AF%E7%94%B1routing/</guid><description>路由(Routing) （使用pika 0.9.5 Python客户端）
在前面的教程中，我们实现了一个简单的日志系统。可以把日志消息广播给多个接收者。
本篇教程中我们打算新增一个功能 —— 使得它能够只订阅消息的一个字集。例如，我们只需要把严重的错误日志信息写入日志文件（存储到磁盘），但同时仍然把所有的日志信息输出到控制台中
绑定（Bindings） 前面的例子，我们已经创建过绑定（bindings），代码如下：
channel.queue_bind(exchange=exchange_name, queue=queue_name) 绑定（binding）是指交换机（exchange）和队列（queue）的关系。可以简单理解为：这个队列（queue）对这个交换机（exchange）的消息感兴趣。
绑定的时候可以带上一个额外的 routing_key 参数。为了避免与basic_publish的参数混淆，我们把它叫做绑定键（binding key）。以下是如何创建一个带绑定键的绑定。
channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=&amp;#39;black&amp;#39;) 绑定键的意义取决于交换机（exchange）的类型。我们之前使用过的扇型交换机（fanout exchanges）会忽略这个值。
直连交换机（Direct exchange） 我们的日志系统广播所有的消息给所有的消费者（consumers）。我们打算扩展它，使其基于日志的严重程度进行消息过滤。例如我们也许只是希望将比较严重的错误（error）日志写入磁盘，以免在警告（warning）或者信息（info）日志上浪费磁盘空间。
我们使用的扇型交换机（fanout exchange）没有足够的灵活性 —— 它能做的仅仅是广播。
我们将会使用直连交换机（direct exchange）来代替。路由的算法很简单 —— 交换机将会对绑定键（binding key）和路由键（routing key）进行精确匹配，从而确定消息该分发到哪个队列。
下图能够很好的描述这个场景：
在这个场景中，我们可以看到直连交换机 X 和两个队列进行了绑定。第一个队列使用 orange 作为绑定键，第二个队列有两个绑定，一个使用 black 作为绑定键，另外一个使用 green。
这样以来，当路由键为 orange 的消息发布到交换机，就会被路由到队列 Q1。路由键为 black 或者 green 的消息就会路由到 Q2。其他的所有消息都将会被丢弃。
多个绑定（Multiple bindings） 多个队列使用相同的绑定键是合法的。这个例子中，我们可以添加一个 X 和 Q1 之间的绑定，使用 black 绑定键。这样一来，直连交换机就和扇型交换机的行为一样，会将消息广播到所有匹配的队列。带有 black 路由键的消息会同时发送到 Q1 和 Q2。
发送日志 我们将会发送消息到一个直连交换机，把日志级别作为路由键。这样接收日志的脚本就可以根据严重级别来选择它想要处理的日志。我们先看看发送日志。
我们需要创建一个交换机（exchange）：</description></item><item><title>RabbitMq系列之三：发布订阅</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</link><pubDate>Sat, 12 Oct 2019 05:52:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</guid><description>发布／订阅 （使用pika 0.9.5 Python客户端）
在上篇教程中，我们搭建了一个工作队列，每个任务只分发给一个工作者（worker）。在本篇教程中，我们要做的跟之前完全不一样 —— 分发一个消息给多个消费者（consumers）。这种模式被称为“发布／订阅”。
为了描述这种模式，我们将会构建一个简单的日志系统。它包括两个程序——第一个程序负责发送日志消息，第二个程序负责获取消息并输出内容。
在我们的这个日志系统中，所有正在运行的接收方程序都会接受消息。我们用其中一个接收者（receiver）把日志写入硬盘中，另外一个接受者（receiver）把日志输出到屏幕上。
最终，日志消息被广播给所有的接受者（receivers）。
交换机（Exchanges） 前面的教程中，我们发送消息到队列并从中取出消息。现在是时候介绍 RabbitMQ 中完整的消息模型了。
让我们简单的概括一下之前的教程：
发布者（producer）是发布消息的应用程序。 队列（queue）用于消息存储的缓冲。 消费者（consumer）是接收消息的应用程序。 RabbitMQ 消息模型的核心理念是：发布者（producer）不会直接发送任何消息给队列。事实上，发布者（producer）甚至不知道消息是否已经被投递到队列。
发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的。
有几个可供选择的交换机类型：直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout）。我们在这里主要说明最后一个 —— 扇型交换机（fanout）。先创建一个 fanout 类型的交换机，命名为 logs：
channel.exchange_declare(exchange=&amp;#39;logs&amp;#39;, type=&amp;#39;fanout&amp;#39;) 扇型交换机（fanout）很简单，你可能从名字上就能猜测出来，它把消息发送给它所知道的所有队列。这正是我们的日志系统所需要的。
交换器列表 rabbitmqctl 能够列出服务器上所有的交换器：
$ sudo rabbitmqctl list_exchanges Listing exchanges ... logs fanout amq.direct direct amq.topic topic amq.fanout fanout amq.headers headers ...done. 这个列表中有一些叫做 amq.* 的交换器。这些都是默认创建的，不过这时候你还不需要使用他们。
匿名的交换器 前面的教程中我们对交换机一无所知，但仍然能够发送消息到队列中。因为我们使用了命名为空字符串 (&amp;quot;&amp;quot;) 默认的交换机。
回想我们之前是如何发布一则消息：
channel.basic_publish(exchange=&amp;#39;&amp;#39;, routing_key=&amp;#39;hello&amp;#39;, body=message) exchange 参数就是交换机的名称。空字符串代表默认或者匿名交换机：消息将会根据指定的 routing_key 分发到指定的队列。</description></item><item><title>RabbitMq系列之二：工作队列</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/</link><pubDate>Sat, 12 Oct 2019 05:50:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/</guid><description>工作队列 （使用pika 0.9.5 Python客户端）
在第一篇教程中，我们已经写了一个从已知队列中发送和获取消息的程序。在这篇教程中，我们将创建一个工作队列（Work Queue），它会发送一些耗时的任务给多个工作者（Worker）。
工作队列（又称：任务队列——Task Queues）是为了避免等待一些占用大量资源、时间的操作。当我们把任务（Task）当作消息发送到队列中，一个运行在后台的工作者（worker）进程就会取出任务然后处理。当你运行多个工作者（workers），任务就会在它们之间共享。
这个概念在网络应用中是非常有用的，它可以在短暂的 HTTP 请求中处理一些复杂的任务。
准备 之前的教程中，我们发送了一个包含 “Hello World!” 的字符串消息。现在，我们将发送一些字符串，把这些字符串当作复杂的任务。我们没有真实的例子，例如图片缩放、pdf 文件转换。所以使用 time.sleep() 函数来模拟这种情况。我们在字符串中加上点号（.）来表示任务的复杂程度，一个点（.）将会耗时1秒钟。比如 &amp;ldquo;Hello&amp;hellip;&amp;rdquo; 就会耗时3秒钟。
我们对之前教程的 send.py 做些简单的调整，以便可以发送随意的消息。这个程序会按照计划发送任务到我们的工作队列中。我们把它命名为 new_task.py：
import sys message = &amp;#39; &amp;#39;.join(sys.argv[1:]) or &amp;#34;Hello World!&amp;#34; channel.basic_publish(exchange=&amp;#39;&amp;#39;, routing_key=&amp;#39;hello&amp;#39;, body=message) print &amp;#34; [x] Sent %r&amp;#34; % (message,) 我们的旧脚本（receive.py）同样需要做一些改动：它需要为消息体中每一个点号（.）模拟1秒钟的操作。它会从队列中获取消息并执行，我们把它命名为 worker.py：
import time def callback(ch, method, properties, body): print &amp;#34; [x] Received %r&amp;#34; % (body,) time.sleep( body.count(&amp;#39;.&amp;#39;) ) print &amp;#34; [x] Done&amp;#34; 循环调度 使用工作队列的一个好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了，扩展很简单。
首先，我们先同时运行两个 worker.</description></item><item><title>RabbitMq系列之一：介绍</title><link>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E4%BB%8B%E7%BB%8D/</link><pubDate>Sat, 12 Oct 2019 05:49:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2019/rabbitmq%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E4%BB%8B%E7%BB%8D/</guid><description/></item><item><title>使用UnblockNeteaseMusic播放网易云音乐客户端无版权歌曲</title><link>https://blog.ch3nnn.cn/posts/2018/%E4%BD%BF%E7%94%A8unblockneteasemusic%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E7%89%88%E6%9D%83%E6%AD%8C%E6%9B%B2/</link><pubDate>Sun, 18 Feb 2018 03:56:00 +0800</pubDate><guid>https://blog.ch3nnn.cn/posts/2018/%E4%BD%BF%E7%94%A8unblockneteasemusic%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E7%89%88%E6%9D%83%E6%AD%8C%E6%9B%B2/</guid><description>说明：UnblockNeteaseMusic是一款可以给你解除网易云音乐海外限制并解锁变灰(无版权)歌曲的工具，让你可以听取客户端任何的歌曲，而不受到限制，此前该类似工具挺多的，不过貌似都不维护或者失效了，这里提到的项目更新很频繁，支持Windows、MacOS、安卓、IOS等设备，所以就分享一下使用方法。
截图 特性 使用网易云旧链/QQ/虾米/百度/酷狗/酷我/咕咪/JOOX音源替换变灰歌曲链接(默认仅启用前四)。 为请求增加X-Real-IP参数解锁海外限制，支持指定网易云服务器IP，支持设置上游HTTP/HTTPS代理。 完整的流量代理功能(HTTP/HTTPS)，可直接作为系统代理(同时支持PAC)。 安装 Github地址：https://github.com/nondanee/UnblockNeteaseMusic
1、安装Nodejs
#Debian/Ubuntu系统 curl -sL https://deb.nodesource.com/setup_10.x | bash - apt install -y nodejs git #CentOS系统 curl -sL https://rpm.nodesource.com/setup_10.x | bash - yum install nodejs git -y 2、运行UnblockNeteaseMusic
git clone https://github.com/nondanee/UnblockNeteaseMusic.git cd UnblockNeteaseMusic node app.js 运行端口默认为8080，需要想修改可以编辑app.js文件的config.port对应的数值，或者使用命令：
#这里默认修改4567，自行调整 node app.js -p 4567 这里还可以加一个-s参数限制代理范围防止被滥用，也就是仅放行网易云音乐所属域名的请求，不过使用起来的话就受限了，仅支持PAC或Hosts。
node app.js -s 3、开机自启
这里使用Systemd进程守护，只适用于CentOS 7、Debian 8+、Ubuntu 16+等。
#修改下ExecStartPre源码路径即可，然后一起复制到SSH运行 cat &amp;gt; /etc/systemd/system/UnblockNeteaseMusic.service &amp;lt;&amp;lt;EOF [Unit] Description=UnblockNeteaseMusic After=network.target Wants=network.target [Service] Type=simple PIDFile=/var/run/UnblockNeteaseMusic.pid WorkingDirectory=/root/UnblockNeteaseMusic ExecStart=$(command -v node) app.</description></item></channel></rss>